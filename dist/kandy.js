/**
 * Kandy.js (Next)
 * kandy.cpaas2.js
 * Version: 3.3.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Kandy"] = factory();
	else
		root["Kandy"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.cpaas2.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/babel-runtime/core-js/array/from.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/array/from.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/json/stringify.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/json/stringify.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/map.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/map.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/assign.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/create.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/create.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/define-properties.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-properties.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/define-property.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/entries.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/entries.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/freeze.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-own-property-descriptor.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/get-own-property-symbols.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-own-property-symbols.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/keys.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/object/values.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/values.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/promise.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/symbol.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/symbol/for.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/for.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/core-js/symbol/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "../../node_modules/babel-runtime/helpers/extends.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "../../node_modules/babel-runtime/helpers/objectWithoutProperties.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/array/from.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.from.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Array.from;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/json/stringify.js":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/map.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.map.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.to-json.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.of.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.from.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Map;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/create.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-properties.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-properties.js");
var $Object = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/entries.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.object.entries.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.entries;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.freeze.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.freeze;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-own-property-descriptor.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js");
var $Object = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-own-property-symbols.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.getOwnPropertySymbols;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.get-prototype-of.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.getPrototypeOf;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.keys;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/object/values.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.object.values.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object.values;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.finally.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.try.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Promise;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/for.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Symbol['for'];


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/index.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/fn/symbol/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-from-iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js":
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-strong.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var create = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
var redefineAll = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var anInstance = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var $iterDefine = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js");
var step = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
var setSpecies = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
var fastKey = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").fastKey;
var validate = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
var from = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-from-iterable.js");
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_create-property.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js":
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var macrotask = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js":
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn-ext.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-to-array.js":
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var isEnum = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js").f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var newPromiseCapability = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js":
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var aFunction = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
var SPECIES = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_string-at.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js":
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var invoke = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js");
var html = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js");
var cel = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js");
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_user-agent.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js":
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.from.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var call = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
var toLength = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var createProperty = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_create-property.js");
var getIterFn = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-strong.js");
var validate = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.create.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js") });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-properties.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperties: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js") });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.freeze.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var meta = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").onFreeze;

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js").f;

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.get-prototype-of.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js");

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js":
/***/ (function(module, exports) {



/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var ctx = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var classof = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var aFunction = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
var anInstance = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var speciesConstructor = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js");
var task = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set;
var microtask = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js");
var userAgent = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_user-agent.js");
var promiseResolve = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.string.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var toIObject = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopd.js");
var $DP = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.from.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js")('Map');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.of.js":
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js")('Map');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.map.to-json.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-to-json.js")('Map') });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.object.entries.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var $entries = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.object.values.js":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var $values = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.finally.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var speciesConstructor = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js");
var promiseResolve = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.promise.try.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var newPromiseCapability = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/es7.symbol.observable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "../../node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__("../../node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "../../node_modules/decode-uri-component/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ "../../node_modules/error-stack-parser/error-stack-parser.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("../../node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "../../node_modules/eventemitter3/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../../node_modules/events/events.js":
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "../../node_modules/fetch-ponyfill/build/fetch-browser.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function (self) {
  'use strict';

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {
        'use strict';

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob()
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        }

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ]

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          }

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          }
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name)
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value)
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift()
              return {done: value === undefined, value: value}
            }
          }

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            }
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {}

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value)
            }, this)
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1])
            }, this)
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name])
            }, this)
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name)
          value = normalizeValue(value)
          var oldValue = this.map[name]
          this.map[name] = oldValue ? oldValue+','+value : value
        }

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)]
        }

        Headers.prototype.get = function(name) {
          name = normalizeName(name)
          return this.has(name) ? this.map[name] : null
        }

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this)
            }
          }
        }

        Headers.prototype.keys = function() {
          var items = []
          this.forEach(function(value, name) { items.push(name) })
          return iteratorFor(items)
        }

        Headers.prototype.values = function() {
          var items = []
          this.forEach(function(value) { items.push(value) })
          return iteratorFor(items)
        }

        Headers.prototype.entries = function() {
          var items = []
          this.forEach(function(value, name) { items.push([name, value]) })
          return iteratorFor(items)
        }

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result)
            }
            reader.onerror = function() {
              reject(reader.error)
            }
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsArrayBuffer(blob)
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsText(blob)
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf)
          var chars = new Array(view.length)

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i])
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength)
            view.set(new Uint8Array(buf))
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false

          this._initBody = function(body) {
            this._bodyInit = body
            if (!body) {
              this._bodyText = ''
            } else if (typeof body === 'string') {
              this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString()
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer)
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer])
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body)
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8')
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type)
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
              }
            }
          }

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this)
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            }

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            }
          }

          this.text = function() {
            var rejected = consumed(this)
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          }

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            }
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          }

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

        function normalizeMethod(method) {
          var upcased = method.toUpperCase()
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {}
          var body = options.body

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url
            this.credentials = input.credentials
            if (!options.headers) {
              this.headers = new Headers(input.headers)
            }
            this.method = input.method
            this.mode = input.mode
            if (!body && input._bodyInit != null) {
              body = input._bodyInit
              input.bodyUsed = true
            }
          } else {
            this.url = String(input)
          }

          this.credentials = options.credentials || this.credentials || 'omit'
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers)
          }
          this.method = normalizeMethod(options.method || this.method || 'GET')
          this.mode = options.mode || this.mode || null
          this.referrer = null

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body)
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        }

        function decode(body) {
          var form = new FormData()
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=')
              var name = split.shift().replace(/\+/g, ' ')
              var value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          })
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers()
          rawHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':')
            var key = parts.shift().trim()
            if (key) {
              var value = parts.join(':').trim()
              headers.append(key, value)
            }
          })
          return headers
        }

        Body.call(Request.prototype)

        function Response(bodyInit, options) {
          if (!options) {
            options = {}
          }

          this.type = 'default'
          this.status = 'status' in options ? options.status : 200
          this.ok = this.status >= 200 && this.status < 300
          this.statusText = 'statusText' in options ? options.statusText : 'OK'
          this.headers = new Headers(options.headers)
          this.url = options.url || ''
          this._initBody(bodyInit)
        }

        Body.call(Response.prototype)

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''})
          response.type = 'error'
          return response
        }

        var redirectStatuses = [301, 302, 303, 307, 308]

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        }

        self.Headers = Headers
        self.Request = Request
        self.Response = Response

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init)
            var xhr = new XMLHttpRequest()

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
              xhr.withCredentials = true
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob'
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
          })
        }
        self.fetch.polyfill = true
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return fetchPonyfill;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self === 'undefined' ? this : self));



/***/ }),

/***/ "../../node_modules/inherits/inherits_browser.js":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/just-curry-it/index.js":
/***/ (function(module, exports) {

module.exports = curry;

/*
  function add(a, b, c) {
    return a + b + c;
  }
  curry(add)(1)(2)(3); // 6
  curry(add)(1)(2)(2); // 5
  curry(add)(2)(4, 3); // 9

  function add(...args) {
    return args.reduce((sum, n) => sum + n, 0)
  }
  var curryAdd4 = curry(add, 4)
  curryAdd4(1)(2, 3)(4); // 10

  function converter(ratio, input) {
    return (input*ratio).toFixed(1);
  }
  const curriedConverter = curry(converter)
  const milesToKm = curriedConverter(1.62);
  milesToKm(35); // 56.7
  milesToKm(10); // 16.2
*/

function curry(fn, arity) {
  return function curried() {
    if (arity == null) {
      arity = fn.length;
    }
    var args = [].slice.call(arguments);
    if (args.length >= arity) {
      return fn.apply(this, args);
    } else {
      return function() {
        return curried.apply(this, args.concat([].slice.call(arguments)));
      };
    }
  };
}


/***/ }),

/***/ "../../node_modules/jwt-decode/lib/atob.js":
/***/ (function(module, exports) {

/**
 * The code was extracted from:
 * https://github.com/davidchambers/Base64.js
 */

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}

InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

function polyfill (input) {
  var str = String(input).replace(/=+$/, '');
  if (str.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = str.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
}


module.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;


/***/ }),

/***/ "../../node_modules/jwt-decode/lib/base64_url_decode.js":
/***/ (function(module, exports, __webpack_require__) {

var atob = __webpack_require__("../../node_modules/jwt-decode/lib/atob.js");

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  }));
}

module.exports = function(str) {
  var output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }

  try{
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
};


/***/ }),

/***/ "../../node_modules/jwt-decode/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var base64_url_decode = __webpack_require__("../../node_modules/jwt-decode/lib/base64_url_decode.js");

function InvalidTokenError(message) {
  this.message = message;
}

InvalidTokenError.prototype = new Error();
InvalidTokenError.prototype.name = 'InvalidTokenError';

module.exports = function (token,options) {
  if (typeof token !== 'string') {
    throw new InvalidTokenError('Invalid token specified');
  }

  options = options || {};
  var pos = options.header === true ? 0 : 1;
  try {
    return JSON.parse(base64_url_decode(token.split('.')[pos]));
  } catch (e) {
    throw new InvalidTokenError('Invalid token specified: ' + e.message);
  }
};

module.exports.InvalidTokenError = InvalidTokenError;


/***/ }),

/***/ "../../node_modules/lodash-es/_Symbol.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;

/* harmony default export */ __webpack_exports__["default"] = (Symbol);


/***/ }),

/***/ "../../node_modules/lodash-es/_baseGetTag.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/lodash-es/_getRawTag.js");
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/lodash-es/_objectToString.js");




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? Object(_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
    : Object(_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ __webpack_exports__["default"] = (baseGetTag);


/***/ }),

/***/ "../../node_modules/lodash-es/_freeGlobal.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["default"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/lodash-es/_getPrototype.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_overArg.js");


/** Built-in value references. */
var getPrototype = Object(_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["default"] = (getPrototype);


/***/ }),

/***/ "../../node_modules/lodash-es/_getRawTag.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_Symbol.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (getRawTag);


/***/ }),

/***/ "../../node_modules/lodash-es/_objectToString.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["default"] = (objectToString);


/***/ }),

/***/ "../../node_modules/lodash-es/_overArg.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (overArg);


/***/ }),

/***/ "../../node_modules/lodash-es/_root.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["default"] = (root);


/***/ }),

/***/ "../../node_modules/lodash-es/isObjectLike.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["default"] = (isObjectLike);


/***/ }),

/***/ "../../node_modules/lodash-es/isPlainObject.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/lodash-es/_getPrototype.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/lodash-es/isObjectLike.js");




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) != objectTag) {
    return false;
  }
  var proto = Object(_getPrototype_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["default"] = (isPlainObject);


/***/ }),

/***/ "../../node_modules/lodash/fp.js":
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__("../../node_modules/lodash/lodash.min.js").runInContext();
module.exports = __webpack_require__("../../node_modules/lodash/fp/_baseConvert.js")(_, _);


/***/ }),

/***/ "../../node_modules/lodash/fp/_baseConvert.js":
/***/ (function(module, exports, __webpack_require__) {

var mapping = __webpack_require__("../../node_modules/lodash/fp/_mapping.js"),
    fallbackHolder = __webpack_require__("../../node_modules/lodash/fp/placeholder.js");

/** Built-in value reference. */
var push = Array.prototype.push;

/**
 * Creates a function, with an arity of `n`, that invokes `func` with the
 * arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} n The arity of the new function.
 * @returns {Function} Returns the new function.
 */
function baseArity(func, n) {
  return n == 2
    ? function(a, b) { return func.apply(undefined, arguments); }
    : function(a) { return func.apply(undefined, arguments); };
}

/**
 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
 * any additional arguments.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @param {number} n The arity cap.
 * @returns {Function} Returns the new function.
 */
function baseAry(func, n) {
  return n == 2
    ? function(a, b) { return func(a, b); }
    : function(a) { return func(a); };
}

/**
 * Creates a clone of `array`.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the cloned array.
 */
function cloneArray(array) {
  var length = array ? array.length : 0,
      result = Array(length);

  while (length--) {
    result[length] = array[length];
  }
  return result;
}

/**
 * Creates a function that clones a given object using the assignment `func`.
 *
 * @private
 * @param {Function} func The assignment function.
 * @returns {Function} Returns the new cloner function.
 */
function createCloner(func) {
  return function(object) {
    return func({}, object);
  };
}

/**
 * A specialized version of `_.spread` which flattens the spread array into
 * the arguments of the invoked `func`.
 *
 * @private
 * @param {Function} func The function to spread arguments over.
 * @param {number} start The start position of the spread.
 * @returns {Function} Returns the new function.
 */
function flatSpread(func, start) {
  return function() {
    var length = arguments.length,
        lastIndex = length - 1,
        args = Array(length);

    while (length--) {
      args[length] = arguments[length];
    }
    var array = args[start],
        otherArgs = args.slice(0, start);

    if (array) {
      push.apply(otherArgs, array);
    }
    if (start != lastIndex) {
      push.apply(otherArgs, args.slice(start + 1));
    }
    return func.apply(this, otherArgs);
  };
}

/**
 * Creates a function that wraps `func` and uses `cloner` to clone the first
 * argument it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} cloner The function to clone arguments.
 * @returns {Function} Returns the new immutable function.
 */
function wrapImmutable(func, cloner) {
  return function() {
    var length = arguments.length;
    if (!length) {
      return;
    }
    var args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var result = args[0] = cloner.apply(undefined, args);
    func.apply(undefined, args);
    return result;
  };
}

/**
 * The base implementation of `convert` which accepts a `util` object of methods
 * required to perform conversions.
 *
 * @param {Object} util The util object.
 * @param {string} name The name of the function to convert.
 * @param {Function} func The function to convert.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
 * @param {boolean} [options.curry=true] Specify currying.
 * @param {boolean} [options.fixed=true] Specify fixed arity.
 * @param {boolean} [options.immutable=true] Specify immutable operations.
 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
 * @returns {Function|Object} Returns the converted function or object.
 */
function baseConvert(util, name, func, options) {
  var isLib = typeof name == 'function',
      isObj = name === Object(name);

  if (isObj) {
    options = func;
    func = name;
    name = undefined;
  }
  if (func == null) {
    throw new TypeError;
  }
  options || (options = {});

  var config = {
    'cap': 'cap' in options ? options.cap : true,
    'curry': 'curry' in options ? options.curry : true,
    'fixed': 'fixed' in options ? options.fixed : true,
    'immutable': 'immutable' in options ? options.immutable : true,
    'rearg': 'rearg' in options ? options.rearg : true
  };

  var defaultHolder = isLib ? func : fallbackHolder,
      forceCurry = ('curry' in options) && options.curry,
      forceFixed = ('fixed' in options) && options.fixed,
      forceRearg = ('rearg' in options) && options.rearg,
      pristine = isLib ? func.runInContext() : undefined;

  var helpers = isLib ? func : {
    'ary': util.ary,
    'assign': util.assign,
    'clone': util.clone,
    'curry': util.curry,
    'forEach': util.forEach,
    'isArray': util.isArray,
    'isError': util.isError,
    'isFunction': util.isFunction,
    'isWeakMap': util.isWeakMap,
    'iteratee': util.iteratee,
    'keys': util.keys,
    'rearg': util.rearg,
    'toInteger': util.toInteger,
    'toPath': util.toPath
  };

  var ary = helpers.ary,
      assign = helpers.assign,
      clone = helpers.clone,
      curry = helpers.curry,
      each = helpers.forEach,
      isArray = helpers.isArray,
      isError = helpers.isError,
      isFunction = helpers.isFunction,
      isWeakMap = helpers.isWeakMap,
      keys = helpers.keys,
      rearg = helpers.rearg,
      toInteger = helpers.toInteger,
      toPath = helpers.toPath;

  var aryMethodKeys = keys(mapping.aryMethod);

  var wrappers = {
    'castArray': function(castArray) {
      return function() {
        var value = arguments[0];
        return isArray(value)
          ? castArray(cloneArray(value))
          : castArray.apply(undefined, arguments);
      };
    },
    'iteratee': function(iteratee) {
      return function() {
        var func = arguments[0],
            arity = arguments[1],
            result = iteratee(func, arity),
            length = result.length;

        if (config.cap && typeof arity == 'number') {
          arity = arity > 2 ? (arity - 2) : 1;
          return (length && length <= arity) ? result : baseAry(result, arity);
        }
        return result;
      };
    },
    'mixin': function(mixin) {
      return function(source) {
        var func = this;
        if (!isFunction(func)) {
          return mixin(func, Object(source));
        }
        var pairs = [];
        each(keys(source), function(key) {
          if (isFunction(source[key])) {
            pairs.push([key, func.prototype[key]]);
          }
        });

        mixin(func, Object(source));

        each(pairs, function(pair) {
          var value = pair[1];
          if (isFunction(value)) {
            func.prototype[pair[0]] = value;
          } else {
            delete func.prototype[pair[0]];
          }
        });
        return func;
      };
    },
    'nthArg': function(nthArg) {
      return function(n) {
        var arity = n < 0 ? 1 : (toInteger(n) + 1);
        return curry(nthArg(n), arity);
      };
    },
    'rearg': function(rearg) {
      return function(func, indexes) {
        var arity = indexes ? indexes.length : 0;
        return curry(rearg(func, indexes), arity);
      };
    },
    'runInContext': function(runInContext) {
      return function(context) {
        return baseConvert(util, runInContext(context), options);
      };
    }
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Casts `func` to a function with an arity capped iteratee if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @returns {Function} Returns the cast function.
   */
  function castCap(name, func) {
    if (config.cap) {
      var indexes = mapping.iterateeRearg[name];
      if (indexes) {
        return iterateeRearg(func, indexes);
      }
      var n = !isLib && mapping.iterateeAry[name];
      if (n) {
        return iterateeAry(func, n);
      }
    }
    return func;
  }

  /**
   * Casts `func` to a curried function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castCurry(name, func, n) {
    return (forceCurry || (config.curry && n > 1))
      ? curry(func, n)
      : func;
  }

  /**
   * Casts `func` to a fixed arity function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the cast function.
   */
  function castFixed(name, func, n) {
    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
      var data = mapping.methodSpread[name],
          start = data && data.start;

      return start  === undefined ? ary(func, n) : flatSpread(func, start);
    }
    return func;
  }

  /**
   * Casts `func` to an rearged function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castRearg(name, func, n) {
    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))
      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])
      : func;
  }

  /**
   * Creates a clone of `object` by `path`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {Array|string} path The path to clone by.
   * @returns {Object} Returns the cloned object.
   */
  function cloneByPath(object, path) {
    path = toPath(path);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        result = clone(Object(object)),
        nested = result;

    while (nested != null && ++index < length) {
      var key = path[index],
          value = nested[key];

      if (value != null &&
          !(isFunction(value) || isError(value) || isWeakMap(value))) {
        nested[key] = clone(index == lastIndex ? value : Object(value));
      }
      nested = nested[key];
    }
    return result;
  }

  /**
   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
   * version with conversion `options` applied.
   *
   * @param {Object} [options] The options object. See `baseConvert` for more details.
   * @returns {Function} Returns the converted `lodash`.
   */
  function convertLib(options) {
    return _.runInContext.convert(options)(undefined);
  }

  /**
   * Create a converter function for `func` of `name`.
   *
   * @param {string} name The name of the function to convert.
   * @param {Function} func The function to convert.
   * @returns {Function} Returns the new converter function.
   */
  function createConverter(name, func) {
    var realName = mapping.aliasToReal[name] || name,
        methodName = mapping.remap[realName] || realName,
        oldOptions = options;

    return function(options) {
      var newUtil = isLib ? pristine : helpers,
          newFunc = isLib ? pristine[methodName] : func,
          newOptions = assign(assign({}, oldOptions), options);

      return baseConvert(newUtil, realName, newFunc, newOptions);
    };
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
   * arguments, ignoring any additional arguments.
   *
   * @private
   * @param {Function} func The function to cap iteratee arguments for.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the new function.
   */
  function iterateeAry(func, n) {
    return overArg(func, function(func) {
      return typeof func == 'function' ? baseAry(func, n) : func;
    });
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee with arguments
   * arranged according to the specified `indexes` where the argument value at
   * the first index is provided as the first argument, the argument value at
   * the second index is provided as the second argument, and so on.
   *
   * @private
   * @param {Function} func The function to rearrange iteratee arguments for.
   * @param {number[]} indexes The arranged argument indexes.
   * @returns {Function} Returns the new function.
   */
  function iterateeRearg(func, indexes) {
    return overArg(func, function(func) {
      var n = indexes.length;
      return baseArity(rearg(baseAry(func, n), indexes), n);
    });
  }

  /**
   * Creates a function that invokes `func` with its first argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function() {
      var length = arguments.length;
      if (!length) {
        return func();
      }
      var args = Array(length);
      while (length--) {
        args[length] = arguments[length];
      }
      var index = config.rearg ? 0 : (length - 1);
      args[index] = transform(args[index]);
      return func.apply(undefined, args);
    };
  }

  /**
   * Creates a function that wraps `func` and applys the conversions
   * rules by `name`.
   *
   * @private
   * @param {string} name The name of the function to wrap.
   * @param {Function} func The function to wrap.
   * @returns {Function} Returns the converted function.
   */
  function wrap(name, func, placeholder) {
    var result,
        realName = mapping.aliasToReal[name] || name,
        wrapped = func,
        wrapper = wrappers[realName];

    if (wrapper) {
      wrapped = wrapper(func);
    }
    else if (config.immutable) {
      if (mapping.mutate.array[realName]) {
        wrapped = wrapImmutable(func, cloneArray);
      }
      else if (mapping.mutate.object[realName]) {
        wrapped = wrapImmutable(func, createCloner(func));
      }
      else if (mapping.mutate.set[realName]) {
        wrapped = wrapImmutable(func, cloneByPath);
      }
    }
    each(aryMethodKeys, function(aryKey) {
      each(mapping.aryMethod[aryKey], function(otherName) {
        if (realName == otherName) {
          var data = mapping.methodSpread[realName],
              afterRearg = data && data.afterRearg;

          result = afterRearg
            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)
            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);

          result = castCap(realName, result);
          result = castCurry(realName, result, aryKey);
          return false;
        }
      });
      return !result;
    });

    result || (result = wrapped);
    if (result == func) {
      result = forceCurry ? curry(result, 1) : function() {
        return func.apply(this, arguments);
      };
    }
    result.convert = createConverter(realName, func);
    result.placeholder = func.placeholder = placeholder;

    return result;
  }

  /*--------------------------------------------------------------------------*/

  if (!isObj) {
    return wrap(name, func, defaultHolder);
  }
  var _ = func;

  // Convert methods by ary cap.
  var pairs = [];
  each(aryMethodKeys, function(aryKey) {
    each(mapping.aryMethod[aryKey], function(key) {
      var func = _[mapping.remap[key] || key];
      if (func) {
        pairs.push([key, wrap(key, func, _)]);
      }
    });
  });

  // Convert remaining methods.
  each(keys(_), function(key) {
    var func = _[key];
    if (typeof func == 'function') {
      var length = pairs.length;
      while (length--) {
        if (pairs[length][0] == key) {
          return;
        }
      }
      func.convert = createConverter(key, func);
      pairs.push([key, func]);
    }
  });

  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.
  each(pairs, function(pair) {
    _[pair[0]] = pair[1];
  });

  _.convert = convertLib;
  _.placeholder = _;

  // Assign aliases.
  each(keys(_), function(key) {
    each(mapping.realToAlias[key] || [], function(alias) {
      _[alias] = _[key];
    });
  });

  return _;
}

module.exports = baseConvert;


/***/ }),

/***/ "../../node_modules/lodash/fp/_mapping.js":
/***/ (function(module, exports) {

/** Used to map aliases to their real names. */
exports.aliasToReal = {

  // Lodash aliases.
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'entries': 'toPairs',
  'entriesIn': 'toPairsIn',
  'extend': 'assignIn',
  'extendAll': 'assignInAll',
  'extendAllWith': 'assignInAllWith',
  'extendWith': 'assignInWith',
  'first': 'head',

  // Methods that are curried variants of others.
  'conforms': 'conformsTo',
  'matches': 'isMatch',
  'property': 'get',

  // Ramda aliases.
  '__': 'placeholder',
  'F': 'stubFalse',
  'T': 'stubTrue',
  'all': 'every',
  'allPass': 'overEvery',
  'always': 'constant',
  'any': 'some',
  'anyPass': 'overSome',
  'apply': 'spread',
  'assoc': 'set',
  'assocPath': 'set',
  'complement': 'negate',
  'compose': 'flowRight',
  'contains': 'includes',
  'dissoc': 'unset',
  'dissocPath': 'unset',
  'dropLast': 'dropRight',
  'dropLastWhile': 'dropRightWhile',
  'equals': 'isEqual',
  'identical': 'eq',
  'indexBy': 'keyBy',
  'init': 'initial',
  'invertObj': 'invert',
  'juxt': 'over',
  'omitAll': 'omit',
  'nAry': 'ary',
  'path': 'get',
  'pathEq': 'matchesProperty',
  'pathOr': 'getOr',
  'paths': 'at',
  'pickAll': 'pick',
  'pipe': 'flow',
  'pluck': 'map',
  'prop': 'get',
  'propEq': 'matchesProperty',
  'propOr': 'getOr',
  'props': 'at',
  'symmetricDifference': 'xor',
  'symmetricDifferenceBy': 'xorBy',
  'symmetricDifferenceWith': 'xorWith',
  'takeLast': 'takeRight',
  'takeLastWhile': 'takeRightWhile',
  'unapply': 'rest',
  'unnest': 'flatten',
  'useWith': 'overArgs',
  'where': 'conformsTo',
  'whereEq': 'isMatch',
  'zipObj': 'zipObject'
};

/** Used to map ary to method names. */
exports.aryMethod = {
  '1': [
    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',
    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',
    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',
    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',
    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',
    'uniqueId', 'words', 'zipAll'
  ],
  '2': [
    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',
    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',
    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',
    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',
    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',
    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',
    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',
    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',
    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',
    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',
    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',
    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',
    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',
    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',
    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',
    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',
    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',
    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',
    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',
    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',
    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',
    'zipObjectDeep'
  ],
  '3': [
    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',
    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',
    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',
    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',
    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',
    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',
    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',
    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',
    'xorWith', 'zipWith'
  ],
  '4': [
    'fill', 'setWith', 'updateWith'
  ]
};

/** Used to map ary to rearg configs. */
exports.aryRearg = {
  '2': [1, 0],
  '3': [2, 0, 1],
  '4': [3, 2, 0, 1]
};

/** Used to map method names to their iteratee ary. */
exports.iterateeAry = {
  'dropRightWhile': 1,
  'dropWhile': 1,
  'every': 1,
  'filter': 1,
  'find': 1,
  'findFrom': 1,
  'findIndex': 1,
  'findIndexFrom': 1,
  'findKey': 1,
  'findLast': 1,
  'findLastFrom': 1,
  'findLastIndex': 1,
  'findLastIndexFrom': 1,
  'findLastKey': 1,
  'flatMap': 1,
  'flatMapDeep': 1,
  'flatMapDepth': 1,
  'forEach': 1,
  'forEachRight': 1,
  'forIn': 1,
  'forInRight': 1,
  'forOwn': 1,
  'forOwnRight': 1,
  'map': 1,
  'mapKeys': 1,
  'mapValues': 1,
  'partition': 1,
  'reduce': 2,
  'reduceRight': 2,
  'reject': 1,
  'remove': 1,
  'some': 1,
  'takeRightWhile': 1,
  'takeWhile': 1,
  'times': 1,
  'transform': 2
};

/** Used to map method names to iteratee rearg configs. */
exports.iterateeRearg = {
  'mapKeys': [1],
  'reduceRight': [1, 0]
};

/** Used to map method names to rearg configs. */
exports.methodRearg = {
  'assignInAllWith': [1, 0],
  'assignInWith': [1, 2, 0],
  'assignAllWith': [1, 0],
  'assignWith': [1, 2, 0],
  'differenceBy': [1, 2, 0],
  'differenceWith': [1, 2, 0],
  'getOr': [2, 1, 0],
  'intersectionBy': [1, 2, 0],
  'intersectionWith': [1, 2, 0],
  'isEqualWith': [1, 2, 0],
  'isMatchWith': [2, 1, 0],
  'mergeAllWith': [1, 0],
  'mergeWith': [1, 2, 0],
  'padChars': [2, 1, 0],
  'padCharsEnd': [2, 1, 0],
  'padCharsStart': [2, 1, 0],
  'pullAllBy': [2, 1, 0],
  'pullAllWith': [2, 1, 0],
  'rangeStep': [1, 2, 0],
  'rangeStepRight': [1, 2, 0],
  'setWith': [3, 1, 2, 0],
  'sortedIndexBy': [2, 1, 0],
  'sortedLastIndexBy': [2, 1, 0],
  'unionBy': [1, 2, 0],
  'unionWith': [1, 2, 0],
  'updateWith': [3, 1, 2, 0],
  'xorBy': [1, 2, 0],
  'xorWith': [1, 2, 0],
  'zipWith': [1, 2, 0]
};

/** Used to map method names to spread configs. */
exports.methodSpread = {
  'assignAll': { 'start': 0 },
  'assignAllWith': { 'start': 0 },
  'assignInAll': { 'start': 0 },
  'assignInAllWith': { 'start': 0 },
  'defaultsAll': { 'start': 0 },
  'defaultsDeepAll': { 'start': 0 },
  'invokeArgs': { 'start': 2 },
  'invokeArgsMap': { 'start': 2 },
  'mergeAll': { 'start': 0 },
  'mergeAllWith': { 'start': 0 },
  'partial': { 'start': 1 },
  'partialRight': { 'start': 1 },
  'without': { 'start': 1 },
  'zipAll': { 'start': 0 }
};

/** Used to identify methods which mutate arrays or objects. */
exports.mutate = {
  'array': {
    'fill': true,
    'pull': true,
    'pullAll': true,
    'pullAllBy': true,
    'pullAllWith': true,
    'pullAt': true,
    'remove': true,
    'reverse': true
  },
  'object': {
    'assign': true,
    'assignAll': true,
    'assignAllWith': true,
    'assignIn': true,
    'assignInAll': true,
    'assignInAllWith': true,
    'assignInWith': true,
    'assignWith': true,
    'defaults': true,
    'defaultsAll': true,
    'defaultsDeep': true,
    'defaultsDeepAll': true,
    'merge': true,
    'mergeAll': true,
    'mergeAllWith': true,
    'mergeWith': true,
  },
  'set': {
    'set': true,
    'setWith': true,
    'unset': true,
    'update': true,
    'updateWith': true
  }
};

/** Used to map real names to their aliases. */
exports.realToAlias = (function() {
  var hasOwnProperty = Object.prototype.hasOwnProperty,
      object = exports.aliasToReal,
      result = {};

  for (var key in object) {
    var value = object[key];
    if (hasOwnProperty.call(result, value)) {
      result[value].push(key);
    } else {
      result[value] = [key];
    }
  }
  return result;
}());

/** Used to map method names to other names. */
exports.remap = {
  'assignAll': 'assign',
  'assignAllWith': 'assignWith',
  'assignInAll': 'assignIn',
  'assignInAllWith': 'assignInWith',
  'curryN': 'curry',
  'curryRightN': 'curryRight',
  'defaultsAll': 'defaults',
  'defaultsDeepAll': 'defaultsDeep',
  'findFrom': 'find',
  'findIndexFrom': 'findIndex',
  'findLastFrom': 'findLast',
  'findLastIndexFrom': 'findLastIndex',
  'getOr': 'get',
  'includesFrom': 'includes',
  'indexOfFrom': 'indexOf',
  'invokeArgs': 'invoke',
  'invokeArgsMap': 'invokeMap',
  'lastIndexOfFrom': 'lastIndexOf',
  'mergeAll': 'merge',
  'mergeAllWith': 'mergeWith',
  'padChars': 'pad',
  'padCharsEnd': 'padEnd',
  'padCharsStart': 'padStart',
  'propertyOf': 'get',
  'rangeStep': 'range',
  'rangeStepRight': 'rangeRight',
  'restFrom': 'rest',
  'spreadFrom': 'spread',
  'trimChars': 'trim',
  'trimCharsEnd': 'trimEnd',
  'trimCharsStart': 'trimStart',
  'zipAll': 'zip'
};

/** Used to track methods that skip fixing their arity. */
exports.skipFixed = {
  'castArray': true,
  'flow': true,
  'flowRight': true,
  'iteratee': true,
  'mixin': true,
  'rearg': true,
  'runInContext': true
};

/** Used to track methods that skip rearranging arguments. */
exports.skipRearg = {
  'add': true,
  'assign': true,
  'assignIn': true,
  'bind': true,
  'bindKey': true,
  'concat': true,
  'difference': true,
  'divide': true,
  'eq': true,
  'gt': true,
  'gte': true,
  'isEqual': true,
  'lt': true,
  'lte': true,
  'matchesProperty': true,
  'merge': true,
  'multiply': true,
  'overArgs': true,
  'partial': true,
  'partialRight': true,
  'propertyOf': true,
  'random': true,
  'range': true,
  'rangeRight': true,
  'subtract': true,
  'zip': true,
  'zipObject': true,
  'zipObjectDeep': true
};


/***/ }),

/***/ "../../node_modules/lodash/fp/placeholder.js":
/***/ (function(module, exports) {

/**
 * The default argument placeholder value for methods.
 *
 * @type {Object}
 */
module.exports = {};


/***/ }),

/***/ "../../node_modules/lodash/lodash.min.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function e(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;
return true}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!(null==n||!n.length)&&-1<v(n,t,0)}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function p(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function _(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function v(n,t,r){if(t===t)n:{--r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=_(n,d,r);return n}function g(n,t,r,e){
--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function d(n){return n!==n}function y(n,t){var r=null==n?0:n.length;return r?m(n,t)/r:F}function b(n){return function(t){return null==t?T:t[n]}}function x(n){return function(t){return null==n?T:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function w(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function m(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==T&&(r=r===T?i:r+i)}return r;
}function A(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function k(n,t){return c(t,function(t){return[t,n[t]]})}function E(n){return function(t){return n(t)}}function S(n,t){return c(t,function(t){return n[t]})}function O(n,t){return n.has(t)}function I(n,t){for(var r=-1,e=n.length;++r<e&&-1<v(t,n[r],0););return r}function R(n,t){for(var r=n.length;r--&&-1<v(t,n[r],0););return r}function z(n){return"\\"+Ln[n]}function W(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n];
}),r}function U(n,t){return function(r){return n(t(r))}}function B(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function C(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function D(n){if(Rn.test(n)){for(var t=On.lastIndex=0;On.test(n);)++t;n=t}else n=Qn(n);return n}function M(n){return Rn.test(n)?n.match(On)||[]:n.split("");
}var T,$=1/0,F=NaN,N=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],P=/\b__p\+='';/g,Z=/\b(__p\+=)''\+/g,q=/(__e\(.*?\)|\b__t\))\+'';/g,V=/&(?:amp|lt|gt|quot|#39);/g,K=/[&<>"']/g,G=RegExp(V.source),H=RegExp(K.source),J=/<%-([\s\S]+?)%>/g,Y=/<%([\s\S]+?)%>/g,Q=/<%=([\s\S]+?)%>/g,X=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,nn=/^\w*$/,tn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,rn=/[\\^$.*+?()[\]{}|]/g,en=RegExp(rn.source),un=/^\s+|\s+$/g,on=/^\s+/,fn=/\s+$/,cn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,an=/\{\n\/\* \[wrapped with (.+)\] \*/,ln=/,? & /,sn=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,hn=/\\(\\)?/g,pn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,_n=/\w*$/,vn=/^[-+]0x[0-9a-f]+$/i,gn=/^0b[01]+$/i,dn=/^\[object .+?Constructor\]$/,yn=/^0o[0-7]+$/i,bn=/^(?:0|[1-9]\d*)$/,xn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,jn=/($^)/,wn=/['\n\r\u2028\u2029\\]/g,mn="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",An="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+mn,kn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",En=RegExp("['\u2019]","g"),Sn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),On=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+kn+mn,"g"),In=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+",An].join("|"),"g"),Rn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),zn=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Wn="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Un={};
Un["[object Float32Array]"]=Un["[object Float64Array]"]=Un["[object Int8Array]"]=Un["[object Int16Array]"]=Un["[object Int32Array]"]=Un["[object Uint8Array]"]=Un["[object Uint8ClampedArray]"]=Un["[object Uint16Array]"]=Un["[object Uint32Array]"]=true,Un["[object Arguments]"]=Un["[object Array]"]=Un["[object ArrayBuffer]"]=Un["[object Boolean]"]=Un["[object DataView]"]=Un["[object Date]"]=Un["[object Error]"]=Un["[object Function]"]=Un["[object Map]"]=Un["[object Number]"]=Un["[object Object]"]=Un["[object RegExp]"]=Un["[object Set]"]=Un["[object String]"]=Un["[object WeakMap]"]=false;
var Bn={};Bn["[object Arguments]"]=Bn["[object Array]"]=Bn["[object ArrayBuffer]"]=Bn["[object DataView]"]=Bn["[object Boolean]"]=Bn["[object Date]"]=Bn["[object Float32Array]"]=Bn["[object Float64Array]"]=Bn["[object Int8Array]"]=Bn["[object Int16Array]"]=Bn["[object Int32Array]"]=Bn["[object Map]"]=Bn["[object Number]"]=Bn["[object Object]"]=Bn["[object RegExp]"]=Bn["[object Set]"]=Bn["[object String]"]=Bn["[object Symbol]"]=Bn["[object Uint8Array]"]=Bn["[object Uint8ClampedArray]"]=Bn["[object Uint16Array]"]=Bn["[object Uint32Array]"]=true,
Bn["[object Error]"]=Bn["[object Function]"]=Bn["[object WeakMap]"]=false;var Ln={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Cn=parseFloat,Dn=parseInt,Mn=typeof global=="object"&&global&&global.Object===Object&&global,Tn=typeof self=="object"&&self&&self.Object===Object&&self,$n=Mn||Tn||Function("return this")(),Fn=true&&exports&&!exports.nodeType&&exports,Nn=Fn&&typeof module=="object"&&module&&!module.nodeType&&module,Pn=Nn&&Nn.exports===Fn,Zn=Pn&&Mn.process,qn=function(){
try{var n=Nn&&Nn.require&&Nn.require("util").types;return n?n:Zn&&Zn.binding&&Zn.binding("util")}catch(n){}}(),Vn=qn&&qn.isArrayBuffer,Kn=qn&&qn.isDate,Gn=qn&&qn.isMap,Hn=qn&&qn.isRegExp,Jn=qn&&qn.isSet,Yn=qn&&qn.isTypedArray,Qn=b("length"),Xn=x({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e",
"\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a",
"\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I",
"\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r",
"\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ",
"\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"}),nt=x({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),tt=x({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),rt=function x(mn){function An(n){if(yu(n)&&!ff(n)&&!(n instanceof Ln)){if(n instanceof On)return n;if(oi.call(n,"__wrapped__"))return Fe(n)}return new On(n)}function kn(){}function On(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=T}function Ln(n){
this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Mn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Fn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Fn;++t<r;)this.add(n[t]);
}function Zn(n){this.size=(this.__data__=new Tn(n)).size}function qn(n,t){var r,e=ff(n),u=!e&&of(n),i=!e&&!u&&af(n),o=!e&&!u&&!i&&_f(n),u=(e=e||u||i||o)?A(n.length,ni):[],f=u.length;for(r in n)!t&&!oi.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Se(r,f))||u.push(r);return u}function Qn(n){var t=n.length;return t?n[ir(0,t-1)]:T}function et(n,t){return De(Lr(n),pt(t,0,n.length))}function ut(n){return De(Lr(n))}function it(n,t,r){(r===T||lu(n[t],r))&&(r!==T||t in n)||st(n,t,r);
}function ot(n,t,r){var e=n[t];oi.call(n,t)&&lu(e,r)&&(r!==T||t in n)||st(n,t,r)}function ft(n,t){for(var r=n.length;r--;)if(lu(n[r][0],t))return r;return-1}function ct(n,t,r,e){return uo(n,function(n,u,i){t(e,n,r(n),i)}),e}function at(n,t){return n&&Cr(t,Wu(t),n)}function lt(n,t){return n&&Cr(t,Uu(t),n)}function st(n,t,r){"__proto__"==t&&Ai?Ai(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function ht(n,t){for(var r=-1,e=t.length,u=Ku(e),i=null==n;++r<e;)u[r]=i?T:Ru(n,t[r]);return u;
}function pt(n,t,r){return n===n&&(r!==T&&(n=n<=r?n:r),t!==T&&(n=n>=t?n:t)),n}function _t(n,t,e,u,i,o){var f,c=1&t,a=2&t,l=4&t;if(e&&(f=i?e(n,u,i,o):e(n)),f!==T)return f;if(!du(n))return n;if(u=ff(n)){if(f=me(n),!c)return Lr(n,f)}else{var s=vo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(af(n))return Ir(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Ae(n),!c)return a?Mr(n,lt(f,n)):Dr(n,at(f,n))}else{if(!Bn[s])return i?n:{};f=ke(n,s,c)}}if(o||(o=new Zn),
i=o.get(n))return i;if(o.set(n,f),pf(n))return n.forEach(function(r){f.add(_t(r,t,e,r,n,o))}),f;if(sf(n))return n.forEach(function(r,u){f.set(u,_t(r,t,e,u,n,o))}),f;var a=l?a?ve:_e:a?Uu:Wu,p=u?T:a(n);return r(p||n,function(r,u){p&&(u=r,r=n[u]),ot(f,u,_t(r,t,e,u,n,o))}),f}function vt(n){var t=Wu(n);return function(r){return gt(r,n,t)}}function gt(n,t,r){var e=r.length;if(null==n)return!e;for(n=Qu(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===T&&!(u in n)||!i(o))return false}return true}function dt(n,t,r){if(typeof n!="function")throw new ti("Expected a function");
return bo(function(){n.apply(T,r)},t)}function yt(n,t,r,e){var u=-1,i=o,a=true,l=n.length,s=[],h=t.length;if(!l)return s;r&&(t=c(t,E(r))),e?(i=f,a=false):200<=t.length&&(i=O,a=false,t=new Nn(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function bt(n,t){var r=true;return uo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function xt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===T?o===o&&!wu(o):r(o,f)))var f=o,c=i;
}return c}function jt(n,t){var r=[];return uo(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function wt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ee),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?wt(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function mt(n,t){return n&&oo(n,t,Wu)}function At(n,t){return n&&fo(n,t,Wu)}function kt(n,t){return i(t,function(t){return _u(n[t])})}function Et(n,t){t=Sr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[Me(t[r++])];return r&&r==e?n:T}function St(n,t,r){return t=t(n),
ff(n)?t:a(t,r(n))}function Ot(n){if(null==n)return n===T?"[object Undefined]":"[object Null]";if(mi&&mi in Qu(n)){var t=oi.call(n,mi),r=n[mi];try{n[mi]=T;var e=true}catch(n){}var u=ai.call(n);e&&(t?n[mi]=r:delete n[mi]),n=u}else n=ai.call(n);return n}function It(n,t){return n>t}function Rt(n,t){return null!=n&&oi.call(n,t)}function zt(n,t){return null!=n&&t in Qu(n)}function Wt(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=Ku(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,E(t))),s=Ci(p.length,s),
l[a]=!r&&(t||120<=u&&120<=p.length)?new Nn(a&&p):T}var p=n[0],_=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;if(v?!O(v,d):!e(h,d,r)){for(a=i;--a;){var y=l[a];if(y?!O(y,d):!e(n[a],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ut(n,t,r,e){return mt(n,function(n,u,i){t(e,r(n),u,i)}),e}function Bt(t,r,e){return r=Sr(r,t),t=2>r.length?t:Et(t,hr(r,0,-1)),r=null==t?t:t[Me(Ve(r))],null==r?T:n(r,t,e)}function Lt(n){return yu(n)&&"[object Arguments]"==Ot(n)}function Ct(n){
return yu(n)&&"[object ArrayBuffer]"==Ot(n)}function Dt(n){return yu(n)&&"[object Date]"==Ot(n)}function Mt(n,t,r,e,u){if(n===t)return true;if(null==n||null==t||!yu(n)&&!yu(t))return n!==n&&t!==t;n:{var i=ff(n),o=ff(t),f=i?"[object Array]":vo(n),c=o?"[object Array]":vo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&af(n)){if(!af(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Zn),t=i||_f(n)?se(n,t,r,e,Mt,u):he(n,t,f,r,e,Mt,u);else{
if(!(1&r)&&(i=a&&oi.call(n,"__wrapped__"),f=o&&oi.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Zn),t=Mt(n,t,r,e,u);break n}if(c)t:if(u||(u=new Zn),i=1&r,f=_e(n),o=f.length,c=_e(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:oi.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===T?h!==p&&!Mt(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l);
}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Tt(n){return yu(n)&&"[object Map]"==vo(n)}function $t(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=Qu(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===T&&!(c in n))return false;
}else{if(f=new Zn,e)var s=e(a,l,c,n,t,f);if(s===T?!Mt(l,a,3,e,f):!s)return false}}return true}function Ft(n){return!(!du(n)||ci&&ci in n)&&(_u(n)?hi:dn).test(Te(n))}function Nt(n){return yu(n)&&"[object RegExp]"==Ot(n)}function Pt(n){return yu(n)&&"[object Set]"==vo(n)}function Zt(n){return yu(n)&&gu(n.length)&&!!Un[Ot(n)]}function qt(n){return typeof n=="function"?n:null==n?$u:typeof n=="object"?ff(n)?Jt(n[0],n[1]):Ht(n):Zu(n)}function Vt(n){if(!ze(n))return Bi(n);var t,r=[];for(t in Qu(n))oi.call(n,t)&&"constructor"!=t&&r.push(t);
return r}function Kt(n,t){return n<t}function Gt(n,t){var r=-1,e=su(n)?Ku(n.length):[];return uo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Ht(n){var t=xe(n);return 1==t.length&&t[0][2]?We(t[0][0],t[0][1]):function(r){return r===n||$t(r,n,t)}}function Jt(n,t){return Ie(n)&&t===t&&!du(t)?We(Me(n),t):function(r){var e=Ru(r,n);return e===T&&e===t?zu(r,n):Mt(t,e,3)}}function Yt(n,t,r,e,u){n!==t&&oo(t,function(i,o){if(du(i)){u||(u=new Zn);var f=u,c=Be(n,o),a=Be(t,o),l=f.get(a);if(!l){var l=e?e(c,a,o+"",n,t,f):T,s=l===T;
if(s){var h=ff(a),p=!h&&af(a),_=!h&&!p&&_f(a),l=a;h||p||_?ff(c)?l=c:hu(c)?l=Lr(c):p?(s=false,l=Ir(a,true)):_?(s=false,l=zr(a,true)):l=[]:xu(a)||of(a)?(l=c,of(c)?l=Ou(c):du(c)&&!_u(c)||(l=Ae(a))):s=false}s&&(f.set(a,l),Yt(l,a,r,e,f),f.delete(a))}it(n,o,l)}else f=e?e(Be(n,o),i,o+"",n,t,u):T,f===T&&(f=i),it(n,o,f)},Uu)}function Qt(n,t){var r=n.length;if(r)return t+=0>t?r:0,Se(t,r)?n[t]:T}function Xt(n,t,r){var e=-1;return t=c(t.length?t:[$u],E(ye())),n=Gt(n,function(n,r,u){return{a:c(t,function(t){return t(n)}),
b:++e,c:n}}),w(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Wr(u[e],i[e]);if(c){if(e>=f){e=c;break n}e=c*("desc"==r[e]?-1:1);break n}}e=n.b-t.b}return e})}function nr(n,t){return tr(n,t,function(t,r){return zu(n,r)})}function tr(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=Et(n,o);r(f,o)&&lr(i,Sr(o,n),f)}return i}function rr(n){return function(t){return Et(t,n)}}function er(n,t,r,e){var u=e?g:v,i=-1,o=t.length,f=n;for(n===t&&(t=Lr(t)),r&&(f=c(n,E(r)));++i<o;)for(var a=0,l=t[i],l=r?r(l):l;-1<(a=u(f,l,a,e));)f!==n&&xi.call(f,a,1),
xi.call(n,a,1);return n}function ur(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];if(r==e||u!==i){var i=u;Se(u)?xi.call(n,u,1):xr(n,u)}}return n}function ir(n,t){return n+Ii(Ti()*(t-n+1))}function or(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=Ii(t/2))&&(n+=n);while(t);return r}function fr(n,t){return xo(Ue(n,t,$u),n+"")}function cr(n){return Qn(Lu(n))}function ar(n,t){var r=Lu(n);return De(r,pt(t,0,r.length))}function lr(n,t,r,e){if(!du(n))return n;t=Sr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){
var c=Me(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):T;a===T&&(a=du(l)?l:Se(t[u+1])?[]:{})}ot(f,c,a),f=f[c]}return n}function sr(n){return De(Lu(n))}function hr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Ku(u);++e<u;)r[e]=n[e+t];return r}function pr(n,t){var r;return uo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function _r(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!wu(o)&&(r?o<=t:o<t)?e=i+1:u=i;
}return u}return vr(n,t,$u,r)}function vr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=wu(t),a=t===T;u<i;){var l=Ii((u+i)/2),s=r(n[l]),h=s!==T,p=null===s,_=s===s,v=wu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Ci(i,4294967294)}function gr(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!lu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function dr(n){return typeof n=="number"?n:wu(n)?F:+n}function yr(n){
if(typeof n=="string")return n;if(ff(n))return c(n,yr)+"";if(wu(n))return ro?ro.call(n):"";var t=n+"";return"0"==t&&1/n==-$?"-0":t}function br(n,t,r){var e=-1,u=o,i=n.length,c=true,a=[],l=a;if(r)c=false,u=f;else if(200<=i){if(u=t?null:so(n))return L(u);c=false,u=O,l=new Nn}else l=t?[]:a;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(c&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),a.push(s)}else u(l,h,r)||(l!==a&&l.push(h),a.push(s))}return a}function xr(n,t){return t=Sr(t,n),
n=2>t.length?n:Et(n,hr(t,0,-1)),null==n||delete n[Me(Ve(t))]}function jr(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?hr(n,e?0:i,e?i+1:u):hr(n,e?i+1:0,e?u:i)}function wr(n,t){var r=n;return r instanceof Ln&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function mr(n,t,r){var e=n.length;if(2>e)return e?br(n[0]):[];for(var u=-1,i=Ku(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=yt(i[u]||o,n[f],t,r));return br(wt(i,1),t,r)}function Ar(n,t,r){
for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:T);return o}function kr(n){return hu(n)?n:[]}function Er(n){return typeof n=="function"?n:$u}function Sr(n,t){return ff(n)?n:Ie(n,t)?[n]:jo(Iu(n))}function Or(n,t,r){var e=n.length;return r=r===T?e:r,!t&&r>=e?n:hr(n,t,r)}function Ir(n,t){if(t)return n.slice();var r=n.length,r=gi?gi(r):new n.constructor(r);return n.copy(r),r}function Rr(n){var t=new n.constructor(n.byteLength);return new vi(t).set(new vi(n)),t}function zr(n,t){return new n.constructor(t?Rr(n.buffer):n.buffer,n.byteOffset,n.length);
}function Wr(n,t){if(n!==t){var r=n!==T,e=null===n,u=n===n,i=wu(n),o=t!==T,f=null===t,c=t===t,a=wu(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Ur(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Li(i-o,0),l=Ku(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Br(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Li(i-f,0),s=Ku(l+a);
for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Lr(n,t){var r=-1,e=n.length;for(t||(t=Ku(e));++r<e;)t[r]=n[r];return t}function Cr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):T;c===T&&(c=n[f]),u?st(r,f,c):ot(r,f,c)}return r}function Dr(n,t){return Cr(n,po(n),t)}function Mr(n,t){return Cr(n,_o(n),t)}function Tr(n,r){return function(e,u){var i=ff(e)?t:ct,o=r?r():{};return i(e,n,ye(u,2),o);
}}function $r(n){return fr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:T,o=2<u?r[2]:T,i=3<n.length&&typeof i=="function"?(u--,i):T;for(o&&Oe(r[0],r[1],o)&&(i=3>u?T:i,u=1),t=Qu(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Fr(n,t){return function(r,e){if(null==r)return r;if(!su(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=Qu(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function Nr(n){return function(t,r,e){var u=-1,i=Qu(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
}return t}}function Pr(n,t,r){function e(){return(this&&this!==$n&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Vr(n);return e}function Zr(n){return function(t){t=Iu(t);var r=Rn.test(t)?M(t):T,e=r?r[0]:t.charAt(0);return t=r?Or(r,1).join(""):t.slice(1),e[n]()+t}}function qr(n){return function(t){return l(Mu(Du(t).replace(En,"")),n,"")}}function Vr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=eo(n.prototype),t=n.apply(r,t);return du(t)?t:r}}function Kr(t,r,e){function u(){for(var o=arguments.length,f=Ku(o),c=o,a=de(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:B(f,a),o-=c.length,o<e?ue(t,r,Jr,u.placeholder,T,f,c,T,T,e-o):n(this&&this!==$n&&this instanceof u?i:t,this,f);
}var i=Vr(t);return u}function Gr(n){return function(t,r,e){var u=Qu(t);if(!su(t)){var i=ye(r,3);t=Wu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:T}}function Hr(n){return pe(function(t){var r=t.length,e=r,u=On.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ti("Expected a function");if(u&&!o&&"wrapper"==ge(i))var o=new On([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=ge(i),f="wrapper"==u?ho(i):T,o=f&&Re(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[ge(f[0])].apply(o,f[3]):1==i.length&&Re(i)?o[u]():o.thru(i);
return function(){var n=arguments,e=n[0];if(o&&1==n.length&&ff(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Jr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Ku(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=de(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Ur(y,e,u,_)),i&&(y=Br(y,i,o,_)),d-=x,_&&d<a)return j=B(y,j),ue(n,t,Jr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Ci(f.length,x),m=Lr(y);w--;){
var A=f[w];y[w]=Se(A,x)?m[A]:T}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==$n&&this instanceof l&&(b=g||Vr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?T:Vr(n);return l}function Yr(n,t){return function(r,e){return Ut(r,n,t(e),{})}}function Qr(n,t){return function(r,e){var u;if(r===T&&e===T)return t;if(r!==T&&(u=r),e!==T){if(u===T)return e;typeof r=="string"||typeof e=="string"?(r=yr(r),e=yr(e)):(r=dr(r),e=dr(e)),u=n(r,e)}return u}}function Xr(t){return pe(function(r){
return r=c(r,E(ye())),fr(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ne(n,t){t=t===T?" ":yr(t);var r=t.length;return 2>r?r?or(t,n):t:(r=or(t,Oi(n/D(t))),Rn.test(t)?Or(M(r),0,n).join(""):r.slice(0,n))}function te(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=Ku(l+c),h=this&&this!==$n&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];return n(h,o?e:this,s)}var o=1&r,f=Vr(t);return i}function re(n){return function(t,r,e){
e&&typeof e!="number"&&Oe(t,r,e)&&(r=e=T),t=Au(t),r===T?(r=t,t=0):r=Au(r),e=e===T?t<r?1:-1:Au(e);var u=-1;r=Li(Oi((r-t)/(e||1)),0);for(var i=Ku(r);r--;)i[n?r:++u]=t,t+=e;return i}}function ee(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Su(t),r=Su(r)),n(t,r)}}function ue(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:T;o=l?T:o;var h=l?i:T;return i=l?T:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(T,u),Re(n)&&yo(r,u),r.placeholder=e,Le(r,n,t)}function ie(n){
var t=Yu[n];return function(n,r){if(n=Su(n),r=null==r?0:Ci(ku(r),292)){var e=(Iu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(Iu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function oe(n){return function(t){var r=vo(t);return"[object Map]"==r?W(t):"[object Set]"==r?C(t):k(t,n(t))}}function fe(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ti("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=T),o=o===T?o:Li(ku(o),0),f=f===T?f:ku(f),a-=u?u.length:0,64&t){
var l=e,s=u;e=u=T}var h=c?T:ho(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Ur(e,r,h[4]):r,i[4]=e?B(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Br(e,r,h[6]):r,i[6]=e?B(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Ci(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===T?c?0:n.length:Li(i[9]-a,0),!f&&24&t&&(t&=-25),c=t&&1!=t?8==t||16==t?Kr(n,t,f):32!=t&&33!=t||u.length?Jr.apply(T,i):te(n,t,r,e):Pr(n,t,r),Le((h?co:yo)(c,i),n,t)}function ce(n,t,r,e){return n===T||lu(n,ei[r])&&!oi.call(e,r)?t:n}function ae(n,t,r,e,u,i){return du(n)&&du(t)&&(i.set(t,n),Yt(n,t,T,ae,i),i.delete(t)),n}function le(n){return xu(n)?T:n}function se(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;
var c=-1,a=true,l=2&r?new Nn:T;for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],p=t[c];if(e)var _=o?e(p,s,c,t,n,i):e(s,p,c,n,t,i);if(_!==T){if(_)continue;a=false;break}if(l){if(!h(t,function(n,t){if(!O(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==p&&!u(s,p,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function he(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":
if(n.byteLength!=t.byteLength||!i(new vi(n),new vi(t)))break;return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return lu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=W;case"[object Set]":if(f||(f=L),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=se(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(to)return to.call(n)==to.call(t)}
return false}function pe(n){return xo(Ue(n,T,Ze),n+"")}function _e(n){return St(n,Wu,po)}function ve(n){return St(n,Uu,_o)}function ge(n){for(var t=n.name+"",r=Gi[t],e=oi.call(Gi,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function de(n){return(oi.call(An,"placeholder")?An:n).placeholder}function ye(){var n=An.iteratee||Fu,n=n===Fu?qt:n;return arguments.length?n(arguments[0],arguments[1]):n}function be(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
}function xe(n){for(var t=Wu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!du(u)]}return t}function je(n,t){var r=null==n?T:n[t];return Ft(r)?r:T}function we(n,t,r){t=Sr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=Me(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&gu(u)&&Se(o,u)&&(ff(n)||of(n)))}function me(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&oi.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ae(n){
return typeof n.constructor!="function"||ze(n)?{}:eo(di(n))}function ke(n,t,r){var e=n.constructor;switch(t){case"[object ArrayBuffer]":return Rr(n);case"[object Boolean]":case"[object Date]":return new e(+n);case"[object DataView]":return t=r?Rr(n.buffer):n.buffer,new n.constructor(t,n.byteOffset,n.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
case"[object Uint16Array]":case"[object Uint32Array]":return zr(n,r);case"[object Map]":return new e;case"[object Number]":case"[object String]":return new e(n);case"[object RegExp]":return t=new n.constructor(n.source,_n.exec(n)),t.lastIndex=n.lastIndex,t;case"[object Set]":return new e;case"[object Symbol]":return to?Qu(to.call(n)):{}}}function Ee(n){return ff(n)||of(n)||!!(ji&&n&&n[ji])}function Se(n,t){var r=typeof n;return t=null==t?9007199254740991:t,!!t&&("number"==r||"symbol"!=r&&bn.test(n))&&-1<n&&0==n%1&&n<t;
}function Oe(n,t,r){if(!du(r))return false;var e=typeof t;return!!("number"==e?su(r)&&Se(t,r.length):"string"==e&&t in r)&&lu(r[t],n)}function Ie(n,t){if(ff(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!wu(n))||(nn.test(n)||!X.test(n)||null!=t&&n in Qu(t))}function Re(n){var t=ge(n),r=An[t];return typeof r=="function"&&t in Ln.prototype&&(n===r||(t=ho(r),!!t&&n===t[0]))}function ze(n){var t=n&&n.constructor;return n===(typeof t=="function"&&t.prototype||ei)}function We(n,t){
return function(r){return null!=r&&(r[n]===t&&(t!==T||n in Qu(r)))}}function Ue(t,r,e){return r=Li(r===T?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Li(u.length-r,0),f=Ku(o);++i<o;)f[i]=u[r+i];for(i=-1,o=Ku(r+1);++i<r;)o[i]=u[i];return o[r]=e(f),n(t,this,o)}}function Be(n,t){if("__proto__"!=t)return n[t]}function Le(n,t,r){var e=t+"";t=xo;var u,i=$e;return u=(u=e.match(an))?u[1].split(ln):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),e=e.replace(cn,"{\n/* [wrapped with "+r+"] */\n")),
t(n,e)}function Ce(n){var t=0,r=0;return function(){var e=Di(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(T,arguments)}}function De(n,t){var r=-1,e=n.length,u=e-1;for(t=t===T?e:t;++r<t;){var e=ir(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function Me(n){if(typeof n=="string"||wu(n))return n;var t=n+"";return"0"==t&&1/n==-$?"-0":t}function Te(n){if(null!=n){try{return ii.call(n)}catch(n){}return n+""}return""}function $e(n,t){return r(N,function(r){var e="_."+r[0];
t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function Fe(n){if(n instanceof Ln)return n.clone();var t=new On(n.__wrapped__,n.__chain__);return t.__actions__=Lr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ne(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:ku(r),0>r&&(r=Li(e+r,0)),_(n,ye(t,3),r)):-1}function Pe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==T&&(u=ku(r),u=0>r?Li(e+u,0):Ci(u,e-1)),_(n,ye(t,3),u,true)}function Ze(n){return(null==n?0:n.length)?wt(n,1):[];
}function qe(n){return n&&n.length?n[0]:T}function Ve(n){var t=null==n?0:n.length;return t?n[t-1]:T}function Ke(n,t){return n&&n.length&&t&&t.length?er(n,t):n}function Ge(n){return null==n?n:$i.call(n)}function He(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){if(hu(n))return t=Li(n.length,t),true}),A(t,function(t){return c(n,b(t))})}function Je(t,r){if(!t||!t.length)return[];var e=He(t);return null==r?e:c(e,function(t){return n(r,T,t)})}function Ye(n){return n=An(n),n.__chain__=true,n;
}function Qe(n,t){return t(n)}function Xe(){return this}function nu(n,t){return(ff(n)?r:uo)(n,ye(t,3))}function tu(n,t){return(ff(n)?e:io)(n,ye(t,3))}function ru(n,t){return(ff(n)?c:Gt)(n,ye(t,3))}function eu(n,t,r){return t=r?T:t,t=n&&null==t?n.length:t,fe(n,128,T,T,T,T,t)}function uu(n,t){var r;if(typeof t!="function")throw new ti("Expected a function");return n=ku(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=T),r}}function iu(n,t,r){return t=r?T:t,n=fe(n,8,T,T,T,T,T,t),n.placeholder=iu.placeholder,
n}function ou(n,t,r){return t=r?T:t,n=fe(n,16,T,T,T,T,T,t),n.placeholder=ou.placeholder,n}function fu(n,t,r){function e(t){var r=c,e=a;return c=a=T,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===T||r>=t||0>r||g&&n>=l}function i(){var n=Go();if(u(n))return o(n);var r,e=bo;r=n-_,n=t-(n-p),r=g?Ci(n,l-r):n,h=e(i,r)}function o(n){return h=T,d&&c?e(n):(c=a=T,s)}function f(){var n=Go(),r=u(n);if(c=arguments,a=this,p=n,r){if(h===T)return _=n=p,h=bo(i,t),v?e(n):s;if(g)return h=bo(i,t),e(p)}return h===T&&(h=bo(i,t)),
s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ti("Expected a function");return t=Su(t)||0,du(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Li(Su(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==T&&lo(h),_=0,c=p=a=h=T},f.flush=function(){return h===T?s:o(Go())},f}function cu(n,t){if(typeof n!="function"||null!=t&&typeof t!="function")throw new ti("Expected a function");var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
r.cache=i.set(u,e)||i,e)};return r.cache=new(cu.Cache||Fn),r}function au(n){if(typeof n!="function")throw new ti("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function lu(n,t){return n===t||n!==n&&t!==t}function su(n){return null!=n&&gu(n.length)&&!_u(n)}function hu(n){return yu(n)&&su(n)}function pu(n){if(!yu(n))return false;
var t=Ot(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!xu(n)}function _u(n){return!!du(n)&&(n=Ot(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function vu(n){return typeof n=="number"&&n==ku(n)}function gu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function du(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function yu(n){return null!=n&&typeof n=="object";
}function bu(n){return typeof n=="number"||yu(n)&&"[object Number]"==Ot(n)}function xu(n){return!(!yu(n)||"[object Object]"!=Ot(n))&&(n=di(n),null===n||(n=oi.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&ii.call(n)==li))}function ju(n){return typeof n=="string"||!ff(n)&&yu(n)&&"[object String]"==Ot(n)}function wu(n){return typeof n=="symbol"||yu(n)&&"[object Symbol]"==Ot(n)}function mu(n){if(!n)return[];if(su(n))return ju(n)?M(n):Lr(n);if(wi&&n[wi]){n=n[wi]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);
return r}return t=vo(n),("[object Map]"==t?W:"[object Set]"==t?L:Lu)(n)}function Au(n){return n?(n=Su(n),n===$||n===-$?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function ku(n){n=Au(n);var t=n%1;return n===n?t?n-t:n:0}function Eu(n){return n?pt(ku(n),0,4294967295):0}function Su(n){if(typeof n=="number")return n;if(wu(n))return F;if(du(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=du(n)?n+"":n),typeof n!="string")return 0===n?n:+n;n=n.replace(un,"");var t=gn.test(n);return t||yn.test(n)?Dn(n.slice(2),t?2:8):vn.test(n)?F:+n;
}function Ou(n){return Cr(n,Uu(n))}function Iu(n){return null==n?"":yr(n)}function Ru(n,t,r){return n=null==n?T:Et(n,t),n===T?r:n}function zu(n,t){return null!=n&&we(n,t,zt)}function Wu(n){return su(n)?qn(n):Vt(n)}function Uu(n){if(su(n))n=qn(n,true);else if(du(n)){var t,r=ze(n),e=[];for(t in n)("constructor"!=t||!r&&oi.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in Qu(n))t.push(r);n=t}return n}function Bu(n,t){if(null==n)return{};var r=c(ve(n),function(n){return[n]});return t=ye(t),tr(n,r,function(n,r){
return t(n,r[0])})}function Lu(n){return null==n?[]:S(n,Wu(n))}function Cu(n){return $f(Iu(n).toLowerCase())}function Du(n){return(n=Iu(n))&&n.replace(xn,Xn).replace(Sn,"")}function Mu(n,t,r){return n=Iu(n),t=r?T:t,t===T?zn.test(n)?n.match(In)||[]:n.match(sn)||[]:n.match(t)||[]}function Tu(n){return function(){return n}}function $u(n){return n}function Fu(n){return qt(typeof n=="function"?n:_t(n,1))}function Nu(n,t,e){var u=Wu(t),i=kt(t,u);null!=e||du(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=kt(t,Wu(t)));
var o=!(du(e)&&"chain"in e&&!e.chain),f=_u(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Lr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function Pu(){}function Zu(n){return Ie(n)?b(Me(n)):rr(n)}function qu(){return[]}function Vu(){return false}mn=null==mn?$n:rt.defaults($n.Object(),mn,rt.pick($n,Wn));var Ku=mn.Array,Gu=mn.Date,Hu=mn.Error,Ju=mn.Function,Yu=mn.Math,Qu=mn.Object,Xu=mn.RegExp,ni=mn.String,ti=mn.TypeError,ri=Ku.prototype,ei=Qu.prototype,ui=mn["__core-js_shared__"],ii=Ju.prototype.toString,oi=ei.hasOwnProperty,fi=0,ci=function(){
var n=/[^.]+$/.exec(ui&&ui.keys&&ui.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),ai=ei.toString,li=ii.call(Qu),si=$n._,hi=Xu("^"+ii.call(oi).replace(rn,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),pi=Pn?mn.Buffer:T,_i=mn.Symbol,vi=mn.Uint8Array,gi=pi?pi.allocUnsafe:T,di=U(Qu.getPrototypeOf,Qu),yi=Qu.create,bi=ei.propertyIsEnumerable,xi=ri.splice,ji=_i?_i.isConcatSpreadable:T,wi=_i?_i.iterator:T,mi=_i?_i.toStringTag:T,Ai=function(){try{var n=je(Qu,"defineProperty");
return n({},"",{}),n}catch(n){}}(),ki=mn.clearTimeout!==$n.clearTimeout&&mn.clearTimeout,Ei=Gu&&Gu.now!==$n.Date.now&&Gu.now,Si=mn.setTimeout!==$n.setTimeout&&mn.setTimeout,Oi=Yu.ceil,Ii=Yu.floor,Ri=Qu.getOwnPropertySymbols,zi=pi?pi.isBuffer:T,Wi=mn.isFinite,Ui=ri.join,Bi=U(Qu.keys,Qu),Li=Yu.max,Ci=Yu.min,Di=Gu.now,Mi=mn.parseInt,Ti=Yu.random,$i=ri.reverse,Fi=je(mn,"DataView"),Ni=je(mn,"Map"),Pi=je(mn,"Promise"),Zi=je(mn,"Set"),qi=je(mn,"WeakMap"),Vi=je(Qu,"create"),Ki=qi&&new qi,Gi={},Hi=Te(Fi),Ji=Te(Ni),Yi=Te(Pi),Qi=Te(Zi),Xi=Te(qi),no=_i?_i.prototype:T,to=no?no.valueOf:T,ro=no?no.toString:T,eo=function(){
function n(){}return function(t){return du(t)?yi?yi(t):(n.prototype=t,t=new n,n.prototype=T,t):{}}}();An.templateSettings={escape:J,evaluate:Y,interpolate:Q,variable:"",imports:{_:An}},An.prototype=kn.prototype,An.prototype.constructor=An,On.prototype=eo(kn.prototype),On.prototype.constructor=On,Ln.prototype=eo(kn.prototype),Ln.prototype.constructor=Ln,Mn.prototype.clear=function(){this.__data__=Vi?Vi(null):{},this.size=0},Mn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
this.size-=n?1:0,n},Mn.prototype.get=function(n){var t=this.__data__;return Vi?(n=t[n],"__lodash_hash_undefined__"===n?T:n):oi.call(t,n)?t[n]:T},Mn.prototype.has=function(n){var t=this.__data__;return Vi?t[n]!==T:oi.call(t,n)},Mn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Vi&&t===T?"__lodash_hash_undefined__":t,this},Tn.prototype.clear=function(){this.__data__=[],this.size=0},Tn.prototype.delete=function(n){var t=this.__data__;return n=ft(t,n),!(0>n)&&(n==t.length-1?t.pop():xi.call(t,n,1),
--this.size,true)},Tn.prototype.get=function(n){var t=this.__data__;return n=ft(t,n),0>n?T:t[n][1]},Tn.prototype.has=function(n){return-1<ft(this.__data__,n)},Tn.prototype.set=function(n,t){var r=this.__data__,e=ft(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Fn.prototype.clear=function(){this.size=0,this.__data__={hash:new Mn,map:new(Ni||Tn),string:new Mn}},Fn.prototype.delete=function(n){return n=be(this,n).delete(n),this.size-=n?1:0,n},Fn.prototype.get=function(n){return be(this,n).get(n);
},Fn.prototype.has=function(n){return be(this,n).has(n)},Fn.prototype.set=function(n,t){var r=be(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},Nn.prototype.add=Nn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},Nn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.clear=function(){this.__data__=new Tn,this.size=0},Zn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Zn.prototype.get=function(n){
return this.__data__.get(n)},Zn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Tn){var e=r.__data__;if(!Ni||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Fn(e)}return r.set(n,t),this.size=r.size,this};var uo=Fr(mt),io=Fr(At,true),oo=Nr(),fo=Nr(true),co=Ki?function(n,t){return Ki.set(n,t),n}:$u,ao=Ai?function(n,t){return Ai(n,"toString",{configurable:true,enumerable:false,value:Tu(t),writable:true})}:$u,lo=ki||function(n){
return $n.clearTimeout(n)},so=Zi&&1/L(new Zi([,-0]))[1]==$?function(n){return new Zi(n)}:Pu,ho=Ki?function(n){return Ki.get(n)}:Pu,po=Ri?function(n){return null==n?[]:(n=Qu(n),i(Ri(n),function(t){return bi.call(n,t)}))}:qu,_o=Ri?function(n){for(var t=[];n;)a(t,po(n)),n=di(n);return t}:qu,vo=Ot;(Fi&&"[object DataView]"!=vo(new Fi(new ArrayBuffer(1)))||Ni&&"[object Map]"!=vo(new Ni)||Pi&&"[object Promise]"!=vo(Pi.resolve())||Zi&&"[object Set]"!=vo(new Zi)||qi&&"[object WeakMap]"!=vo(new qi))&&(vo=function(n){
var t=Ot(n);if(n=(n="[object Object]"==t?n.constructor:T)?Te(n):"")switch(n){case Hi:return"[object DataView]";case Ji:return"[object Map]";case Yi:return"[object Promise]";case Qi:return"[object Set]";case Xi:return"[object WeakMap]"}return t});var go=ui?_u:Vu,yo=Ce(co),bo=Si||function(n,t){return $n.setTimeout(n,t)},xo=Ce(ao),jo=function(n){n=cu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(tn,function(n,r,e,u){
t.push(e?u.replace(hn,"$1"):r||n)}),t}),wo=fr(function(n,t){return hu(n)?yt(n,wt(t,1,hu,true)):[]}),mo=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),ye(r,2)):[]}),Ao=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),T,r):[]}),ko=fr(function(n){var t=c(n,kr);return t.length&&t[0]===n[0]?Wt(t):[]}),Eo=fr(function(n){var t=Ve(n),r=c(n,kr);return t===Ve(r)?t=T:r.pop(),r.length&&r[0]===n[0]?Wt(r,ye(t,2)):[]}),So=fr(function(n){var t=Ve(n),r=c(n,kr);return(t=typeof t=="function"?t:T)&&r.pop(),
r.length&&r[0]===n[0]?Wt(r,T,t):[]}),Oo=fr(Ke),Io=pe(function(n,t){var r=null==n?0:n.length,e=ht(n,t);return ur(n,c(t,function(n){return Se(n,r)?+n:n}).sort(Wr)),e}),Ro=fr(function(n){return br(wt(n,1,hu,true))}),zo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),br(wt(n,1,hu,true),ye(t,2))}),Wo=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return br(wt(n,1,hu,true),T,t)}),Uo=fr(function(n,t){return hu(n)?yt(n,t):[]}),Bo=fr(function(n){return mr(i(n,hu))}),Lo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),
mr(i(n,hu),ye(t,2))}),Co=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return mr(i(n,hu),T,t)}),Do=fr(He),Mo=fr(function(n){var t=n.length,t=1<t?n[t-1]:T,t=typeof t=="function"?(n.pop(),t):T;return Je(n,t)}),To=pe(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return ht(t,n)};return!(1<t||this.__actions__.length)&&e instanceof Ln&&Se(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:Qe,args:[u],thisArg:T}),new On(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(T),
n})):this.thru(u)}),$o=Tr(function(n,t,r){oi.call(n,r)?++n[r]:st(n,r,1)}),Fo=Gr(Ne),No=Gr(Pe),Po=Tr(function(n,t,r){oi.call(n,r)?n[r].push(t):st(n,r,[t])}),Zo=fr(function(t,r,e){var u=-1,i=typeof r=="function",o=su(t)?Ku(t.length):[];return uo(t,function(t){o[++u]=i?n(r,t,e):Bt(t,r,e)}),o}),qo=Tr(function(n,t,r){st(n,r,t)}),Vo=Tr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ko=fr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&Oe(n,t[0],t[1])?t=[]:2<r&&Oe(t[0],t[1],t[2])&&(t=[t[0]]),
Xt(n,wt(t,1),[])}),Go=Ei||function(){return $n.Date.now()},Ho=fr(function(n,t,r){var e=1;if(r.length)var u=B(r,de(Ho)),e=32|e;return fe(n,e,t,r,u)}),Jo=fr(function(n,t,r){var e=3;if(r.length)var u=B(r,de(Jo)),e=32|e;return fe(t,e,n,r,u)}),Yo=fr(function(n,t){return dt(n,1,t)}),Qo=fr(function(n,t,r){return dt(n,Su(t)||0,r)});cu.Cache=Fn;var Xo=fr(function(t,r){r=1==r.length&&ff(r[0])?c(r[0],E(ye())):c(wt(r,1),E(ye()));var e=r.length;return fr(function(u){for(var i=-1,o=Ci(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);
return n(t,this,u)})}),nf=fr(function(n,t){return fe(n,32,T,t,B(t,de(nf)))}),tf=fr(function(n,t){return fe(n,64,T,t,B(t,de(tf)))}),rf=pe(function(n,t){return fe(n,256,T,T,T,t)}),ef=ee(It),uf=ee(function(n,t){return n>=t}),of=Lt(function(){return arguments}())?Lt:function(n){return yu(n)&&oi.call(n,"callee")&&!bi.call(n,"callee")},ff=Ku.isArray,cf=Vn?E(Vn):Ct,af=zi||Vu,lf=Kn?E(Kn):Dt,sf=Gn?E(Gn):Tt,hf=Hn?E(Hn):Nt,pf=Jn?E(Jn):Pt,_f=Yn?E(Yn):Zt,vf=ee(Kt),gf=ee(function(n,t){return n<=t}),df=$r(function(n,t){
if(ze(t)||su(t))Cr(t,Wu(t),n);else for(var r in t)oi.call(t,r)&&ot(n,r,t[r])}),yf=$r(function(n,t){Cr(t,Uu(t),n)}),bf=$r(function(n,t,r,e){Cr(t,Uu(t),n,e)}),xf=$r(function(n,t,r,e){Cr(t,Wu(t),n,e)}),jf=pe(ht),wf=fr(function(n,t){n=Qu(n);var r=-1,e=t.length,u=2<e?t[2]:T;for(u&&Oe(t[0],t[1],u)&&(e=1);++r<e;)for(var u=t[r],i=Uu(u),o=-1,f=i.length;++o<f;){var c=i[o],a=n[c];(a===T||lu(a,ei[c])&&!oi.call(n,c))&&(n[c]=u[c])}return n}),mf=fr(function(t){return t.push(T,ae),n(Of,T,t)}),Af=Yr(function(n,t,r){
null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),n[t]=r},Tu($u)),kf=Yr(function(n,t,r){null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),oi.call(n,t)?n[t].push(r):n[t]=[r]},ye),Ef=fr(Bt),Sf=$r(function(n,t,r){Yt(n,t,r)}),Of=$r(function(n,t,r,e){Yt(n,t,r,e)}),If=pe(function(n,t){var r={};if(null==n)return r;var e=false;t=c(t,function(t){return t=Sr(t,n),e||(e=1<t.length),t}),Cr(n,ve(n),r),e&&(r=_t(r,7,le));for(var u=t.length;u--;)xr(r,t[u]);return r}),Rf=pe(function(n,t){return null==n?{}:nr(n,t);
}),zf=oe(Wu),Wf=oe(Uu),Uf=qr(function(n,t,r){return t=t.toLowerCase(),n+(r?Cu(t):t)}),Bf=qr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Lf=qr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Cf=Zr("toLowerCase"),Df=qr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Mf=qr(function(n,t,r){return n+(r?" ":"")+$f(t)}),Tf=qr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),$f=Zr("toUpperCase"),Ff=fr(function(t,r){try{return n(t,T,r)}catch(n){return pu(n)?n:new Hu(n)}}),Nf=pe(function(n,t){
return r(t,function(t){t=Me(t),st(n,t,Ho(n[t],n))}),n}),Pf=Hr(),Zf=Hr(true),qf=fr(function(n,t){return function(r){return Bt(r,n,t)}}),Vf=fr(function(n,t){return function(r){return Bt(n,r,t)}}),Kf=Xr(c),Gf=Xr(u),Hf=Xr(h),Jf=re(),Yf=re(true),Qf=Qr(function(n,t){return n+t},0),Xf=ie("ceil"),nc=Qr(function(n,t){return n/t},1),tc=ie("floor"),rc=Qr(function(n,t){return n*t},1),ec=ie("round"),uc=Qr(function(n,t){return n-t},0);return An.after=function(n,t){if(typeof t!="function")throw new ti("Expected a function");
return n=ku(n),function(){if(1>--n)return t.apply(this,arguments)}},An.ary=eu,An.assign=df,An.assignIn=yf,An.assignInWith=bf,An.assignWith=xf,An.at=jf,An.before=uu,An.bind=Ho,An.bindAll=Nf,An.bindKey=Jo,An.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return ff(n)?n:[n]},An.chain=Ye,An.chunk=function(n,t,r){if(t=(r?Oe(n,t,r):t===T)?1:Li(ku(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Ku(Oi(r/t));e<r;)i[u++]=hr(n,e,e+=t);return i},An.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){
var i=n[t];i&&(u[e++]=i)}return u},An.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Ku(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return a(ff(r)?Lr(r):[r],wt(t,1))},An.cond=function(t){var r=null==t?0:t.length,e=ye();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new ti("Expected a function");return[e(n[0]),n[1]]}):[],fr(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e)}})},An.conforms=function(n){return vt(_t(n,1))},An.constant=Tu,
An.countBy=$o,An.create=function(n,t){var r=eo(n);return null==t?r:at(r,t)},An.curry=iu,An.curryRight=ou,An.debounce=fu,An.defaults=wf,An.defaultsDeep=mf,An.defer=Yo,An.delay=Qo,An.difference=wo,An.differenceBy=mo,An.differenceWith=Ao,An.drop=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),hr(n,0>t?0:t,e)):[]},An.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),t=e-t,hr(n,0,0>t?0:t)):[]},An.dropRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true,true):[];
},An.dropWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true):[]},An.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&Oe(n,t,r)&&(r=0,e=u),u=n.length,r=ku(r),0>r&&(r=-r>u?0:u+r),e=e===T||e>u?u:ku(e),0>e&&(e+=u),e=r>e?0:Eu(e);r<e;)n[r++]=t;return n},An.filter=function(n,t){return(ff(n)?i:jt)(n,ye(t,3))},An.flatMap=function(n,t){return wt(ru(n,t),1)},An.flatMapDeep=function(n,t){return wt(ru(n,t),$)},An.flatMapDepth=function(n,t,r){return r=r===T?1:ku(r),
wt(ru(n,t),r)},An.flatten=Ze,An.flattenDeep=function(n){return(null==n?0:n.length)?wt(n,$):[]},An.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===T?1:ku(t),wt(n,t)):[]},An.flip=function(n){return fe(n,512)},An.flow=Pf,An.flowRight=Zf,An.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e},An.functions=function(n){return null==n?[]:kt(n,Wu(n))},An.functionsIn=function(n){return null==n?[]:kt(n,Uu(n))},An.groupBy=Po,An.initial=function(n){
return(null==n?0:n.length)?hr(n,0,-1):[]},An.intersection=ko,An.intersectionBy=Eo,An.intersectionWith=So,An.invert=Af,An.invertBy=kf,An.invokeMap=Zo,An.iteratee=Fu,An.keyBy=qo,An.keys=Wu,An.keysIn=Uu,An.map=ru,An.mapKeys=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,t(n,e,u),n)}),r},An.mapValues=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,e,t(n,e,u))}),r},An.matches=function(n){return Ht(_t(n,1))},An.matchesProperty=function(n,t){return Jt(n,_t(t,1))},An.memoize=cu,
An.merge=Sf,An.mergeWith=Of,An.method=qf,An.methodOf=Vf,An.mixin=Nu,An.negate=au,An.nthArg=function(n){return n=ku(n),fr(function(t){return Qt(t,n)})},An.omit=If,An.omitBy=function(n,t){return Bu(n,au(ye(t)))},An.once=function(n){return uu(2,n)},An.orderBy=function(n,t,r,e){return null==n?[]:(ff(t)||(t=null==t?[]:[t]),r=e?T:r,ff(r)||(r=null==r?[]:[r]),Xt(n,t,r))},An.over=Kf,An.overArgs=Xo,An.overEvery=Gf,An.overSome=Hf,An.partial=nf,An.partialRight=tf,An.partition=Vo,An.pick=Rf,An.pickBy=Bu,An.property=Zu,
An.propertyOf=function(n){return function(t){return null==n?T:Et(n,t)}},An.pull=Oo,An.pullAll=Ke,An.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,ye(r,2)):n},An.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,T,r):n},An.pullAt=Io,An.range=Jf,An.rangeRight=Yf,An.rearg=rf,An.reject=function(n,t){return(ff(n)?i:jt)(n,au(ye(t,3)))},An.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=ye(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),
u.push(e))}return ur(n,u),r},An.rest=function(n,t){if(typeof n!="function")throw new ti("Expected a function");return t=t===T?t:ku(t),fr(n,t)},An.reverse=Ge,An.sampleSize=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:ku(t),(ff(n)?et:ar)(n,t)},An.set=function(n,t,r){return null==n?n:lr(n,t,r)},An.setWith=function(n,t,r,e){return e=typeof e=="function"?e:T,null==n?n:lr(n,t,r,e)},An.shuffle=function(n){return(ff(n)?ut:sr)(n)},An.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&Oe(n,t,r)?(t=0,
r=e):(t=null==t?0:ku(t),r=r===T?e:ku(r)),hr(n,t,r)):[]},An.sortBy=Ko,An.sortedUniq=function(n){return n&&n.length?gr(n):[]},An.sortedUniqBy=function(n,t){return n&&n.length?gr(n,ye(t,2)):[]},An.split=function(n,t,r){return r&&typeof r!="number"&&Oe(n,t,r)&&(t=r=T),r=r===T?4294967295:r>>>0,r?(n=Iu(n))&&(typeof t=="string"||null!=t&&!hf(t))&&(t=yr(t),!t&&Rn.test(n))?Or(M(n),0,r):n.split(t,r):[]},An.spread=function(t,r){if(typeof t!="function")throw new ti("Expected a function");return r=null==r?0:Li(ku(r),0),
fr(function(e){var u=e[r];return e=Or(e,0,r),u&&a(e,u),n(t,this,e)})},An.tail=function(n){var t=null==n?0:n.length;return t?hr(n,1,t):[]},An.take=function(n,t,r){return n&&n.length?(t=r||t===T?1:ku(t),hr(n,0,0>t?0:t)):[]},An.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),t=e-t,hr(n,0>t?0:t,e)):[]},An.takeRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),false,true):[]},An.takeWhile=function(n,t){return n&&n.length?jr(n,ye(t,3)):[]},An.tap=function(n,t){return t(n),
n},An.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ti("Expected a function");return du(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),fu(n,t,{leading:e,maxWait:t,trailing:u})},An.thru=Qe,An.toArray=mu,An.toPairs=zf,An.toPairsIn=Wf,An.toPath=function(n){return ff(n)?c(n,Me):wu(n)?[n]:Lr(jo(Iu(n)))},An.toPlainObject=Ou,An.transform=function(n,t,e){var u=ff(n),i=u||af(n)||_f(n);if(t=ye(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:du(n)&&_u(o)?eo(di(n)):{};
}return(i?r:mt)(n,function(n,r,u){return t(e,n,r,u)}),e},An.unary=function(n){return eu(n,1)},An.union=Ro,An.unionBy=zo,An.unionWith=Wo,An.uniq=function(n){return n&&n.length?br(n):[]},An.uniqBy=function(n,t){return n&&n.length?br(n,ye(t,2)):[]},An.uniqWith=function(n,t){return t=typeof t=="function"?t:T,n&&n.length?br(n,T,t):[]},An.unset=function(n,t){return null==n||xr(n,t)},An.unzip=He,An.unzipWith=Je,An.update=function(n,t,r){return null!=n&&(r=Er(r),n=lr(n,t,r(Et(n,t)),void 0)),n},An.updateWith=function(n,t,r,e){
return e=typeof e=="function"?e:T,null!=n&&(r=Er(r),n=lr(n,t,r(Et(n,t)),e)),n},An.values=Lu,An.valuesIn=function(n){return null==n?[]:S(n,Uu(n))},An.without=Uo,An.words=Mu,An.wrap=function(n,t){return nf(Er(t),n)},An.xor=Bo,An.xorBy=Lo,An.xorWith=Co,An.zip=Do,An.zipObject=function(n,t){return Ar(n||[],t||[],ot)},An.zipObjectDeep=function(n,t){return Ar(n||[],t||[],lr)},An.zipWith=Mo,An.entries=zf,An.entriesIn=Wf,An.extend=yf,An.extendWith=bf,Nu(An,An),An.add=Qf,An.attempt=Ff,An.camelCase=Uf,An.capitalize=Cu,
An.ceil=Xf,An.clamp=function(n,t,r){return r===T&&(r=t,t=T),r!==T&&(r=Su(r),r=r===r?r:0),t!==T&&(t=Su(t),t=t===t?t:0),pt(Su(n),t,r)},An.clone=function(n){return _t(n,4)},An.cloneDeep=function(n){return _t(n,5)},An.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,5,t)},An.cloneWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,4,t)},An.conformsTo=function(n,t){return null==t||gt(n,t,Wu(t))},An.deburr=Du,An.defaultTo=function(n,t){return null==n||n!==n?t:n},An.divide=nc,An.endsWith=function(n,t,r){
n=Iu(n),t=yr(t);var e=n.length,e=r=r===T?e:pt(ku(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},An.eq=lu,An.escape=function(n){return(n=Iu(n))&&H.test(n)?n.replace(K,nt):n},An.escapeRegExp=function(n){return(n=Iu(n))&&en.test(n)?n.replace(rn,"\\$&"):n},An.every=function(n,t,r){var e=ff(n)?u:bt;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.find=Fo,An.findIndex=Ne,An.findKey=function(n,t){return p(n,ye(t,3),mt)},An.findLast=No,An.findLastIndex=Pe,An.findLastKey=function(n,t){return p(n,ye(t,3),At);
},An.floor=tc,An.forEach=nu,An.forEachRight=tu,An.forIn=function(n,t){return null==n?n:oo(n,ye(t,3),Uu)},An.forInRight=function(n,t){return null==n?n:fo(n,ye(t,3),Uu)},An.forOwn=function(n,t){return n&&mt(n,ye(t,3))},An.forOwnRight=function(n,t){return n&&At(n,ye(t,3))},An.get=Ru,An.gt=ef,An.gte=uf,An.has=function(n,t){return null!=n&&we(n,t,Rt)},An.hasIn=zu,An.head=qe,An.identity=$u,An.includes=function(n,t,r,e){return n=su(n)?n:Lu(n),r=r&&!e?ku(r):0,e=n.length,0>r&&(r=Li(e+r,0)),ju(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<v(n,t,r);
},An.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:ku(r),0>r&&(r=Li(e+r,0)),v(n,t,r)):-1},An.inRange=function(n,t,r){return t=Au(t),r===T?(r=t,t=0):r=Au(r),n=Su(n),n>=Ci(t,r)&&n<Li(t,r)},An.invoke=Ef,An.isArguments=of,An.isArray=ff,An.isArrayBuffer=cf,An.isArrayLike=su,An.isArrayLikeObject=hu,An.isBoolean=function(n){return true===n||false===n||yu(n)&&"[object Boolean]"==Ot(n)},An.isBuffer=af,An.isDate=lf,An.isElement=function(n){return yu(n)&&1===n.nodeType&&!xu(n)},An.isEmpty=function(n){
if(null==n)return true;if(su(n)&&(ff(n)||typeof n=="string"||typeof n.splice=="function"||af(n)||_f(n)||of(n)))return!n.length;var t=vo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(ze(n))return!Vt(n).length;for(var r in n)if(oi.call(n,r))return false;return true},An.isEqual=function(n,t){return Mt(n,t)},An.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:T)?r(n,t):T;return e===T?Mt(n,t,T,r):!!e},An.isError=pu,An.isFinite=function(n){return typeof n=="number"&&Wi(n)},An.isFunction=_u,
An.isInteger=vu,An.isLength=gu,An.isMap=sf,An.isMatch=function(n,t){return n===t||$t(n,t,xe(t))},An.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:T,$t(n,t,xe(t),r)},An.isNaN=function(n){return bu(n)&&n!=+n},An.isNative=function(n){if(go(n))throw new Hu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");return Ft(n)},An.isNil=function(n){return null==n},An.isNull=function(n){return null===n},An.isNumber=bu,An.isObject=du,An.isObjectLike=yu,An.isPlainObject=xu,An.isRegExp=hf,
An.isSafeInteger=function(n){return vu(n)&&-9007199254740991<=n&&9007199254740991>=n},An.isSet=pf,An.isString=ju,An.isSymbol=wu,An.isTypedArray=_f,An.isUndefined=function(n){return n===T},An.isWeakMap=function(n){return yu(n)&&"[object WeakMap]"==vo(n)},An.isWeakSet=function(n){return yu(n)&&"[object WeakSet]"==Ot(n)},An.join=function(n,t){return null==n?"":Ui.call(n,t)},An.kebabCase=Bf,An.last=Ve,An.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==T&&(u=ku(r),u=0>u?Li(e+u,0):Ci(u,e-1)),
t===t)n:{for(r=u+1;r--;)if(n[r]===t){n=r;break n}n=r}else n=_(n,d,u,true);return n},An.lowerCase=Lf,An.lowerFirst=Cf,An.lt=vf,An.lte=gf,An.max=function(n){return n&&n.length?xt(n,$u,It):T},An.maxBy=function(n,t){return n&&n.length?xt(n,ye(t,2),It):T},An.mean=function(n){return y(n,$u)},An.meanBy=function(n,t){return y(n,ye(t,2))},An.min=function(n){return n&&n.length?xt(n,$u,Kt):T},An.minBy=function(n,t){return n&&n.length?xt(n,ye(t,2),Kt):T},An.stubArray=qu,An.stubFalse=Vu,An.stubObject=function(){
return{}},An.stubString=function(){return""},An.stubTrue=function(){return true},An.multiply=rc,An.nth=function(n,t){return n&&n.length?Qt(n,ku(t)):T},An.noConflict=function(){return $n._===this&&($n._=si),this},An.noop=Pu,An.now=Go,An.pad=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return!t||e>=t?n:(t=(t-e)/2,ne(Ii(t),r)+n+ne(Oi(t),r))},An.padEnd=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return t&&e<t?n+ne(t-e,r):n},An.padStart=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return t&&e<t?ne(t-e,r)+n:n;
},An.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),Mi(Iu(n).replace(on,""),t||0)},An.random=function(n,t,r){if(r&&typeof r!="boolean"&&Oe(n,t,r)&&(t=r=T),r===T&&(typeof t=="boolean"?(r=t,t=T):typeof n=="boolean"&&(r=n,n=T)),n===T&&t===T?(n=0,t=1):(n=Au(n),t===T?(t=n,n=0):t=Au(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Ti(),Ci(n+r*(t-n+Cn("1e-"+((r+"").length-1))),t)):ir(n,t)},An.reduce=function(n,t,r){var e=ff(n)?l:j,u=3>arguments.length;return e(n,ye(t,4),r,u,uo)},An.reduceRight=function(n,t,r){
var e=ff(n)?s:j,u=3>arguments.length;return e(n,ye(t,4),r,u,io)},An.repeat=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:ku(t),or(Iu(n),t)},An.replace=function(){var n=arguments,t=Iu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},An.result=function(n,t,r){t=Sr(t,n);var e=-1,u=t.length;for(u||(u=1,n=T);++e<u;){var i=null==n?T:n[Me(t[e])];i===T&&(e=u,i=r),n=_u(i)?i.call(n):i}return n},An.round=ec,An.runInContext=x,An.sample=function(n){return(ff(n)?Qn:cr)(n)},An.size=function(n){if(null==n)return 0;
if(su(n))return ju(n)?D(n):n.length;var t=vo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Vt(n).length},An.snakeCase=Df,An.some=function(n,t,r){var e=ff(n)?h:pr;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.sortedIndex=function(n,t){return _r(n,t)},An.sortedIndexBy=function(n,t,r){return vr(n,t,ye(r,2))},An.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){var e=_r(n,t);if(e<r&&lu(n[e],t))return e}return-1},An.sortedLastIndex=function(n,t){return _r(n,t,true)},An.sortedLastIndexBy=function(n,t,r){
return vr(n,t,ye(r,2),true)},An.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=_r(n,t,true)-1;if(lu(n[r],t))return r}return-1},An.startCase=Mf,An.startsWith=function(n,t,r){return n=Iu(n),r=null==r?0:pt(ku(r),0,n.length),t=yr(t),n.slice(r,r+t.length)==t},An.subtract=uc,An.sum=function(n){return n&&n.length?m(n,$u):0},An.sumBy=function(n,t){return n&&n.length?m(n,ye(t,2)):0},An.template=function(n,t,r){var e=An.templateSettings;r&&Oe(n,t,r)&&(t=T),n=Iu(n),t=bf({},t,e,ce),r=bf({},t.imports,e.imports,ce);
var u,i,o=Wu(r),f=S(r,o),c=0;r=t.interpolate||jn;var a="__p+='";r=Xu((t.escape||jn).source+"|"+r.source+"|"+(r===Q?pn:jn).source+"|"+(t.evaluate||jn).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(wn,z),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(P,""):a).replace(Z,"$1").replace(q,"$1;"),
a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Ff(function(){return Ju(o,l+"return "+a).apply(T,f)}),t.source=a,pu(t))throw t;return t},An.times=function(n,t){if(n=ku(n),1>n||9007199254740991<n)return[];var r=4294967295,e=Ci(n,4294967295);for(t=ye(t),n-=4294967295,e=A(e,t);++r<n;)t(r);return e},An.toFinite=Au,An.toInteger=ku,An.toLength=Eu,An.toLower=function(n){
return Iu(n).toLowerCase()},An.toNumber=Su,An.toSafeInteger=function(n){return n?pt(ku(n),-9007199254740991,9007199254740991):0===n?n:0},An.toString=Iu,An.toUpper=function(n){return Iu(n).toUpperCase()},An.trim=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(un,""):n&&(t=yr(t))?(n=M(n),r=M(t),t=I(n,r),r=R(n,r)+1,Or(n,t,r).join("")):n},An.trimEnd=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(fn,""):n&&(t=yr(t))?(n=M(n),t=R(n,M(t))+1,Or(n,0,t).join("")):n},An.trimStart=function(n,t,r){
return(n=Iu(n))&&(r||t===T)?n.replace(on,""):n&&(t=yr(t))?(n=M(n),t=I(n,M(t)),Or(n,t).join("")):n},An.truncate=function(n,t){var r=30,e="...";if(du(t))var u="separator"in t?t.separator:u,r="length"in t?ku(t.length):r,e="omission"in t?yr(t.omission):e;n=Iu(n);var i=n.length;if(Rn.test(n))var o=M(n),i=o.length;if(r>=i)return n;if(i=r-D(e),1>i)return e;if(r=o?Or(o,0,i).join(""):n.slice(0,i),u===T)return r+e;if(o&&(i+=r.length-i),hf(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=Xu(u.source,Iu(_n.exec(u))+"g")),
u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===T?i:c)}}else n.indexOf(yr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},An.unescape=function(n){return(n=Iu(n))&&G.test(n)?n.replace(V,tt):n},An.uniqueId=function(n){var t=++fi;return Iu(n)+t},An.upperCase=Tf,An.upperFirst=$f,An.each=nu,An.eachRight=tu,An.first=qe,Nu(An,function(){var n={};return mt(An,function(t,r){oi.call(An.prototype,r)||(n[r]=t)}),n}(),{chain:false}),An.VERSION="4.17.11",r("bind bindKey curry curryRight partial partialRight".split(" "),function(n){
An[n].placeholder=An}),r(["drop","take"],function(n,t){Ln.prototype[n]=function(r){r=r===T?1:Li(ku(r),0);var e=this.__filtered__&&!t?new Ln(this):this.clone();return e.__filtered__?e.__takeCount__=Ci(r,e.__takeCount__):e.__views__.push({size:Ci(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Ln.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Ln.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({
iteratee:ye(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){var r="take"+(t?"Right":"");Ln.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Ln.prototype[n]=function(){return this.__filtered__?new Ln(this):this[r](1)}}),Ln.prototype.compact=function(){return this.filter($u)},Ln.prototype.find=function(n){return this.filter(n).head()},Ln.prototype.findLast=function(n){return this.reverse().find(n);
},Ln.prototype.invokeMap=fr(function(n,t){return typeof n=="function"?new Ln(this):this.map(function(r){return Bt(r,n,t)})}),Ln.prototype.reject=function(n){return this.filter(au(ye(n)))},Ln.prototype.slice=function(n,t){n=ku(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Ln(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==T&&(t=ku(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Ln.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Ln.prototype.toArray=function(){return this.take(4294967295);
},mt(Ln.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=An[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(An.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Ln,c=o[0],l=f||ff(t),s=function(n){return n=u.apply(An,a([n],o)),e&&h?n[0]:n};l&&r&&typeof c=="function"&&1!=c.length&&(f=l=false);var h=this.__chain__,p=!!this.__actions__.length,c=i&&!h,f=f&&!p;return!i&&l?(t=f?t:new Ln(this),t=n.apply(t,o),t.__actions__.push({
func:Qe,args:[s],thisArg:T}),new On(t,h)):c&&f?n.apply(this,o):(t=this.thru(s),c?e?t.value()[0]:t.value():t)})}),r("pop push shift sort splice unshift".split(" "),function(n){var t=ri[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);An.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(ff(u)?u:[],n)}return this[r](function(r){return t.apply(ff(r)?r:[],n)})}}),mt(Ln.prototype,function(n,t){var r=An[t];if(r){var e=r.name+"";
(Gi[e]||(Gi[e]=[])).push({name:t,func:r})}}),Gi[Jr(T,2).name]=[{name:"wrapper",func:T}],Ln.prototype.clone=function(){var n=new Ln(this.__wrapped__);return n.__actions__=Lr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Lr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Lr(this.__views__),n},Ln.prototype.reverse=function(){if(this.__filtered__){var n=new Ln(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n;
},Ln.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=ff(t),u=0>r,i=e?t.length:0;n=0;for(var o=i,f=this.__views__,c=-1,a=f.length;++c<a;){var l=f[c],s=l.size;switch(l.type){case"drop":n+=s;break;case"dropRight":o-=s;break;case"take":o=Ci(o,n+s);break;case"takeRight":n=Li(n,o-s)}}if(n={start:n,end:o},o=n.start,f=n.end,n=f-o,o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Ci(n,this.__takeCount__),!e||!u&&i==n&&l==n)return wr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,
u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},An.prototype.at=To,An.prototype.chain=function(){return Ye(this)},An.prototype.commit=function(){return new On(this.value(),this.__chain__)},An.prototype.next=function(){this.__values__===T&&(this.__values__=mu(this.value()));var n=this.__index__>=this.__values__.length;return{done:n,value:n?T:this.__values__[this.__index__++]}},An.prototype.plant=function(n){for(var t,r=this;r instanceof kn;){
var e=Fe(r);e.__index__=0,e.__values__=T,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},An.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Ln?(this.__actions__.length&&(n=new Ln(this)),n=n.reverse(),n.__actions__.push({func:Qe,args:[Ge],thisArg:T}),new On(n,this.__chain__)):this.thru(Ge)},An.prototype.toJSON=An.prototype.valueOf=An.prototype.value=function(){return wr(this.__wrapped__,this.__actions__)},An.prototype.first=An.prototype.head,wi&&(An.prototype[wi]=Xe),
An}(); true?($n._=rt, !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return rt}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))):undefined}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js"), __webpack_require__("../../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../node_modules/loglevel/lib/loglevel.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),

/***/ "../../node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/reduce-reducers/es/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var initialState = typeof args[args.length - 1] !== 'function' && args.pop();
  var reducers = args;

  if (typeof initialState === 'undefined') {
    throw new TypeError('The initial state may not be undefined. If you do not want to set a value for this reducer, you can use null instead of undefined.');
  }

  return function (prevState, value) {
    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    var prevStateIsUndefined = typeof prevState === 'undefined';
    var valueIsUndefined = typeof value === 'undefined';

    if (prevStateIsUndefined && valueIsUndefined && initialState) {
      return initialState;
    }

    return reducers.reduce(function (newState, reducer) {
      return reducer.apply(undefined, [newState, value].concat(args));
    }, prevStateIsUndefined && !valueIsUndefined && initialState ? initialState : prevState);
  };
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/combineActions.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return combineActions; });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isFunction.js");
/* harmony import */ var _utils_isSymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isSymbol.js");
/* harmony import */ var _utils_isEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isEmpty.js");
/* harmony import */ var _utils_toString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux-actions/es/utils/toString.js");
/* harmony import */ var _utils_isString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isString.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/redux-actions/es/constants.js");








function isValidActionType(type) {
  return Object(_utils_isString__WEBPACK_IMPORTED_MODULE_5__["default"])(type) || Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(type) || Object(_utils_isSymbol__WEBPACK_IMPORTED_MODULE_2__["default"])(type);
}

function isValidActionTypes(types) {
  if (Object(_utils_isEmpty__WEBPACK_IMPORTED_MODULE_3__["default"])(types)) {
    return false;
  }

  return types.every(isValidActionType);
}

function combineActions() {
  for (var _len = arguments.length, actionsTypes = new Array(_len), _key = 0; _key < _len; _key++) {
    actionsTypes[_key] = arguments[_key];
  }

  invariant__WEBPACK_IMPORTED_MODULE_0___default()(isValidActionTypes(actionsTypes), 'Expected action types to be strings, symbols, or action creators');
  var combinedActionType = actionsTypes.map(_utils_toString__WEBPACK_IMPORTED_MODULE_4__["default"]).join(_constants__WEBPACK_IMPORTED_MODULE_6__["ACTION_TYPE_DELIMITER"]);
  return {
    toString: function toString() {
      return combinedActionType;
    }
  };
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/constants.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_NAMESPACE", function() { return DEFAULT_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACTION_TYPE_DELIMITER", function() { return ACTION_TYPE_DELIMITER; });
var DEFAULT_NAMESPACE = '/';
var ACTION_TYPE_DELIMITER = '||';

/***/ }),

/***/ "../../node_modules/redux-actions/es/createAction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createAction; });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isFunction.js");
/* harmony import */ var _utils_identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/identity.js");
/* harmony import */ var _utils_isNull__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isNull.js");




function createAction(type, payloadCreator, metaCreator) {
  if (payloadCreator === void 0) {
    payloadCreator = _utils_identity__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  invariant__WEBPACK_IMPORTED_MODULE_0___default()(Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(payloadCreator) || Object(_utils_isNull__WEBPACK_IMPORTED_MODULE_3__["default"])(payloadCreator), 'Expected payloadCreator to be a function, undefined or null');
  var finalPayloadCreator = Object(_utils_isNull__WEBPACK_IMPORTED_MODULE_3__["default"])(payloadCreator) || payloadCreator === _utils_identity__WEBPACK_IMPORTED_MODULE_2__["default"] ? _utils_identity__WEBPACK_IMPORTED_MODULE_2__["default"] : function (head) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return head instanceof Error ? head : payloadCreator.apply(void 0, [head].concat(args));
  };
  var hasMeta = Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(metaCreator);
  var typeString = type.toString();

  var actionCreator = function actionCreator() {
    var payload = finalPayloadCreator.apply(void 0, arguments);
    var action = {
      type: type
    };

    if (payload instanceof Error) {
      action.error = true;
    }

    if (payload !== undefined) {
      action.payload = payload;
    }

    if (hasMeta) {
      action.meta = metaCreator.apply(void 0, arguments);
    }

    return action;
  };

  actionCreator.toString = function () {
    return typeString;
  };

  return actionCreator;
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/createActions.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createActions; });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isPlainObject.js");
/* harmony import */ var _utils_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isFunction.js");
/* harmony import */ var _utils_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/identity.js");
/* harmony import */ var _utils_isArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isArray.js");
/* harmony import */ var _utils_isString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isString.js");
/* harmony import */ var _utils_isNil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isNil.js");
/* harmony import */ var _utils_getLastElement__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/redux-actions/es/utils/getLastElement.js");
/* harmony import */ var _utils_camelCase__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../../node_modules/redux-actions/es/utils/camelCase.js");
/* harmony import */ var _utils_arrayToObject__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../../node_modules/redux-actions/es/utils/arrayToObject.js");
/* harmony import */ var _utils_flattenActionMap__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("../../node_modules/redux-actions/es/utils/flattenActionMap.js");
/* harmony import */ var _utils_unflattenActionCreators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("../../node_modules/redux-actions/es/utils/unflattenActionCreators.js");
/* harmony import */ var _createAction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("../../node_modules/redux-actions/es/createAction.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("../../node_modules/redux-actions/es/constants.js");
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















function createActions(actionMap) {
  for (var _len = arguments.length, identityActions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    identityActions[_key - 1] = arguments[_key];
  }

  var options = Object(_utils_isPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_getLastElement__WEBPACK_IMPORTED_MODULE_7__["default"])(identityActions)) ? identityActions.pop() : {};
  invariant__WEBPACK_IMPORTED_MODULE_0___default()(identityActions.every(_utils_isString__WEBPACK_IMPORTED_MODULE_5__["default"]) && (Object(_utils_isString__WEBPACK_IMPORTED_MODULE_5__["default"])(actionMap) || Object(_utils_isPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(actionMap)), 'Expected optional object followed by string action types');

  if (Object(_utils_isString__WEBPACK_IMPORTED_MODULE_5__["default"])(actionMap)) {
    return actionCreatorsFromIdentityActions([actionMap].concat(identityActions), options);
  }

  return _objectSpread({}, actionCreatorsFromActionMap(actionMap, options), actionCreatorsFromIdentityActions(identityActions, options));
}

function actionCreatorsFromActionMap(actionMap, options) {
  var flatActionMap = Object(_utils_flattenActionMap__WEBPACK_IMPORTED_MODULE_10__["default"])(actionMap, options);
  var flatActionCreators = actionMapToActionCreators(flatActionMap);
  return Object(_utils_unflattenActionCreators__WEBPACK_IMPORTED_MODULE_11__["default"])(flatActionCreators, options);
}

function actionMapToActionCreators(actionMap, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      prefix = _ref.prefix,
      _ref$namespace = _ref.namespace,
      namespace = _ref$namespace === void 0 ? _constants__WEBPACK_IMPORTED_MODULE_13__["DEFAULT_NAMESPACE"] : _ref$namespace;

  function isValidActionMapValue(actionMapValue) {
    if (Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(actionMapValue) || Object(_utils_isNil__WEBPACK_IMPORTED_MODULE_6__["default"])(actionMapValue)) {
      return true;
    }

    if (Object(_utils_isArray__WEBPACK_IMPORTED_MODULE_4__["default"])(actionMapValue)) {
      var _actionMapValue$ = actionMapValue[0],
          payload = _actionMapValue$ === void 0 ? _utils_identity__WEBPACK_IMPORTED_MODULE_3__["default"] : _actionMapValue$,
          meta = actionMapValue[1];
      return Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(payload) && Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(meta);
    }

    return false;
  }

  return Object(_utils_arrayToObject__WEBPACK_IMPORTED_MODULE_9__["default"])(Object.keys(actionMap), function (partialActionCreators, type) {
    var _objectSpread2;

    var actionMapValue = actionMap[type];
    invariant__WEBPACK_IMPORTED_MODULE_0___default()(isValidActionMapValue(actionMapValue), 'Expected function, undefined, null, or array with payload and meta ' + ("functions for " + type));
    var prefixedType = prefix ? "" + prefix + namespace + type : type;
    var actionCreator = Object(_utils_isArray__WEBPACK_IMPORTED_MODULE_4__["default"])(actionMapValue) ? _createAction__WEBPACK_IMPORTED_MODULE_12__["default"].apply(void 0, [prefixedType].concat(actionMapValue)) : Object(_createAction__WEBPACK_IMPORTED_MODULE_12__["default"])(prefixedType, actionMapValue);
    return _objectSpread({}, partialActionCreators, (_objectSpread2 = {}, _objectSpread2[type] = actionCreator, _objectSpread2));
  });
}

function actionCreatorsFromIdentityActions(identityActions, options) {
  var actionMap = Object(_utils_arrayToObject__WEBPACK_IMPORTED_MODULE_9__["default"])(identityActions, function (partialActionMap, type) {
    var _objectSpread3;

    return _objectSpread({}, partialActionMap, (_objectSpread3 = {}, _objectSpread3[type] = _utils_identity__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread3));
  });
  var actionCreators = actionMapToActionCreators(actionMap, options);
  return Object(_utils_arrayToObject__WEBPACK_IMPORTED_MODULE_9__["default"])(Object.keys(actionCreators), function (partialActionCreators, type) {
    var _objectSpread4;

    return _objectSpread({}, partialActionCreators, (_objectSpread4 = {}, _objectSpread4[Object(_utils_camelCase__WEBPACK_IMPORTED_MODULE_8__["default"])(type)] = actionCreators[type], _objectSpread4));
  });
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/createCurriedAction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var just_curry_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/just-curry-it/index.js");
/* harmony import */ var just_curry_it__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(just_curry_it__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _createAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/createAction.js");


/* harmony default export */ __webpack_exports__["default"] = (function (type, payloadCreator) {
  return just_curry_it__WEBPACK_IMPORTED_MODULE_0___default()(Object(_createAction__WEBPACK_IMPORTED_MODULE_1__["default"])(type, payloadCreator), payloadCreator.length);
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/handleAction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handleAction; });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isFunction.js");
/* harmony import */ var _utils_isPlainObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isPlainObject.js");
/* harmony import */ var _utils_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/identity.js");
/* harmony import */ var _utils_isNil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isNil.js");
/* harmony import */ var _utils_isUndefined__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isUndefined.js");
/* harmony import */ var _utils_toString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/redux-actions/es/utils/toString.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/redux-actions/es/constants.js");








function handleAction(type, reducer, defaultState) {
  if (reducer === void 0) {
    reducer = _utils_identity__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

  var types = Object(_utils_toString__WEBPACK_IMPORTED_MODULE_6__["default"])(type).split(_constants__WEBPACK_IMPORTED_MODULE_7__["ACTION_TYPE_DELIMITER"]);
  invariant__WEBPACK_IMPORTED_MODULE_0___default()(!Object(_utils_isUndefined__WEBPACK_IMPORTED_MODULE_5__["default"])(defaultState), "defaultState for reducer handling " + types.join(', ') + " should be defined");
  invariant__WEBPACK_IMPORTED_MODULE_0___default()(Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(reducer) || Object(_utils_isPlainObject__WEBPACK_IMPORTED_MODULE_2__["default"])(reducer), 'Expected reducer to be a function or object with next and throw reducers');

  var _ref = Object(_utils_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(reducer) ? [reducer, reducer] : [reducer.next, reducer.throw].map(function (aReducer) {
    return Object(_utils_isNil__WEBPACK_IMPORTED_MODULE_4__["default"])(aReducer) ? _utils_identity__WEBPACK_IMPORTED_MODULE_3__["default"] : aReducer;
  }),
      nextReducer = _ref[0],
      throwReducer = _ref[1];

  return function (state, action) {
    if (state === void 0) {
      state = defaultState;
    }

    var actionType = action.type;

    if (!actionType || types.indexOf(Object(_utils_toString__WEBPACK_IMPORTED_MODULE_6__["default"])(actionType)) === -1) {
      return state;
    }

    return (action.error === true ? throwReducer : nextReducer)(state, action);
  };
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/handleActions.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return handleActions; });
/* harmony import */ var reduce_reducers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/reduce-reducers/es/index.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_isPlainObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isPlainObject.js");
/* harmony import */ var _utils_isMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isMap.js");
/* harmony import */ var _utils_ownKeys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux-actions/es/utils/ownKeys.js");
/* harmony import */ var _utils_flattenReducerMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux-actions/es/utils/flattenReducerMap.js");
/* harmony import */ var _handleAction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/redux-actions/es/handleAction.js");








function get(key, x) {
  return Object(_utils_isMap__WEBPACK_IMPORTED_MODULE_3__["default"])(x) ? x.get(key) : x[key];
}

function handleActions(handlers, defaultState, options) {
  if (options === void 0) {
    options = {};
  }

  invariant__WEBPACK_IMPORTED_MODULE_1___default()(Object(_utils_isPlainObject__WEBPACK_IMPORTED_MODULE_2__["default"])(handlers) || Object(_utils_isMap__WEBPACK_IMPORTED_MODULE_3__["default"])(handlers), 'Expected handlers to be a plain object.');
  var flattenedReducerMap = Object(_utils_flattenReducerMap__WEBPACK_IMPORTED_MODULE_5__["default"])(handlers, options);
  var reducers = Object(_utils_ownKeys__WEBPACK_IMPORTED_MODULE_4__["default"])(flattenedReducerMap).map(function (type) {
    return Object(_handleAction__WEBPACK_IMPORTED_MODULE_6__["default"])(type, get(type, flattenedReducerMap), defaultState);
  });
  var reducer = reduce_reducers__WEBPACK_IMPORTED_MODULE_0__["default"].apply(void 0, reducers.concat([defaultState]));
  return function (state, action) {
    if (state === void 0) {
      state = defaultState;
    }

    return reducer(state, action);
  };
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _combineActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/combineActions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineActions", function() { return _combineActions__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _createAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/createAction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createAction", function() { return _createAction__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _createActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/createActions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createActions", function() { return _createActions__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _createCurriedAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/createCurriedAction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCurriedAction", function() { return _createCurriedAction__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _handleAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux-actions/es/handleAction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "handleAction", function() { return _handleAction__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _handleActions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux-actions/es/handleActions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "handleActions", function() { return _handleActions__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/arrayToObject.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, callback) {
  return array.reduce(function (partialObject, element) {
    return callback(partialObject, element);
  }, {});
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/camelCase.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var to_camel_case__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/to-camel-case/index.js");
/* harmony import */ var to_camel_case__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(to_camel_case__WEBPACK_IMPORTED_MODULE_0__);

var namespacer = '/';
/* harmony default export */ __webpack_exports__["default"] = (function (type) {
  return type.indexOf(namespacer) === -1 ? to_camel_case__WEBPACK_IMPORTED_MODULE_0___default()(type) : type.split(namespacer).map(function (part) {
    return to_camel_case__WEBPACK_IMPORTED_MODULE_0___default()(part);
  }).join(namespacer);
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/flattenActionMap.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isPlainObject.js");
/* harmony import */ var _flattenWhenNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/flattenWhenNode.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_flattenWhenNode__WEBPACK_IMPORTED_MODULE_1__["default"])(_isPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"]));

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/flattenReducerMap.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isPlainObject.js");
/* harmony import */ var _isMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isMap.js");
/* harmony import */ var _hasGeneratorInterface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/hasGeneratorInterface.js");
/* harmony import */ var _flattenWhenNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux-actions/es/utils/flattenWhenNode.js");




/* harmony default export */ __webpack_exports__["default"] = (Object(_flattenWhenNode__WEBPACK_IMPORTED_MODULE_3__["default"])(function (node) {
  return (Object(_isPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || Object(_isMap__WEBPACK_IMPORTED_MODULE_1__["default"])(node)) && !Object(_hasGeneratorInterface__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
}));

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/flattenWhenNode.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/constants.js");
/* harmony import */ var _isMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isMap.js");
/* harmony import */ var _ownKeys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/ownKeys.js");




function get(key, x) {
  return Object(_isMap__WEBPACK_IMPORTED_MODULE_1__["default"])(x) ? x.get(key) : x[key];
}

/* harmony default export */ __webpack_exports__["default"] = (function (predicate) {
  return function flatten(map, _temp, partialFlatMap, partialFlatActionType) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$namespace = _ref.namespace,
        namespace = _ref$namespace === void 0 ? _constants__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_NAMESPACE"] : _ref$namespace,
        prefix = _ref.prefix;

    if (partialFlatMap === void 0) {
      partialFlatMap = {};
    }

    if (partialFlatActionType === void 0) {
      partialFlatActionType = '';
    }

    function connectNamespace(type) {
      var _ref2;

      if (!partialFlatActionType) return type;
      var types = type.toString().split(_constants__WEBPACK_IMPORTED_MODULE_0__["ACTION_TYPE_DELIMITER"]);
      var partials = partialFlatActionType.split(_constants__WEBPACK_IMPORTED_MODULE_0__["ACTION_TYPE_DELIMITER"]);
      return (_ref2 = []).concat.apply(_ref2, partials.map(function (p) {
        return types.map(function (t) {
          return "" + p + namespace + t;
        });
      })).join(_constants__WEBPACK_IMPORTED_MODULE_0__["ACTION_TYPE_DELIMITER"]);
    }

    function connectPrefix(type) {
      if (partialFlatActionType || !prefix) {
        return type;
      }

      return "" + prefix + namespace + type;
    }

    Object(_ownKeys__WEBPACK_IMPORTED_MODULE_2__["default"])(map).forEach(function (type) {
      var nextNamespace = connectPrefix(connectNamespace(type));
      var mapValue = get(type, map);

      if (predicate(mapValue)) {
        flatten(mapValue, {
          namespace: namespace,
          prefix: prefix
        }, partialFlatMap, nextNamespace);
      } else {
        partialFlatMap[nextNamespace] = mapValue;
      }
    });
    return partialFlatMap;
  };
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/getLastElement.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array) {
  return array[array.length - 1];
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/hasGeneratorInterface.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return hasGeneratorInterface; });
/* harmony import */ var _ownKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/utils/ownKeys.js");

function hasGeneratorInterface(handler) {
  var keys = Object(_ownKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(handler);
  var hasOnlyInterfaceNames = keys.every(function (ownKey) {
    return ownKey === 'next' || ownKey === 'throw';
  });
  return keys.length && keys.length <= 2 && hasOnlyInterfaceNames;
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/identity.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isArray.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return Array.isArray(value);
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isEmpty.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value.length === 0;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isFunction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return typeof value === 'function';
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isMap.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value instanceof Map;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isNil.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value === null || value === undefined;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isNull.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value === null;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isPlainObject.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  if (typeof value !== 'object' || value === null) return false;
  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isString.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return typeof value === 'string';
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isSymbol.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return typeof value === 'symbol' || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Symbol]';
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/isUndefined.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value === undefined;
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/ownKeys.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ownKeys; });
/* harmony import */ var _isMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isMap.js");

function ownKeys(object) {
  if (Object(_isMap__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    // We are using loose transforms in babel. Here we are trying to convert an
    // interable to an array. Loose mode expects everything to already be an
    // array. The problem is that our eslint rules encourage us to prefer
    // spread over Array.from.
    //
    // Instead of disabling loose mode we simply disable the warning.
    // eslint-disable-next-line unicorn/prefer-spread
    return Array.from(object.keys());
  }

  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {
    return Reflect.ownKeys(object);
  }

  var keys = Object.getOwnPropertyNames(object);

  if (typeof Object.getOwnPropertySymbols === 'function') {
    keys = keys.concat(Object.getOwnPropertySymbols(object));
  }

  return keys;
}

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/toString.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return value.toString();
});

/***/ }),

/***/ "../../node_modules/redux-actions/es/utils/unflattenActionCreators.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return unflattenActionCreators; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux-actions/es/constants.js");
/* harmony import */ var _isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux-actions/es/utils/isEmpty.js");
/* harmony import */ var _camelCase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux-actions/es/utils/camelCase.js");



function unflattenActionCreators(flatActionCreators, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$namespace = _ref.namespace,
      namespace = _ref$namespace === void 0 ? _constants__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_NAMESPACE"] : _ref$namespace,
      prefix = _ref.prefix;

  function unflatten(flatActionType, partialNestedActionCreators, partialFlatActionTypePath) {
    if (partialNestedActionCreators === void 0) {
      partialNestedActionCreators = {};
    }

    if (partialFlatActionTypePath === void 0) {
      partialFlatActionTypePath = [];
    }

    var nextNamespace = Object(_camelCase__WEBPACK_IMPORTED_MODULE_2__["default"])(partialFlatActionTypePath.shift());

    if (Object(_isEmpty__WEBPACK_IMPORTED_MODULE_1__["default"])(partialFlatActionTypePath)) {
      partialNestedActionCreators[nextNamespace] = flatActionCreators[flatActionType];
    } else {
      if (!partialNestedActionCreators[nextNamespace]) {
        partialNestedActionCreators[nextNamespace] = {};
      }

      unflatten(flatActionType, partialNestedActionCreators[nextNamespace], partialFlatActionTypePath);
    }
  }

  var nestedActionCreators = {};
  Object.getOwnPropertyNames(flatActionCreators).forEach(function (type) {
    var unprefixedType = prefix ? type.replace("" + prefix + namespace, '') : type;
    return unflatten(type, nestedActionCreators, unprefixedType.split(namespace));
  });
  return nestedActionCreators;
}

/***/ }),

/***/ "../../node_modules/redux-devtools-extension/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compose = __webpack_require__("../../node_modules/redux/es/index.js").compose;

exports.__esModule = true;
exports.composeWithDevTools = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :
    function() {
      if (arguments.length === 0) return undefined;
      if (typeof arguments[0] === 'object') return compose;
      return compose.apply(null, arguments);
    }
);

exports.devToolsEnhancer = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?
    window.__REDUX_DEVTOOLS_EXTENSION__ :
    function() { return function(noop) { return noop; } }
);


/***/ }),

/***/ "../../node_modules/redux-logger/dist/redux-logger.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _defineProperties = __webpack_require__("../../node_modules/babel-runtime/core-js/object/define-properties.js");

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _iterator = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _create = __webpack_require__("../../node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

!function (e, t) {
   true ? t(exports) : undefined;
}(undefined, function (e) {
  "use strict";
  function t(e, t) {
    e.super_ = t, e.prototype = (0, _create2.default)(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } });
  }function r(e, t) {
    Object.defineProperty(this, "kind", { value: e, enumerable: !0 }), t && t.length && Object.defineProperty(this, "path", { value: t, enumerable: !0 });
  }function n(e, t, r) {
    n.super_.call(this, "E", e), Object.defineProperty(this, "lhs", { value: t, enumerable: !0 }), Object.defineProperty(this, "rhs", { value: r, enumerable: !0 });
  }function o(e, t) {
    o.super_.call(this, "N", e), Object.defineProperty(this, "rhs", { value: t, enumerable: !0 });
  }function i(e, t) {
    i.super_.call(this, "D", e), Object.defineProperty(this, "lhs", { value: t, enumerable: !0 });
  }function a(e, t, r) {
    a.super_.call(this, "A", e), Object.defineProperty(this, "index", { value: t, enumerable: !0 }), Object.defineProperty(this, "item", { value: r, enumerable: !0 });
  }function f(e, t, r) {
    var n = e.slice((r || t) + 1 || e.length);return e.length = t < 0 ? e.length + t : t, e.push.apply(e, n), e;
  }function u(e) {
    var t = "undefined" == typeof e ? "undefined" : N(e);return "object" !== t ? t : e === Math ? "math" : null === e ? "null" : Array.isArray(e) ? "array" : "[object Date]" === Object.prototype.toString.call(e) ? "date" : "function" == typeof e.toString && /^\/.*\//.test(e.toString()) ? "regexp" : "object";
  }function l(e, t, r, c, s, d, p) {
    s = s || [], p = p || [];var g = s.slice(0);if ("undefined" != typeof d) {
      if (c) {
        if ("function" == typeof c && c(g, d)) return;if ("object" === ("undefined" == typeof c ? "undefined" : N(c))) {
          if (c.prefilter && c.prefilter(g, d)) return;if (c.normalize) {
            var h = c.normalize(g, d, e, t);h && (e = h[0], t = h[1]);
          }
        }
      }g.push(d);
    }"regexp" === u(e) && "regexp" === u(t) && (e = e.toString(), t = t.toString());var y = "undefined" == typeof e ? "undefined" : N(e),
        v = "undefined" == typeof t ? "undefined" : N(t),
        b = "undefined" !== y || p && p[p.length - 1].lhs && p[p.length - 1].lhs.hasOwnProperty(d),
        m = "undefined" !== v || p && p[p.length - 1].rhs && p[p.length - 1].rhs.hasOwnProperty(d);if (!b && m) r(new o(g, t));else if (!m && b) r(new i(g, e));else if (u(e) !== u(t)) r(new n(g, e, t));else if ("date" === u(e) && e - t !== 0) r(new n(g, e, t));else if ("object" === y && null !== e && null !== t) {
      if (p.filter(function (t) {
        return t.lhs === e;
      }).length) e !== t && r(new n(g, e, t));else {
        if (p.push({ lhs: e, rhs: t }), Array.isArray(e)) {
          var w;e.length;for (w = 0; w < e.length; w++) w >= t.length ? r(new a(g, w, new i(void 0, e[w]))) : l(e[w], t[w], r, c, g, w, p);for (; w < t.length;) r(new a(g, w, new o(void 0, t[w++])));
        } else {
          var x = (0, _keys2.default)(e),
              S = (0, _keys2.default)(t);x.forEach(function (n, o) {
            var i = S.indexOf(n);i >= 0 ? (l(e[n], t[n], r, c, g, n, p), S = f(S, i)) : l(e[n], void 0, r, c, g, n, p);
          }), S.forEach(function (e) {
            l(void 0, t[e], r, c, g, e, p);
          });
        }p.length = p.length - 1;
      }
    } else e !== t && ("number" === y && isNaN(e) && isNaN(t) || r(new n(g, e, t)));
  }function c(e, t, r, n) {
    return n = n || [], l(e, t, function (e) {
      e && n.push(e);
    }, r), n.length ? n : void 0;
  }function s(e, t, r) {
    if (r.path && r.path.length) {
      var n,
          o = e[t],
          i = r.path.length - 1;for (n = 0; n < i; n++) o = o[r.path[n]];switch (r.kind) {case "A":
          s(o[r.path[n]], r.index, r.item);break;case "D":
          delete o[r.path[n]];break;case "E":case "N":
          o[r.path[n]] = r.rhs;}
    } else switch (r.kind) {case "A":
        s(e[t], r.index, r.item);break;case "D":
        e = f(e, t);break;case "E":case "N":
        e[t] = r.rhs;}return e;
  }function d(e, t, r) {
    if (e && t && r && r.kind) {
      for (var n = e, o = -1, i = r.path ? r.path.length - 1 : 0; ++o < i;) "undefined" == typeof n[r.path[o]] && (n[r.path[o]] = "number" == typeof r.path[o] ? [] : {}), n = n[r.path[o]];switch (r.kind) {case "A":
          s(r.path ? n[r.path[o]] : n, r.index, r.item);break;case "D":
          delete n[r.path[o]];break;case "E":case "N":
          n[r.path[o]] = r.rhs;}
    }
  }function p(e, t, r) {
    if (r.path && r.path.length) {
      var n,
          o = e[t],
          i = r.path.length - 1;for (n = 0; n < i; n++) o = o[r.path[n]];switch (r.kind) {case "A":
          p(o[r.path[n]], r.index, r.item);break;case "D":
          o[r.path[n]] = r.lhs;break;case "E":
          o[r.path[n]] = r.lhs;break;case "N":
          delete o[r.path[n]];}
    } else switch (r.kind) {case "A":
        p(e[t], r.index, r.item);break;case "D":
        e[t] = r.lhs;break;case "E":
        e[t] = r.lhs;break;case "N":
        e = f(e, t);}return e;
  }function g(e, t, r) {
    if (e && t && r && r.kind) {
      var n,
          o,
          i = e;for (o = r.path.length - 1, n = 0; n < o; n++) "undefined" == typeof i[r.path[n]] && (i[r.path[n]] = {}), i = i[r.path[n]];switch (r.kind) {case "A":
          p(i[r.path[n]], r.index, r.item);break;case "D":
          i[r.path[n]] = r.lhs;break;case "E":
          i[r.path[n]] = r.lhs;break;case "N":
          delete i[r.path[n]];}
    }
  }function h(e, t, r) {
    if (e && t) {
      var n = function (n) {
        r && !r(e, t, n) || d(e, t, n);
      };l(e, t, n);
    }
  }function y(e) {
    return "color: " + F[e].color + "; font-weight: bold";
  }function v(e) {
    var t = e.kind,
        r = e.path,
        n = e.lhs,
        o = e.rhs,
        i = e.index,
        a = e.item;switch (t) {case "E":
        return [r.join("."), n, "", o];case "N":
        return [r.join("."), o];case "D":
        return [r.join(".")];case "A":
        return [r.join(".") + "[" + i + "]", a];default:
        return [];}
  }function b(e, t, r, n) {
    var o = c(e, t);try {
      n ? r.groupCollapsed("diff") : r.group("diff");
    } catch (e) {
      r.log("diff");
    }o ? o.forEach(function (e) {
      var t = e.kind,
          n = v(e);r.log.apply(r, ["%c " + F[t].text, y(t)].concat(P(n)));
    }) : r.log(" no diff ");try {
      r.groupEnd();
    } catch (e) {
      r.log(" diff end  ");
    }
  }function m(e, t, r, n) {
    switch ("undefined" == typeof e ? "undefined" : N(e)) {case "object":
        return "function" == typeof e[n] ? e[n].apply(e, P(r)) : e[n];case "function":
        return e(t);default:
        return e;}
  }function w(e) {
    var t = e.timestamp,
        r = e.duration;return function (e, n, o) {
      var i = ["action"];return i.push("%c" + String(e.type)), t && i.push("%c@ " + n), r && i.push("%c(in " + o.toFixed(2) + " ms)"), i.join(" ");
    };
  }function x(e, t) {
    var r = t.logger,
        n = t.actionTransformer,
        o = t.titleFormatter,
        i = void 0 === o ? w(t) : o,
        a = t.collapsed,
        f = t.colors,
        u = t.level,
        l = t.diff,
        c = "undefined" == typeof t.titleFormatter;e.forEach(function (o, s) {
      var d = o.started,
          p = o.startedTime,
          g = o.action,
          h = o.prevState,
          y = o.error,
          v = o.took,
          w = o.nextState,
          x = e[s + 1];x && (w = x.prevState, v = x.started - d);var S = n(g),
          k = "function" == typeof a ? a(function () {
        return w;
      }, g, o) : a,
          j = D(p),
          E = f.title ? "color: " + f.title(S) + ";" : "",
          A = ["color: gray; font-weight: lighter;"];A.push(E), t.timestamp && A.push("color: gray; font-weight: lighter;"), t.duration && A.push("color: gray; font-weight: lighter;");var O = i(S, j, v);try {
        k ? f.title && c ? r.groupCollapsed.apply(r, ["%c " + O].concat(A)) : r.groupCollapsed(O) : f.title && c ? r.group.apply(r, ["%c " + O].concat(A)) : r.group(O);
      } catch (e) {
        r.log(O);
      }var N = m(u, S, [h], "prevState"),
          P = m(u, S, [S], "action"),
          C = m(u, S, [y, h], "error"),
          F = m(u, S, [w], "nextState");if (N) if (f.prevState) {
        var L = "color: " + f.prevState(h) + "; font-weight: bold";r[N]("%c prev state", L, h);
      } else r[N]("prev state", h);if (P) if (f.action) {
        var T = "color: " + f.action(S) + "; font-weight: bold";r[P]("%c action    ", T, S);
      } else r[P]("action    ", S);if (y && C) if (f.error) {
        var M = "color: " + f.error(y, h) + "; font-weight: bold;";r[C]("%c error     ", M, y);
      } else r[C]("error     ", y);if (F) if (f.nextState) {
        var _ = "color: " + f.nextState(w) + "; font-weight: bold";r[F]("%c next state", _, w);
      } else r[F]("next state", w);l && b(h, w, r, k);try {
        r.groupEnd();
      } catch (e) {
        r.log(" log end ");
      }
    });
  }function S() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = (0, _assign2.default)({}, L, e),
        r = t.logger,
        n = t.stateTransformer,
        o = t.errorTransformer,
        i = t.predicate,
        a = t.logErrors,
        f = t.diffPredicate;if ("undefined" == typeof r) return function () {
      return function (e) {
        return function (t) {
          return e(t);
        };
      };
    };if (e.getState && e.dispatch) return console.error("[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\nconst logger = createLogger({\n  // ...options\n});\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"), function () {
      return function (e) {
        return function (t) {
          return e(t);
        };
      };
    };var u = [];return function (e) {
      var r = e.getState;return function (e) {
        return function (l) {
          if ("function" == typeof i && !i(r, l)) return e(l);var c = {};u.push(c), c.started = O.now(), c.startedTime = new Date(), c.prevState = n(r()), c.action = l;var s = void 0;if (a) try {
            s = e(l);
          } catch (e) {
            c.error = o(e);
          } else s = e(l);c.took = O.now() - c.started, c.nextState = n(r());var d = t.diff && "function" == typeof f ? f(r, l) : t.diff;if (x(u, (0, _assign2.default)({}, t, { diff: d })), u.length = 0, c.error) throw c.error;return s;
        };
      };
    };
  }var k,
      j,
      E = function (e, t) {
    return new Array(t + 1).join(e);
  },
      A = function (e, t) {
    return E("0", t - e.toString().length) + e;
  },
      D = function (e) {
    return A(e.getHours(), 2) + ":" + A(e.getMinutes(), 2) + ":" + A(e.getSeconds(), 2) + "." + A(e.getMilliseconds(), 3);
  },
      O = "undefined" != typeof performance && null !== performance && "function" == typeof performance.now ? performance : Date,
      N = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function (e) {
    return typeof e;
  } : function (e) {
    return e && "function" == typeof _symbol2.default && e.constructor === _symbol2.default && e !== _symbol2.default.prototype ? "symbol" : typeof e;
  },
      P = function (e) {
    if (Array.isArray(e)) {
      for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];return r;
    }return (0, _from2.default)(e);
  },
      C = [];k = "object" === ("undefined" == typeof global ? "undefined" : N(global)) && global ? global : "undefined" != typeof window ? window : {}, j = k.DeepDiff, j && C.push(function () {
    "undefined" != typeof j && k.DeepDiff === c && (k.DeepDiff = j, j = void 0);
  }), t(n, r), t(o, r), t(i, r), t(a, r), (0, _defineProperties2.default)(c, { diff: { value: c, enumerable: !0 }, observableDiff: { value: l, enumerable: !0 }, applyDiff: { value: h, enumerable: !0 }, applyChange: { value: d, enumerable: !0 }, revertChange: { value: g, enumerable: !0 }, isConflict: { value: function () {
        return "undefined" != typeof j;
      }, enumerable: !0 }, noConflict: { value: function () {
        return C && (C.forEach(function (e) {
          e();
        }), C = null), c;
      }, enumerable: !0 } });var F = { E: { color: "#2196F3", text: "CHANGED:" }, N: { color: "#4CAF50", text: "ADDED:" }, D: { color: "#F44336", text: "DELETED:" }, A: { color: "#2196F3", text: "ARRAY:" } },
      L = { level: "log", logger: console, logErrors: !0, collapsed: void 0, predicate: void 0, duration: !1, timestamp: !0, stateTransformer: function (e) {
      return e;
    }, actionTransformer: function (e) {
      return e;
    }, errorTransformer: function (e) {
      return e;
    }, colors: { title: function () {
        return "inherit";
      }, prevState: function () {
        return "#9E9E9E";
      }, action: function () {
        return "#03A9F4";
      }, nextState: function () {
        return "#4CAF50";
      }, error: function () {
        return "#F20404";
      } }, diff: !1, diffPredicate: void 0, transformer: void 0 },
      T = function () {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        t = e.dispatch,
        r = e.getState;return "function" == typeof t || "function" == typeof r ? S()({ dispatch: t, getState: r }) : void console.error("\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from 'redux-logger'\n[redux-logger v3] to\n[redux-logger v3] import { createLogger } from 'redux-logger'\n");
  };e.defaults = L, e.createLogger = S, e.logger = T, e.default = T, Object.defineProperty(e, "__esModule", { value: !0 });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/redux-saga/es/effects.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

Object.defineProperty(exports, 'take', {
  enumerable: true,
  get: function () {
    return _io.take;
  }
});
Object.defineProperty(exports, 'takeMaybe', {
  enumerable: true,
  get: function () {
    return _io.takeMaybe;
  }
});
Object.defineProperty(exports, 'put', {
  enumerable: true,
  get: function () {
    return _io.put;
  }
});
Object.defineProperty(exports, 'putResolve', {
  enumerable: true,
  get: function () {
    return _io.putResolve;
  }
});
Object.defineProperty(exports, 'all', {
  enumerable: true,
  get: function () {
    return _io.all;
  }
});
Object.defineProperty(exports, 'race', {
  enumerable: true,
  get: function () {
    return _io.race;
  }
});
Object.defineProperty(exports, 'call', {
  enumerable: true,
  get: function () {
    return _io.call;
  }
});
Object.defineProperty(exports, 'apply', {
  enumerable: true,
  get: function () {
    return _io.apply;
  }
});
Object.defineProperty(exports, 'cps', {
  enumerable: true,
  get: function () {
    return _io.cps;
  }
});
Object.defineProperty(exports, 'fork', {
  enumerable: true,
  get: function () {
    return _io.fork;
  }
});
Object.defineProperty(exports, 'spawn', {
  enumerable: true,
  get: function () {
    return _io.spawn;
  }
});
Object.defineProperty(exports, 'join', {
  enumerable: true,
  get: function () {
    return _io.join;
  }
});
Object.defineProperty(exports, 'cancel', {
  enumerable: true,
  get: function () {
    return _io.cancel;
  }
});
Object.defineProperty(exports, 'select', {
  enumerable: true,
  get: function () {
    return _io.select;
  }
});
Object.defineProperty(exports, 'actionChannel', {
  enumerable: true,
  get: function () {
    return _io.actionChannel;
  }
});
Object.defineProperty(exports, 'cancelled', {
  enumerable: true,
  get: function () {
    return _io.cancelled;
  }
});
Object.defineProperty(exports, 'flush', {
  enumerable: true,
  get: function () {
    return _io.flush;
  }
});
Object.defineProperty(exports, 'getContext', {
  enumerable: true,
  get: function () {
    return _io.getContext;
  }
});
Object.defineProperty(exports, 'setContext', {
  enumerable: true,
  get: function () {
    return _io.setContext;
  }
});
Object.defineProperty(exports, 'takeEvery', {
  enumerable: true,
  get: function () {
    return _io.takeEvery;
  }
});
Object.defineProperty(exports, 'takeLatest', {
  enumerable: true,
  get: function () {
    return _io.takeLatest;
  }
});
Object.defineProperty(exports, 'takeLeading', {
  enumerable: true,
  get: function () {
    return _io.takeLeading;
  }
});
Object.defineProperty(exports, 'throttle', {
  enumerable: true,
  get: function () {
    return _io.throttle;
  }
});
Object.defineProperty(exports, 'delay', {
  enumerable: true,
  get: function () {
    return _io.delay;
  }
});

/***/ }),

/***/ "../../node_modules/redux-saga/es/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffers = exports.utils = exports.effects = exports.detach = exports.SAGA_LOCATION = exports.CANCEL = exports.stdChannel = exports.multicastChannel = exports.channel = exports.eventChannel = exports.END = exports.runSaga = undefined;

var _runSaga = __webpack_require__("../../node_modules/redux-saga/es/internal/runSaga.js");

Object.defineProperty(exports, 'runSaga', {
  enumerable: true,
  get: function () {
    return _runSaga.runSaga;
  }
});

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

Object.defineProperty(exports, 'END', {
  enumerable: true,
  get: function () {
    return _channel.END;
  }
});
Object.defineProperty(exports, 'eventChannel', {
  enumerable: true,
  get: function () {
    return _channel.eventChannel;
  }
});
Object.defineProperty(exports, 'channel', {
  enumerable: true,
  get: function () {
    return _channel.channel;
  }
});
Object.defineProperty(exports, 'multicastChannel', {
  enumerable: true,
  get: function () {
    return _channel.multicastChannel;
  }
});
Object.defineProperty(exports, 'stdChannel', {
  enumerable: true,
  get: function () {
    return _channel.stdChannel;
  }
});

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

Object.defineProperty(exports, 'CANCEL', {
  enumerable: true,
  get: function () {
    return _symbols.CANCEL;
  }
});
Object.defineProperty(exports, 'SAGA_LOCATION', {
  enumerable: true,
  get: function () {
    return _symbols.SAGA_LOCATION;
  }
});

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

Object.defineProperty(exports, 'detach', {
  enumerable: true,
  get: function () {
    return _io.detach;
  }
});

var _middleware = __webpack_require__("../../node_modules/redux-saga/es/internal/middleware.js");

var _middleware2 = _interopRequireDefault(_middleware);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var effects = _interopRequireWildcard(_effects);

var _utils = __webpack_require__("../../node_modules/redux-saga/es/utils.js");

var utils = _interopRequireWildcard(_utils);

var _buffers = __webpack_require__("../../node_modules/redux-saga/es/internal/buffers.js");

var buffers = _interopRequireWildcard(_buffers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _middleware2.default;
exports.effects = effects;
exports.utils = utils;
exports.buffers = buffers;

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/buffers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expanding = exports.sliding = exports.dropping = exports.fixed = exports.none = undefined;

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_DROP = 2;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;
var zeroBuffer = {
  isEmpty: _utils.kTrue,
  put: _utils.noop,
  take: _utils.noop
};

function ringBuffer(limit, overflowAction) {
  if (limit === void 0) {
    limit = 10;
  }

  var arr = new Array(limit);
  var length = 0;
  var pushIndex = 0;
  var popIndex = 0;

  var push = function push(it) {
    arr[pushIndex] = it;
    pushIndex = (pushIndex + 1) % limit;
    length++;
  };

  var take = function take() {
    if (length != 0) {
      var it = arr[popIndex];
      arr[popIndex] = null;
      length--;
      popIndex = (popIndex + 1) % limit;
      return it;
    }
  };

  var flush = function flush() {
    var items = [];

    while (length) {
      items.push(take());
    }

    return items;
  };

  return {
    isEmpty: function isEmpty() {
      return length == 0;
    },
    put: function put(it) {
      if (length < limit) {
        push(it);
      } else {
        var doubledLimit;

        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);

          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;

          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;
            arr = flush();
            length = arr.length;
            pushIndex = arr.length;
            popIndex = 0;
            arr.length = doubledLimit;
            limit = doubledLimit;
            push(it);
            break;

          default: // DROP

        }
      }
    },
    take: take,
    flush: flush
  };
}

var none = exports.none = function none() {
  return zeroBuffer;
};
var fixed = exports.fixed = function fixed(limit) {
  return ringBuffer(limit, ON_OVERFLOW_THROW);
};
var dropping = exports.dropping = function dropping(limit) {
  return ringBuffer(limit, ON_OVERFLOW_DROP);
};
var sliding = exports.sliding = function sliding(limit) {
  return ringBuffer(limit, ON_OVERFLOW_SLIDE);
};
var expanding = exports.expanding = function expanding(initialSize) {
  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
};

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/channel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEnd = exports.END = undefined;
exports.channel = channel;
exports.eventChannel = eventChannel;
exports.multicastChannel = multicastChannel;
exports.stdChannel = stdChannel;

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var _buffers = __webpack_require__("../../node_modules/redux-saga/es/internal/buffers.js");

var buffers = _interopRequireWildcard(_buffers);

var _scheduler = __webpack_require__("../../node_modules/redux-saga/es/internal/scheduler.js");

var _matcher = __webpack_require__("../../node_modules/redux-saga/es/internal/matcher.js");

var matchers = _interopRequireWildcard(_matcher);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var END = exports.END = {
  type: _symbols.CHANNEL_END_TYPE
};
var isEnd = exports.isEnd = function isEnd(a) {
  return a && a.type === _symbols.CHANNEL_END_TYPE;
};
var INVALID_BUFFER = 'invalid buffer passed to channel factory function';
var UNDEFINED_INPUT_ERROR = "Saga or channel was provided with an undefined action\nHints:\n  - check that your Action Creator returns a non-undefined value\n  - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners";
function channel(buffer) {
  if (buffer === void 0) {
    buffer = buffers.expanding();
  }

  var closed = false;
  var takers = [];

  if (true) {
    (0, _utils.check)(buffer, _utils.is.buffer, INVALID_BUFFER);
  }

  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw (0, _utils.internalErr)('Cannot have a closed channel with pending takers');
    }

    if (takers.length && !buffer.isEmpty()) {
      throw (0, _utils.internalErr)('Cannot have pending takers with non empty buffer');
    }
  }

  function put(input) {
    checkForbiddenStates();

    if (true) {
      (0, _utils.check)(input, _utils.is.notUndef, UNDEFINED_INPUT_ERROR);
    }

    if (closed) {
      return;
    }

    if (!takers.length) {
      return buffer.put(input);
    }

    var cb = takers[0];
    takers.splice(0, 1);
    cb(input);
  }

  function take(cb) {
    checkForbiddenStates();

    if (true) {
      (0, _utils.check)(cb, _utils.is.func, "channel.take's callback must be a function");
    }

    if (closed && buffer.isEmpty()) {
      cb(END);
    } else if (!buffer.isEmpty()) {
      cb(buffer.take());
    } else {
      takers.push(cb);

      cb.cancel = function () {
        return (0, _utils.remove)(takers, cb);
      };
    }
  }

  function flush(cb) {
    checkForbiddenStates(); // TODO: check if some new state should be forbidden now

    if (true) {
      (0, _utils.check)(cb, _utils.is.func, "channel.flush' callback must be a function");
    }

    if (closed && buffer.isEmpty()) {
      cb(END);
      return;
    }

    cb(buffer.flush());
  }

  function close() {
    checkForbiddenStates();

    if (!closed) {
      closed = true;

      if (takers.length) {
        var arr = takers;
        takers = [];

        for (var i = 0, len = arr.length; i < len; i++) {
          var taker = arr[i];
          taker(END);
        }
      }
    }
  }

  return {
    take: take,
    put: put,
    flush: flush,
    close: close
  };
}
function eventChannel(subscribe, buffer) {
  if (buffer === void 0) {
    buffer = buffers.none();
  }

  var closed = false;
  var unsubscribe;
  var chan = channel(buffer);

  var close = function close() {
    if (_utils.is.func(unsubscribe)) {
      unsubscribe();
    }

    chan.close();
  };

  unsubscribe = subscribe(function (input) {
    if (isEnd(input)) {
      close();
      closed = true;
      return;
    }

    chan.put(input);
  });

  if (!_utils.is.func(unsubscribe)) {
    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');
  }

  unsubscribe = (0, _utils.once)(unsubscribe);

  if (closed) {
    unsubscribe();
  }

  return {
    take: chan.take,
    flush: chan.flush,
    close: close
  };
}
function multicastChannel() {
  var _ref;

  var closed = false;
  var currentTakers = [];
  var nextTakers = currentTakers;

  var ensureCanMutateNextTakers = function ensureCanMutateNextTakers() {
    if (nextTakers !== currentTakers) {
      return;
    }

    nextTakers = currentTakers.slice();
  }; // TODO: check if its possible to extract closing function and reuse it in both unicasts and multicasts


  var close = function close() {
    closed = true;
    var takers = currentTakers = nextTakers;

    for (var i = 0; i < takers.length; i++) {
      var taker = takers[i];
      taker(END);
    }

    nextTakers = [];
  };

  return _ref = {}, _ref[_symbols.MULTICAST] = true, _ref.put = function put(input) {
    // TODO: should I check forbidden state here? 1 of them is even impossible
    // as we do not possibility of buffer here
    if (true) {
      (0, _utils.check)(input, _utils.is.notUndef, UNDEFINED_INPUT_ERROR);
    }

    if (closed) {
      return;
    }

    if (isEnd(input)) {
      close();
      return;
    }

    var takers = currentTakers = nextTakers;

    for (var i = 0; i < takers.length; i++) {
      var taker = takers[i];

      if (taker[_symbols.MATCH](input)) {
        taker.cancel();
        taker(input);
      }
    }
  }, _ref.take = function take(cb, matcher) {
    if (matcher === void 0) {
      matcher = matchers.wildcard;
    }

    if (closed) {
      cb(END);
      return;
    }

    cb[_symbols.MATCH] = matcher;
    ensureCanMutateNextTakers();
    nextTakers.push(cb);
    cb.cancel = (0, _utils.once)(function () {
      ensureCanMutateNextTakers();
      (0, _utils.remove)(nextTakers, cb);
    });
  }, _ref.close = close, _ref;
}
function stdChannel() {
  var chan = multicastChannel();
  var put = chan.put;

  chan.put = function (input) {
    if (input[_symbols.SAGA_ACTION]) {
      put(input);
      return;
    }

    (0, _scheduler.asap)(function () {
      return put(input);
    });
  };

  return chan;
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/error-utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocation = getLocation;
exports.sagaStackToString = sagaStackToString;
exports.addSagaStack = addSagaStack;

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

function formatLocation(fileName, lineNumber) {
  return fileName + "?" + lineNumber;
}

function getLocation(instrumented) {
  return instrumented[_symbols.SAGA_LOCATION];
}

function effectLocationAsString(effect) {
  var location = getLocation(effect);

  if (location) {
    var code = location.code,
        fileName = location.fileName,
        lineNumber = location.lineNumber;
    var source = code + "  " + formatLocation(fileName, lineNumber);
    return source;
  }

  return '';
}

function sagaLocationAsString(sagaMeta) {
  var name = sagaMeta.name,
      location = sagaMeta.location;

  if (location) {
    return name + "  " + formatLocation(location.fileName, location.lineNumber);
  }

  return name;
}

var flatMap = function flatMap(arr, getter) {
  if (getter === void 0) {
    getter = function getter(f) {
      return f;
    };
  }

  return arr.reduce(function (acc, i) {
    return acc.concat(getter(i));
  }, []);
};

function cancelledTasksAsString(sagaStack) {
  var cancelledTasks = flatMap(sagaStack, function (i) {
    return i.cancelledTasks;
  });

  if (!cancelledTasks.length) {
    return '';
  }

  return ['Tasks cancelled due to error:'].concat(cancelledTasks).join('\n');
}
/**
    @param {saga, effect}[] sagaStack
    @returns {string}

    @example
    The above error occurred in task errorInPutSaga {pathToFile}
    when executing effect put({type: 'REDUCER_ACTION_ERROR_IN_PUT'}) {pathToFile}
        created by fetchSaga {pathToFile}
        created by rootSaga {pathToFile}
*/

function sagaStackToString(sagaStack) {
  var firstSaga = sagaStack[0],
      otherSagas = sagaStack.slice(1);
  var crashedEffectLocation = firstSaga.effect ? effectLocationAsString(firstSaga.effect) : null;
  var errorMessage = "The above error occurred in task " + sagaLocationAsString(firstSaga.meta) + (crashedEffectLocation ? " \n when executing effect " + crashedEffectLocation : '');
  return [errorMessage].concat(otherSagas.map(function (s) {
    return "    created by " + sagaLocationAsString(s.meta);
  }), [cancelledTasksAsString(sagaStack)]).join('\n');
}
function addSagaStack(errorObject, errorStack) {
  if (typeof errorObject === 'object') {
    if (typeof errorObject.sagaStack === 'undefined') {
      // property is used as a stack of descriptors for failed sagas
      // after formatting to string it will be re-written
      // to pass sagaStack as a string in user land
      Object.defineProperty(errorObject, 'sagaStack', {
        value: [],
        writable: true,
        enumerable: false
      });
    }

    errorObject.sagaStack.push(errorStack);
  }
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/io.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asEffect = exports.delay = exports.putResolve = exports.takeMaybe = exports.detach = undefined;
exports.take = take;
exports.put = put;
exports.all = all;
exports.race = race;
exports.call = call;
exports.apply = apply;
exports.cps = cps;
exports.fork = fork;
exports.spawn = spawn;
exports.join = join;
exports.cancel = cancel;
exports.select = select;
exports.actionChannel = actionChannel;
exports.cancelled = cancelled;
exports.flush = flush;
exports.getContext = getContext;
exports.setContext = setContext;
exports.takeEvery = takeEvery;
exports.takeLatest = takeLatest;
exports.takeLeading = takeLeading;
exports.throttle = throttle;

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var _sagaHelpers = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/index.js");

var TAKE = 'TAKE';
var PUT = 'PUT';
var ALL = 'ALL';
var RACE = 'RACE';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var ACTION_CHANNEL = 'ACTION_CHANNEL';
var CANCELLED = 'CANCELLED';
var FLUSH = 'FLUSH';
var GET_CONTEXT = 'GET_CONTEXT';
var SET_CONTEXT = 'SET_CONTEXT';
var TEST_HINT = '\n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)';

var effect = function effect(type, payload) {
  var _ref;

  return _ref = {}, _ref[_symbols.IO] = true, _ref[type] = payload, _ref;
};

var detach = exports.detach = function detach(eff) {
  if (true) {
    (0, _utils.check)(asEffect.fork(eff), _utils.is.object, 'detach(eff): argument must be a fork effect');
  }

  eff[FORK].detached = true;
  return eff;
};
function take(patternOrChannel, multicastPattern) {
  if (patternOrChannel === void 0) {
    patternOrChannel = '*';
  }

  if (true && arguments.length) {
    (0, _utils.check)(arguments[0], _utils.is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');
  }

  if (_utils.is.pattern(patternOrChannel)) {
    return effect(TAKE, {
      pattern: patternOrChannel
    });
  }

  if (_utils.is.multicast(patternOrChannel) && _utils.is.notUndef(multicastPattern) && _utils.is.pattern(multicastPattern)) {
    return effect(TAKE, {
      channel: patternOrChannel,
      pattern: multicastPattern
    });
  }

  if (_utils.is.channel(patternOrChannel)) {
    return effect(TAKE, {
      channel: patternOrChannel
    });
  }

  throw new Error("take(patternOrChannel): argument " + patternOrChannel + " is not valid channel or a valid pattern");
}

var takeMaybe = function takeMaybe() {
  var eff = take.apply(void 0, arguments);
  eff[TAKE].maybe = true;
  return eff;
};

exports.takeMaybe = takeMaybe;
function put(channel, action) {
  if (true) {
    if (arguments.length > 1) {
      (0, _utils.check)(channel, _utils.is.notUndef, 'put(channel, action): argument channel is undefined');
      (0, _utils.check)(channel, _utils.is.channel, "put(channel, action): argument " + channel + " is not a valid channel");
      (0, _utils.check)(action, _utils.is.notUndef, 'put(channel, action): argument action is undefined');
    } else {
      (0, _utils.check)(channel, _utils.is.notUndef, 'put(action): argument action is undefined');
    }
  }

  if (_utils.is.undef(action)) {
    action = channel;
    channel = null;
  }

  return effect(PUT, {
    channel: channel,
    action: action
  });
}

var putResolve = function putResolve() {
  var eff = put.apply(void 0, arguments);
  eff[PUT].resolve = true;
  return eff;
};

exports.putResolve = putResolve;
function all(effects) {
  return effect(ALL, effects);
}
function race(effects) {
  return effect(RACE, effects);
}

function getFnCallDesc(meth, fn, args) {
  if (true) {
    (0, _utils.check)(fn, _utils.is.notUndef, meth + ": argument fn is undefined");
  }

  var context = null;

  if (_utils.is.array(fn)) {
    var _fn = fn;
    context = _fn[0];
    fn = _fn[1];
  } else if (fn.fn) {
    var _fn2 = fn;
    context = _fn2.context;
    fn = _fn2.fn;
  }

  if (context && _utils.is.string(fn) && _utils.is.func(context[fn])) {
    fn = context[fn];
  }

  if (true) {
    (0, _utils.check)(fn, _utils.is.func, meth + ": argument " + fn + " is not a function");
  }

  return {
    context: context,
    fn: fn,
    args: args
  };
}

function call(fn) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return effect(CALL, getFnCallDesc('call', fn, args));
}
function apply(context, fn, args) {
  if (args === void 0) {
    args = [];
  }

  return effect(CALL, getFnCallDesc('apply', {
    context: context,
    fn: fn
  }, args));
}
function cps(fn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return effect(CPS, getFnCallDesc('cps', fn, args));
}
function fork(fn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return effect(FORK, getFnCallDesc('fork', fn, args));
}
function spawn(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  return detach(fork.apply(void 0, [fn].concat(args)));
}
function join() {
  for (var _len5 = arguments.length, tasks = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    tasks[_key5] = arguments[_key5];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return join(t);
    }));
  }

  var task = tasks[0];

  if (true) {
    (0, _utils.check)(task, _utils.is.notUndef, 'join(task): argument task is undefined');
    (0, _utils.check)(task, _utils.is.task, "join(task): argument " + task + " is not a valid Task object " + TEST_HINT);
  }

  return effect(JOIN, task);
}
function cancel() {
  for (var _len6 = arguments.length, tasks = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    tasks[_key6] = arguments[_key6];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return cancel(t);
    }));
  }

  var task = tasks[0];

  if (true && tasks.length === 1) {
    (0, _utils.check)(task, _utils.is.notUndef, 'cancel(task): argument task is undefined');
    (0, _utils.check)(task, _utils.is.task, "cancel(task): argument " + task + " is not a valid Task object " + TEST_HINT);
  }

  return effect(CANCEL, task || _symbols.SELF_CANCELLATION);
}
function select(selector) {
  if (selector === void 0) {
    selector = _utils.identity;
  }

  for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }

  if (true && arguments.length) {
    (0, _utils.check)(arguments[0], _utils.is.notUndef, 'select(selector, [...]): argument selector is undefined');
    (0, _utils.check)(selector, _utils.is.func, "select(selector, [...]): argument " + selector + " is not a function");
  }

  return effect(SELECT, {
    selector: selector,
    args: args
  });
}
/**
  channel(pattern, [buffer])    => creates a proxy channel for store actions
**/

function actionChannel(pattern, buffer) {
  if (true) {
    (0, _utils.check)(pattern, _utils.is.notUndef, 'actionChannel(pattern,...): argument pattern is undefined');

    if (arguments.length > 1) {
      (0, _utils.check)(buffer, _utils.is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined');
      (0, _utils.check)(buffer, _utils.is.buffer, "actionChannel(pattern, buffer): argument " + buffer + " is not a valid buffer");
    }
  }

  return effect(ACTION_CHANNEL, {
    pattern: pattern,
    buffer: buffer
  });
}
function cancelled() {
  return effect(CANCELLED, {});
}
function flush(channel) {
  if (true) {
    (0, _utils.check)(channel, _utils.is.channel, "flush(channel): argument " + channel + " is not valid channel");
  }

  return effect(FLUSH, channel);
}
function getContext(prop) {
  if (true) {
    (0, _utils.check)(prop, _utils.is.string, "getContext(prop): argument " + prop + " is not a string");
  }

  return effect(GET_CONTEXT, prop);
}
function setContext(props) {
  if (true) {
    (0, _utils.check)(props, _utils.is.object, (0, _utils.createSetContextWarning)(null, props));
  }

  return effect(SET_CONTEXT, props);
}
function takeEvery(patternOrChannel, worker) {
  for (var _len8 = arguments.length, args = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
    args[_key8 - 2] = arguments[_key8];
  }

  return fork.apply(void 0, [_sagaHelpers.takeEveryHelper, patternOrChannel, worker].concat(args));
}
function takeLatest(patternOrChannel, worker) {
  for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
    args[_key9 - 2] = arguments[_key9];
  }

  return fork.apply(void 0, [_sagaHelpers.takeLatestHelper, patternOrChannel, worker].concat(args));
}
function takeLeading(patternOrChannel, worker) {
  for (var _len10 = arguments.length, args = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {
    args[_key10 - 2] = arguments[_key10];
  }

  return fork.apply(void 0, [_sagaHelpers.takeLeadingHelper, patternOrChannel, worker].concat(args));
}
function throttle(ms, pattern, worker) {
  for (var _len11 = arguments.length, args = new Array(_len11 > 3 ? _len11 - 3 : 0), _key11 = 3; _key11 < _len11; _key11++) {
    args[_key11 - 3] = arguments[_key11];
  }

  return fork.apply(void 0, [_sagaHelpers.throttleHelper, ms, pattern, worker].concat(args));
}
var delay =
/*#__PURE__*/
exports.delay = call.bind(null, _utils.delay);

var createAsEffectType = function createAsEffectType(type) {
  return function (effect) {
    return effect && effect[_symbols.IO] && effect[type];
  };
};

var asEffect = exports.asEffect = {
  take:
  /*#__PURE__*/
  createAsEffectType(TAKE),
  put:
  /*#__PURE__*/
  createAsEffectType(PUT),
  all:
  /*#__PURE__*/
  createAsEffectType(ALL),
  race:
  /*#__PURE__*/
  createAsEffectType(RACE),
  call:
  /*#__PURE__*/
  createAsEffectType(CALL),
  cps:
  /*#__PURE__*/
  createAsEffectType(CPS),
  fork:
  /*#__PURE__*/
  createAsEffectType(FORK),
  join:
  /*#__PURE__*/
  createAsEffectType(JOIN),
  cancel:
  /*#__PURE__*/
  createAsEffectType(CANCEL),
  select:
  /*#__PURE__*/
  createAsEffectType(SELECT),
  actionChannel:
  /*#__PURE__*/
  createAsEffectType(ACTION_CHANNEL),
  cancelled:
  /*#__PURE__*/
  createAsEffectType(CANCELLED),
  flush:
  /*#__PURE__*/
  createAsEffectType(FLUSH),
  getContext:
  /*#__PURE__*/
  createAsEffectType(GET_CONTEXT),
  setContext:
  /*#__PURE__*/
  createAsEffectType(SET_CONTEXT)
};

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/matcher.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wildcard = exports.symbol = exports.string = exports.predicate = exports.array = undefined;
exports.default = matcher;

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var array = exports.array = function array(patterns) {
  return function (input) {
    return patterns.some(function (p) {
      return matcher(p)(input);
    });
  };
};
var predicate = exports.predicate = function predicate(_predicate) {
  return function (input) {
    return _predicate(input);
  };
};
var string = exports.string = function string(pattern) {
  return function (input) {
    return input.type === String(pattern);
  };
};
var symbol = exports.symbol = function symbol(pattern) {
  return function (input) {
    return input.type === pattern;
  };
};
var wildcard = exports.wildcard = function wildcard() {
  return _utils.kTrue;
};
function matcher(pattern) {
  // prettier-ignore
  var matcherCreator = pattern === '*' ? wildcard : _utils.is.string(pattern) ? string : _utils.is.array(pattern) ? array : _utils.is.stringableFunc(pattern) ? string : _utils.is.func(pattern) ? predicate : _utils.is.symbol(pattern) ? symbol : null;

  if (matcherCreator === null) {
    throw new Error("invalid pattern: " + pattern);
  }

  return matcherCreator(pattern);
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/middleware.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertySymbols = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-own-property-symbols.js");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

exports.default = sagaMiddlewareFactory;

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

var _runSaga = __webpack_require__("../../node_modules/redux-saga/es/internal/runSaga.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = (0, _keys2.default)(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }if (_getOwnPropertySymbols2.default) {
    var sourceSymbolKeys = (0, _getOwnPropertySymbols2.default)(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
    }
  }return target;
}

function sagaMiddlewareFactory(_ref) {
  if (_ref === void 0) {
    _ref = {};
  }

  var _ref2 = _ref,
      _ref2$context = _ref2.context,
      context = _ref2$context === void 0 ? {} : _ref2$context,
      options = _objectWithoutProperties(_ref2, ["context"]);

  var sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      onError = options.onError,
      effectMiddlewares = options.effectMiddlewares;

  if (true) {
    if (_utils.is.notUndef(logger)) {
      (0, _utils.check)(logger, _utils.is.func, 'options.logger passed to the Saga middleware is not a function!');
    }

    if (_utils.is.notUndef(onError)) {
      (0, _utils.check)(onError, _utils.is.func, 'options.onError passed to the Saga middleware is not a function!');
    }

    if (_utils.is.notUndef(options.emitter)) {
      (0, _utils.check)(options.emitter, _utils.is.func, 'options.emitter passed to the Saga middleware is not a function!');
    }
  }

  function sagaMiddleware(_ref3) {
    var getState = _ref3.getState,
        dispatch = _ref3.dispatch;
    var channel = (0, _channel.stdChannel)();
    channel.put = (options.emitter || _utils.identity)(channel.put);
    sagaMiddleware.run = _runSaga.runSaga.bind(null, {
      context: context,
      channel: channel,
      dispatch: dispatch,
      getState: getState,
      sagaMonitor: sagaMonitor,
      logger: logger,
      onError: onError,
      effectMiddlewares: effectMiddlewares
    });
    return function (next) {
      return function (action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }

        var result = next(action); // hit reducers

        channel.put(action);
        return result;
      };
    };
  }

  sagaMiddleware.run = function () {
    throw new Error('Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware');
  };

  sagaMiddleware.setContext = function (props) {
    if (true) {
      (0, _utils.check)(props, _utils.is.object, (0, _utils.createSetContextWarning)('sagaMiddleware', props));
    }

    _utils.object.assign(context, props);
  };

  return sagaMiddleware;
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/proc.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TASK_CANCEL = exports.CHANNEL_END = undefined;

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _create = __webpack_require__("../../node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

exports.getMetaInfo = getMetaInfo;
exports.default = proc;

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var _errorUtils = __webpack_require__("../../node_modules/redux-saga/es/internal/error-utils.js");

var _scheduler = __webpack_require__("../../node_modules/redux-saga/es/internal/scheduler.js");

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

var _matcher = __webpack_require__("../../node_modules/redux-saga/es/internal/matcher.js");

var _matcher2 = _interopRequireDefault(_matcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = _assign2.default || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

function getMetaInfo(fn) {
  return {
    name: fn.name || 'anonymous',
    location: (0, _errorUtils.getLocation)(fn)
  };
}

function getIteratorMetaInfo(iterator, fn) {
  if (iterator.isSagaIterator) {
    return {
      name: iterator.meta.name
    };
  }

  return getMetaInfo(fn);
} // TODO: check if this hacky toString stuff is needed
// also check again whats the difference between CHANNEL_END and CHANNEL_END_TYPE
// maybe this could become MAYBE_END
// I guess this gets exported so takeMaybe result can be checked


var CHANNEL_END = exports.CHANNEL_END = {
  toString: function toString() {
    return _symbols.CHANNEL_END;
  }
};
var TASK_CANCEL = exports.TASK_CANCEL = {
  toString: function toString() {
    return _symbols.TASK_CANCEL;
  }
};
/**
  Used to track a parent task and its forks
  In the new fork model, forked tasks are attached by default to their parent
  We model this using the concept of Parent task && main Task
  main task is the main flow of the current Generator, the parent tasks is the
  aggregation of the main tasks + all its forked tasks.
  Thus the whole model represents an execution tree with multiple branches (vs the
  linear execution tree in sequential (non parallel) programming)

  A parent tasks has the following semantics
  - It completes if all its forks either complete or all cancelled
  - If it's cancelled, all forks are cancelled as well
  - It aborts if any uncaught error bubbles up from forks
  - If it completes, the return value is the one returned by the main task
**/

function forkQueue(mainTask, onAbort, cb) {
  var tasks = [],
      result,
      completed = false;
  addTask(mainTask);

  var getTasks = function getTasks() {
    return tasks;
  };

  var getTaskNames = function getTaskNames() {
    return tasks.map(function (t) {
      return t.meta.name;
    });
  };

  function abort(err) {
    onAbort();
    cancelAll();
    cb(err, true);
  }

  function addTask(task) {
    tasks.push(task);

    task.cont = function (res, isErr) {
      if (completed) {
        return;
      }

      (0, _utils.remove)(tasks, task);
      task.cont = _utils.noop;

      if (isErr) {
        abort(res);
      } else {
        if (task === mainTask) {
          result = res;
        }

        if (!tasks.length) {
          completed = true;
          cb(result);
        }
      }
    }; // task.cont.cancel = task.cancel
  }

  function cancelAll() {
    if (completed) {
      return;
    }

    completed = true;
    tasks.forEach(function (t) {
      t.cont = _utils.noop;
      t.cancel();
    });
    tasks = [];
  }

  return {
    addTask: addTask,
    cancelAll: cancelAll,
    abort: abort,
    getTasks: getTasks,
    getTaskNames: getTaskNames
  };
}

function createTaskIterator(_ref) {
  var context = _ref.context,
      fn = _ref.fn,
      args = _ref.args;

  if (_utils.is.iterator(fn)) {
    return fn;
  } // catch synchronous failures; see #152 and #441


  var result, error;

  try {
    result = fn.apply(context, args);
  } catch (err) {
    error = err;
  } // i.e. a generator function returns an iterator


  if (_utils.is.iterator(result)) {
    return result;
  } // do not bubble up synchronous failures for detached forks
  // instead create a failed task. See #152 and #441


  return error ? (0, _utils.makeIterator)(function () {
    throw error;
  }) : (0, _utils.makeIterator)(function () {
    var pc;
    var eff = {
      done: false,
      value: result
    };

    var ret = function ret(value) {
      return {
        done: true,
        value: value
      };
    };

    return function (arg) {
      if (!pc) {
        pc = true;
        return eff;
      } else {
        return ret(arg);
      }
    };
  }());
}

function proc(iterator, stdChannel, dispatch, getState, parentContext, options, parentEffectId, meta, cont) {
  if (dispatch === void 0) {
    dispatch = _utils.noop;
  }

  if (getState === void 0) {
    getState = _utils.noop;
  }

  if (parentContext === void 0) {
    parentContext = {};
  }

  if (options === void 0) {
    options = {};
  }

  if (parentEffectId === void 0) {
    parentEffectId = 0;
  }

  var _options = options,
      sagaMonitor = _options.sagaMonitor,
      logger = _options.logger,
      onError = _options.onError,
      middleware = _options.middleware;
  var log = logger || _utils.log;

  var logError = function logError(err) {
    log('error', err);

    if (err.sagaStack) {
      log('error', err.sagaStack);
    }
  };

  var taskContext = (0, _create2.default)(parentContext);
  var crashedEffect = null;
  var cancelledDueToErrorTasks = [];
  /**
    Tracks the current effect cancellation
    Each time the generator progresses. calling runEffect will set a new value
    on it. It allows propagating cancellation to child effects
  **/

  next.cancel = _utils.noop;
  /**
    Creates a new task descriptor for this generator, We'll also create a main task
    to track the main flow (besides other forked tasks)
  **/

  var task = newTask(parentEffectId, meta, iterator, cont);
  var mainTask = {
    meta: meta,
    cancel: cancelMain,
    isRunning: true
  };
  var taskQueue = forkQueue(mainTask, function onAbort() {
    cancelledDueToErrorTasks.push.apply(cancelledDueToErrorTasks, taskQueue.getTaskNames());
  }, end);
  /**
    cancellation of the main task. We'll simply resume the Generator with a Cancel
  **/

  function cancelMain() {
    if (mainTask.isRunning && !mainTask.isCancelled) {
      mainTask.isCancelled = true;
      next(TASK_CANCEL);
    }
  }
  /**
    This may be called by a parent generator to trigger/propagate cancellation
    cancel all pending tasks (including the main task), then end the current task.
     Cancellation propagates down to the whole execution tree holded by this Parent task
    It's also propagated to all joiners of this task and their execution tree/joiners
     Cancellation is noop for terminated/Cancelled tasks tasks
  **/

  function cancel() {
    /**
      We need to check both Running and Cancelled status
      Tasks can be Cancelled but still Running
    **/
    if (iterator._isRunning && !iterator._isCancelled) {
      iterator._isCancelled = true;
      taskQueue.cancelAll();
      /**
        Ending with a Never result will propagate the Cancellation to all joiners
      **/

      end(TASK_CANCEL);
    }
  }
  /**
    attaches cancellation logic to this task's continuation
    this will permit cancellation to propagate down the call chain
  **/

  cont && (cont.cancel = cancel); // tracks the running status

  iterator._isRunning = true; // kicks up the generator

  next(); // then return the task descriptor to the caller

  return task;
  /**
    This is the generator driver
    It's a recursive async/continuation function which calls itself
    until the generator terminates or throws
  **/

  function next(arg, isErr) {
    // Preventive measure. If we end up here, then there is really something wrong
    if (!mainTask.isRunning) {
      throw new Error('Trying to resume an already finished generator');
    }

    try {
      var result;

      if (isErr) {
        result = iterator.throw(arg);
      } else if (arg === TASK_CANCEL) {
        /**
          getting TASK_CANCEL automatically cancels the main task
          We can get this value here
           - By cancelling the parent task manually
          - By joining a Cancelled task
        **/
        mainTask.isCancelled = true;
        /**
          Cancels the current effect; this will propagate the cancellation down to any called tasks
        **/

        next.cancel();
        /**
          If this Generator has a `return` method then invokes it
          This will jump to the finally block
        **/

        result = _utils.is.func(iterator.return) ? iterator.return(TASK_CANCEL) : {
          done: true,
          value: TASK_CANCEL
        };
      } else if (arg === CHANNEL_END) {
        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)
        result = _utils.is.func(iterator.return) ? iterator.return() : {
          done: true
        };
      } else {
        result = iterator.next(arg);
      }

      if (!result.done) {
        digestEffect(result.value, parentEffectId, '', next);
      } else {
        /**
          This Generator has ended, terminate the main task and notify the fork queue
        **/
        mainTask.isMainRunning = false;
        mainTask.cont && mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.isCancelled) {
        logError(error);
      }

      mainTask.isMainRunning = false;
      mainTask.cont(error, true);
    }
  }

  function end(result, isErr) {
    iterator._isRunning = false; // stdChannel.close()

    if (!isErr) {
      iterator._result = result;
      iterator._deferredEnd && iterator._deferredEnd.resolve(result);
    } else {
      (0, _errorUtils.addSagaStack)(result, {
        meta: meta,
        effect: crashedEffect,
        cancelledTasks: cancelledDueToErrorTasks
      });

      if (!task.cont) {
        if (result.sagaStack) {
          result.sagaStack = (0, _errorUtils.sagaStackToString)(result.sagaStack);
        }

        if (result instanceof Error && onError) {
          onError(result);
        } else {
          // TODO: could we skip this when _deferredEnd is attached?
          logError(result);
        }
      }

      iterator._error = result;
      iterator._isAborted = true;
      iterator._deferredEnd && iterator._deferredEnd.reject(result);
    }

    task.cont && task.cont(result, isErr);
    task.joiners.forEach(function (j) {
      return j.cb(result, isErr);
    });
    task.joiners = null;
  }

  function runEffect(effect, effectId, currCb) {
    /**
      each effect runner must attach its own logic of cancellation to the provided callback
      it allows this generator to propagate cancellation downward.
       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]
      And the setup must occur before calling the callback
       This is a sort of inversion of control: called async functions are responsible
      of completing the flow by calling the provided continuation; while caller functions
      are responsible for aborting the current flow by calling the attached cancel function
       Library users can attach their own cancellation logic to promises by defining a
      promise[CANCEL] method in their returned promises
      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect
    **/
    var data; // prettier-ignore

    return (// Non declarative effect
      _utils.is.promise(effect) ? resolvePromise(effect, currCb) : _utils.is.iterator(effect) ? resolveIterator(effect, effectId, meta, currCb) // declarative effects
      : (data = _io.asEffect.take(effect)) ? runTakeEffect(data, currCb) : (data = _io.asEffect.put(effect)) ? runPutEffect(data, currCb) : (data = _io.asEffect.all(effect)) ? runAllEffect(data, effectId, currCb) : (data = _io.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : (data = _io.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : (data = _io.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : (data = _io.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : (data = _io.asEffect.join(effect)) ? runJoinEffect(data, currCb) : (data = _io.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : (data = _io.asEffect.select(effect)) ? runSelectEffect(data, currCb) : (data = _io.asEffect.actionChannel(effect)) ? runChannelEffect(data, currCb) : (data = _io.asEffect.flush(effect)) ? runFlushEffect(data, currCb) : (data = _io.asEffect.cancelled(effect)) ? runCancelledEffect(data, currCb) : (data = _io.asEffect.getContext(effect)) ? runGetContextEffect(data, currCb) : (data = _io.asEffect.setContext(effect)) ? runSetContextEffect(data, currCb) :
      /* anything else returned as is */
      currCb(effect)
    );
  }

  function digestEffect(effect, parentEffectId, label, cb) {
    if (label === void 0) {
      label = '';
    }

    var effectId = (0, _utils.uid)();
    sagaMonitor && sagaMonitor.effectTriggered({
      effectId: effectId,
      parentEffectId: parentEffectId,
      label: label,
      effect: effect
    });
    /**
      completion callback and cancel callback are mutually exclusive
      We can't cancel an already completed effect
      And We can't complete an already cancelled effectId
    **/

    var effectSettled; // Completion callback passed to the appropriate effect runner

    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      cb.cancel = _utils.noop; // defensive measure

      if (sagaMonitor) {
        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);
      }

      if (isErr) {
        crashedEffect = effect;
      }

      cb(res, isErr);
    } // tracks down the current cancel


    currCb.cancel = _utils.noop; // setup cancellation logic on the parent cb

    cb.cancel = function () {
      // prevents cancelling an already completed effect
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      /**
        propagates cancel downward
        catch uncaught cancellations errors; since we can no longer call the completion
        callback, log errors raised during cancellations into the console
      **/

      try {
        currCb.cancel();
      } catch (err) {
        logError(err);
      }

      currCb.cancel = _utils.noop; // defensive measure

      sagaMonitor && sagaMonitor.effectCancelled(effectId);
    }; // if one can find a way to decouple runEffect from closure variables
    // so it could be the call to it could be referentially transparent
    // this potentially could be simplified, finalRunEffect created beforehand
    // and this part of the code wouldnt have to know about middleware stuff


    if (_utils.is.func(middleware)) {
      middleware(function (eff) {
        return runEffect(eff, effectId, currCb);
      })(effect);
      return;
    }

    runEffect(effect, effectId, currCb);
  }

  function resolvePromise(promise, cb) {
    var cancelPromise = promise[_symbols.CANCEL];

    if (_utils.is.func(cancelPromise)) {
      cb.cancel = cancelPromise;
    } else if (_utils.is.func(promise.abort)) {
      cb.cancel = function () {
        return promise.abort();
      };
    }

    promise.then(cb, function (error) {
      return cb(error, true);
    });
  }

  function resolveIterator(iterator, effectId, meta, cb) {
    proc(iterator, stdChannel, dispatch, getState, taskContext, options, effectId, meta, cb);
  }

  function runTakeEffect(_ref2, cb) {
    var _ref2$channel = _ref2.channel,
        channel = _ref2$channel === void 0 ? stdChannel : _ref2$channel,
        pattern = _ref2.pattern,
        maybe = _ref2.maybe;

    var takeCb = function takeCb(input) {
      if (input instanceof Error) {
        cb(input, true);
        return;
      }

      if ((0, _channel.isEnd)(input) && !maybe) {
        cb(CHANNEL_END);
        return;
      }

      cb(input);
    };

    try {
      channel.take(takeCb, _utils.is.notUndef(pattern) ? (0, _matcher2.default)(pattern) : null);
    } catch (err) {
      cb(err, true);
      return;
    }

    cb.cancel = takeCb.cancel;
  }

  function runPutEffect(_ref3, cb) {
    var channel = _ref3.channel,
        action = _ref3.action,
        resolve = _ref3.resolve;

    /**
      Schedule the put in case another saga is holding a lock.
      The put will be executed atomically. ie nested puts will execute after
      this put has terminated.
    **/
    (0, _scheduler.asap)(function () {
      var result;

      try {
        result = (channel ? channel.put : dispatch)(action);
      } catch (error) {
        cb(error, true);
        return;
      }

      if (resolve && _utils.is.promise(result)) {
        resolvePromise(result, cb);
      } else {
        cb(result);
        return;
      }
    }); // Put effects are non cancellables
  }

  function runCallEffect(_ref4, effectId, cb) {
    var context = _ref4.context,
        fn = _ref4.fn,
        args = _ref4.args;
    var result; // catch synchronous failures; see #152

    try {
      result = fn.apply(context, args);
    } catch (error) {
      cb(error, true);
      return;
    }

    return _utils.is.promise(result) ? resolvePromise(result, cb) : _utils.is.iterator(result) ? resolveIterator(result, effectId, getMetaInfo(fn), cb) : cb(result);
  }

  function runCPSEffect(_ref5, cb) {
    var context = _ref5.context,
        fn = _ref5.fn,
        args = _ref5.args;

    // CPS (ie node style functions) can define their own cancellation logic
    // by setting cancel field on the cb
    // catch synchronous failures; see #152
    try {
      var cpsCb = function cpsCb(err, res) {
        return _utils.is.undef(err) ? cb(res) : cb(err, true);
      };

      fn.apply(context, args.concat(cpsCb));

      if (cpsCb.cancel) {
        cb.cancel = function () {
          return cpsCb.cancel();
        };
      }
    } catch (error) {
      cb(error, true);
      return;
    }
  }

  function runForkEffect(_ref6, effectId, cb) {
    var context = _ref6.context,
        fn = _ref6.fn,
        args = _ref6.args,
        detached = _ref6.detached;
    var taskIterator = createTaskIterator({
      context: context,
      fn: fn,
      args: args
    });
    var meta = getIteratorMetaInfo(taskIterator, fn);

    try {
      (0, _scheduler.suspend)();

      var _task = proc(taskIterator, stdChannel, dispatch, getState, taskContext, options, effectId, meta, detached ? null : _utils.noop);

      if (detached) {
        cb(_task);
      } else {
        if (taskIterator._isRunning) {
          taskQueue.addTask(_task);
          cb(_task);
        } else if (taskIterator._error) {
          taskQueue.abort(taskIterator._error);
        } else {
          cb(_task);
        }
      }
    } finally {
      (0, _scheduler.flush)();
    } // Fork effects are non cancellables
  }

  function runJoinEffect(t, cb) {
    if (t.isRunning()) {
      var joiner = {
        task: task,
        cb: cb
      };

      cb.cancel = function () {
        return (0, _utils.remove)(t.joiners, joiner);
      };

      t.joiners.push(joiner);
    } else {
      t.isAborted() ? cb(t.error(), true) : cb(t.result());
    }
  }

  function runCancelEffect(taskToCancel, cb) {
    if (taskToCancel === _symbols.SELF_CANCELLATION) {
      taskToCancel = task;
    }

    if (taskToCancel.isRunning()) {
      taskToCancel.cancel();
    }

    cb(); // cancel effects are non cancellables
  }

  function runAllEffect(effects, effectId, cb) {
    var keys = (0, _keys2.default)(effects);

    if (!keys.length) {
      cb(_utils.is.array(effects) ? [] : {});
      return;
    }

    var completedCount = 0;
    var completed;
    var results = {};
    var childCbs = {};

    function checkEffectEnd() {
      if (completedCount === keys.length) {
        completed = true;
        cb(_utils.is.array(effects) ? _utils.array.from(_extends({}, results, {
          length: keys.length
        })) : results);
      }
    }

    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }

        if (isErr || (0, _channel.isEnd)(res) || res === CHANNEL_END || res === TASK_CANCEL) {
          cb.cancel();
          cb(res, isErr);
        } else {
          results[key] = res;
          completedCount++;
          checkEffectEnd();
        }
      };

      chCbAtKey.cancel = _utils.noop;
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };

    keys.forEach(function (key) {
      return digestEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runRaceEffect(effects, effectId, cb) {
    var completed;
    var keys = (0, _keys2.default)(effects);
    var childCbs = {};
    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }

        if (isErr) {
          // Race Auto cancellation
          cb.cancel();
          cb(res, true);
        } else if (!(0, _channel.isEnd)(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {
          var _response;

          cb.cancel();
          completed = true;
          var response = (_response = {}, _response[key] = res, _response);
          cb(_utils.is.array(effects) ? [].slice.call(_extends({}, response, {
            length: keys.length
          })) : response);
        }
      };

      chCbAtKey.cancel = _utils.noop;
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      // prevents unnecessary cancellation
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };

    keys.forEach(function (key) {
      if (completed) {
        return;
      }

      digestEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runSelectEffect(_ref7, cb) {
    var selector = _ref7.selector,
        args = _ref7.args;

    try {
      var state = selector.apply(void 0, [getState()].concat(args));
      cb(state);
    } catch (error) {
      cb(error, true);
    }
  }

  function runChannelEffect(_ref8, cb) {
    var pattern = _ref8.pattern,
        buffer = _ref8.buffer;
    // TODO: rethink how END is handled
    var chan = (0, _channel.channel)(buffer);
    var match = (0, _matcher2.default)(pattern);

    var taker = function taker(action) {
      if (!(0, _channel.isEnd)(action)) {
        stdChannel.take(taker, match);
      }

      chan.put(action);
    };

    stdChannel.take(taker, match);
    cb(chan);
  }

  function runCancelledEffect(data, cb) {
    cb(!!mainTask.isCancelled);
  }

  function runFlushEffect(channel, cb) {
    channel.flush(cb);
  }

  function runGetContextEffect(prop, cb) {
    cb(taskContext[prop]);
  }

  function runSetContextEffect(props, cb) {
    _utils.object.assign(taskContext, props);
    cb();
  }

  function newTask(id, meta, iterator, cont) {
    var _ref9;

    iterator._deferredEnd = null;
    return _ref9 = {}, _ref9[_symbols.TASK] = true, _ref9.id = id, _ref9.meta = meta, _ref9.toPromise = function toPromise() {
      if (iterator._deferredEnd) {
        return iterator._deferredEnd.promise;
      }

      var def = (0, _utils.deferred)();
      iterator._deferredEnd = def;

      if (!iterator._isRunning) {
        if (iterator._isAborted) {
          def.reject(iterator._error);
        } else {
          def.resolve(iterator._result);
        }
      }

      return def.promise;
    }, _ref9.cont = cont, _ref9.joiners = [], _ref9.cancel = cancel, _ref9.isRunning = function isRunning() {
      return iterator._isRunning;
    }, _ref9.isCancelled = function isCancelled() {
      return iterator._isCancelled;
    }, _ref9.isAborted = function isAborted() {
      return iterator._isAborted;
    }, _ref9.result = function result() {
      return iterator._result;
    }, _ref9.error = function error() {
      return iterator._error;
    }, _ref9.setContext = function setContext(props) {
      if (true) {
        (0, _utils.check)(props, _utils.is.object, (0, _utils.createSetContextWarning)('task', props));
      }

      _utils.object.assign(taskContext, props);
    }, _ref9;
  }
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/runSaga.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runSaga = runSaga;

var _redux = __webpack_require__("../../node_modules/redux-saga/node_modules/redux/es/redux.js");

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var _proc = __webpack_require__("../../node_modules/redux-saga/es/internal/proc.js");

var _proc2 = _interopRequireDefault(_proc);

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RUN_SAGA_SIGNATURE = 'runSaga(options, saga, ...args)';
var NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ": saga argument must be a Generator function!";
function runSaga(options, saga) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (true) {
    (0, _utils.check)(saga, _utils.is.func, NON_GENERATOR_ERR);
  }

  var iterator = saga.apply(void 0, args);

  if (true) {
    (0, _utils.check)(iterator, _utils.is.iterator, NON_GENERATOR_ERR);
  }

  var _options$channel = options.channel,
      channel = _options$channel === void 0 ? (0, _channel.stdChannel)() : _options$channel,
      dispatch = options.dispatch,
      getState = options.getState,
      context = options.context,
      sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      effectMiddlewares = options.effectMiddlewares,
      onError = options.onError;
  var effectId = (0, _utils.uid)();

  if (sagaMonitor) {
    // monitors are expected to have a certain interface, let's fill-in any missing ones
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || _utils.noop;
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || _utils.noop;
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || _utils.noop;
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || _utils.noop;
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || _utils.noop;
    sagaMonitor.effectTriggered({
      effectId: effectId,
      root: true,
      parentEffectId: 0,
      effect: {
        root: true,
        saga: saga,
        args: args
      }
    });
  }

  if ((true) && _utils.is.notUndef(effectMiddlewares)) {
    var MIDDLEWARE_TYPE_ERROR = 'effectMiddlewares must be an array of functions';
    (0, _utils.check)(effectMiddlewares, _utils.is.array, MIDDLEWARE_TYPE_ERROR);
    effectMiddlewares.forEach(function (effectMiddleware) {
      return (0, _utils.check)(effectMiddleware, _utils.is.func, MIDDLEWARE_TYPE_ERROR);
    });
  }

  var middleware = effectMiddlewares && _redux.compose.apply(void 0, effectMiddlewares);
  var task = (0, _proc2.default)(iterator, channel, (0, _utils.wrapSagaDispatch)(dispatch), getState, context, {
    sagaMonitor: sagaMonitor,
    logger: logger,
    onError: onError,
    middleware: middleware
  }, effectId, (0, _proc.getMetaInfo)(saga));

  if (sagaMonitor) {
    sagaMonitor.effectResolved(effectId, task);
  }

  return task;
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.qEnd = undefined;
exports.safeName = safeName;
exports.default = fsmIterator;

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

var done = {
  done: true,
  value: undefined
};
var qEnd = exports.qEnd = {};
function safeName(patternOrChannel) {
  if (_utils.is.channel(patternOrChannel)) {
    return 'channel';
  }

  if (_utils.is.stringableFunc(patternOrChannel)) {
    return String(patternOrChannel);
  }

  if (_utils.is.func(patternOrChannel)) {
    return patternOrChannel.name;
  }

  return String(patternOrChannel);
}
function fsmIterator(fsm, q0, name) {
  var updateState,
      qNext = q0;

  function next(arg, error) {
    if (qNext === qEnd) {
      return done;
    }

    if (error) {
      qNext = qEnd;
      throw error;
    } else {
      updateState && updateState(arg);

      var _fsm$qNext = fsm[qNext](),
          q = _fsm$qNext[0],
          output = _fsm$qNext[1],
          _updateState = _fsm$qNext[2];

      qNext = q;
      updateState = _updateState;
      return qNext === qEnd ? done : output;
    }
  }

  return (0, _utils.makeIterator)(next, function (error) {
    return next(null, error);
  }, name);
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throttleHelper = exports.takeLeadingHelper = exports.takeLatestHelper = exports.takeEveryHelper = undefined;

var _takeEvery = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/takeEvery.js");

var _takeEvery2 = _interopRequireDefault(_takeEvery);

var _takeLatest = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/takeLatest.js");

var _takeLatest2 = _interopRequireDefault(_takeLatest);

var _takeLeading = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/takeLeading.js");

var _takeLeading2 = _interopRequireDefault(_takeLeading);

var _throttle = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/throttle.js");

var _throttle2 = _interopRequireDefault(_throttle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.takeEveryHelper = _takeEvery2.default;
exports.takeLatestHelper = _takeLatest2.default;
exports.takeLeadingHelper = _takeLeading2.default;
exports.throttleHelper = _throttle2.default;

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/takeEvery.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = takeEvery;

var _fsmIterator = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");

var _fsmIterator2 = _interopRequireDefault(_fsmIterator);

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function takeEvery(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = {
    done: false,
    value: (0, _io.take)(patternOrChannel)
  };

  var yFork = function yFork(ac) {
    return {
      done: false,
      value: _io.fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };

  var action,
      setAction = function setAction(ac) {
    return action = ac;
  };

  return (0, _fsmIterator2.default)({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === _channel.END ? [_fsmIterator.qEnd] : ['q1', yFork(action)];
    }
  }, 'q1', "takeEvery(" + (0, _fsmIterator.safeName)(patternOrChannel) + ", " + worker.name + ")");
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/takeLatest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = takeLatest;

var _fsmIterator = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");

var _fsmIterator2 = _interopRequireDefault(_fsmIterator);

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function takeLatest(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = {
    done: false,
    value: (0, _io.take)(patternOrChannel)
  };

  var yFork = function yFork(ac) {
    return {
      done: false,
      value: _io.fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };

  var yCancel = function yCancel(task) {
    return {
      done: false,
      value: (0, _io.cancel)(task)
    };
  };

  var task, action;

  var setTask = function setTask(t) {
    return task = t;
  };

  var setAction = function setAction(ac) {
    return action = ac;
  };

  return (0, _fsmIterator2.default)({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === _channel.END ? [_fsmIterator.qEnd] : task ? ['q3', yCancel(task)] : ['q1', yFork(action), setTask];
    },
    q3: function q3() {
      return ['q1', yFork(action), setTask];
    }
  }, 'q1', "takeLatest(" + (0, _fsmIterator.safeName)(patternOrChannel) + ", " + worker.name + ")");
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/takeLeading.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = takeLeading;

var _fsmIterator = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");

var _fsmIterator2 = _interopRequireDefault(_fsmIterator);

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function takeLeading(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = {
    done: false,
    value: (0, _io.take)(patternOrChannel)
  };

  var yCall = function yCall(ac) {
    return {
      done: false,
      value: _io.call.apply(void 0, [worker].concat(args, [ac]))
    };
  };

  var action;

  var setAction = function setAction(ac) {
    return action = ac;
  };

  return (0, _fsmIterator2.default)({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === _channel.END ? [_fsmIterator.qEnd] : ['q1', yCall(action)];
    }
  }, 'q1', "takeLeading(" + (0, _fsmIterator.safeName)(patternOrChannel) + ", " + worker.name + ")");
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/sagaHelpers/throttle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = throttle;

var _fsmIterator = __webpack_require__("../../node_modules/redux-saga/es/internal/sagaHelpers/fsmIterator.js");

var _fsmIterator2 = _interopRequireDefault(_fsmIterator);

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

var _channel = __webpack_require__("../../node_modules/redux-saga/es/internal/channel.js");

var _buffers = __webpack_require__("../../node_modules/redux-saga/es/internal/buffers.js");

var buffers = _interopRequireWildcard(_buffers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function throttle(delayLength, pattern, worker) {
  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var action, channel;
  var yActionChannel = {
    done: false,
    value: (0, _io.actionChannel)(pattern, buffers.sliding(1))
  };

  var yTake = function yTake() {
    return {
      done: false,
      value: (0, _io.take)(channel)
    };
  };

  var yFork = function yFork(ac) {
    return {
      done: false,
      value: _io.fork.apply(void 0, [worker].concat(args, [ac]))
    };
  };

  var yDelay = {
    done: false,
    value: (0, _io.delay)(delayLength)
  };

  var setAction = function setAction(ac) {
    return action = ac;
  };

  var setChannel = function setChannel(ch) {
    return channel = ch;
  };

  return (0, _fsmIterator2.default)({
    q1: function q1() {
      return ['q2', yActionChannel, setChannel];
    },
    q2: function q2() {
      return ['q3', yTake(), setAction];
    },
    q3: function q3() {
      return action === _channel.END ? [_fsmIterator.qEnd] : ['q4', yFork(action)];
    },
    q4: function q4() {
      return ['q2', yDelay];
    }
  }, 'q1', "throttle(" + (0, _fsmIterator.safeName)(pattern) + ", " + worker.name + ")");
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/scheduler.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asap = asap;
exports.suspend = suspend;
exports.flush = flush;
var queue = [];
/**
  Variable to hold a counting semaphore
  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not
    already suspended)
  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This
    triggers flushing the queued tasks.
**/

var semaphore = 0;
/**
  Executes a task 'atomically'. Tasks scheduled during this execution will be queued
  and flushed after this task has finished (assuming the scheduler endup in a released
  state).
**/

function exec(task) {
  try {
    suspend();
    task();
  } finally {
    release();
  }
}
/**
  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)
**/

function asap(task) {
  queue.push(task);

  if (!semaphore) {
    suspend();
    flush();
  }
}
/**
  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the
  scheduler is released.
**/

function suspend() {
  semaphore++;
}
/**
  Puts the scheduler in a `released` state.
**/

function release() {
  semaphore--;
}
/**
  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.
**/

function flush() {
  release();
  var task;

  while (!semaphore && (task = queue.shift()) !== undefined) {
    exec(task);
  }
}

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/symbols.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SAGA_LOCATION = exports.TASK_CANCEL = exports.TASK = exports.SELF_CANCELLATION = exports.SAGA_ACTION = exports.MULTICAST = exports.MATCH = exports.IO = exports.CHANNEL_END_TYPE = exports.CHANNEL_END = exports.CANCEL = undefined;

var _for = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol/for.js");

var _for2 = _interopRequireDefault(_for);

var _symbol = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createName = function createName(name) {
  return "@@redux-saga/" + name;
};

var createSymbol = function createSymbol(id) {
  id = createName(id);
  return typeof _symbol2.default === 'function' ? (0, _symbol2.default)(id) : id;
};

var createGlobalSymbol = function createGlobalSymbol(id) {
  id = createName(id);
  return typeof _symbol2.default === 'function' && typeof _for2.default === 'function' ? (0, _for2.default)(id) : id;
};

var CANCEL =
/*#__PURE__*/
exports.CANCEL = createSymbol('CANCEL_PROMISE');
var CHANNEL_END =
/*#__PURE__*/
exports.CHANNEL_END = createSymbol('CHANNEL_END');
var CHANNEL_END_TYPE =
/*#__PURE__*/
exports.CHANNEL_END_TYPE = createSymbol('CHANNEL_END');
var IO =
/*#__PURE__*/
exports.IO = createSymbol('IO');
var MATCH =
/*#__PURE__*/
exports.MATCH = createSymbol('MATCH');
var MULTICAST =
/*#__PURE__*/
exports.MULTICAST = createSymbol('MULTICAST');
var SAGA_ACTION =
/*#__PURE__*/
exports.SAGA_ACTION = createSymbol('SAGA_ACTION');
var SELF_CANCELLATION =
/*#__PURE__*/
exports.SELF_CANCELLATION = createSymbol('SELF_CANCELLATION');
var TASK =
/*#__PURE__*/
exports.TASK = createSymbol('TASK');
var TASK_CANCEL =
/*#__PURE__*/
exports.TASK_CANCEL = createSymbol('TASK_CANCEL');
var SAGA_LOCATION =
/*#__PURE__*/
exports.SAGA_LOCATION = createGlobalSymbol('LOCATION');

/***/ }),

/***/ "../../node_modules/redux-saga/es/internal/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneableGenerator = exports.wrapSagaDispatch = exports.createSetContextWarning = exports.internalErr = exports.updateIncentive = exports.uid = exports.array = exports.object = exports.is = exports.identity = exports.noop = exports.kFalse = exports.kTrue = exports.konst = undefined;

var _defineProperty = __webpack_require__("../../node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _iterator = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__("../../node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

exports.check = check;
exports.hasOwn = hasOwn;
exports.remove = remove;
exports.once = once;
exports.deferred = deferred;
exports.arrayOfDeferred = arrayOfDeferred;
exports.delay = delay;
exports.createMockTask = createMockTask;
exports.autoInc = autoInc;
exports.makeIterator = makeIterator;
exports.log = log;
exports.deprecate = deprecate;

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = _assign2.default || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var konst = exports.konst = function konst(v) {
  return function () {
    return v;
  };
};
var kTrue =
/*#__PURE__*/
exports.kTrue = konst(true);
var kFalse =
/*#__PURE__*/
exports.kFalse = konst(false);
var noop = exports.noop = function noop() {};
var identity = exports.identity = function identity(v) {
  return v;
};
function check(value, predicate, error) {
  if (!predicate(value)) {
    throw new Error(error);
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(object, property) {
  return is.notUndef(object) && hasOwnProperty.call(object, property);
}
var is = exports.is = {
  undef: function undef(v) {
    return v === null || v === undefined;
  },
  notUndef: function notUndef(v) {
    return v !== null && v !== undefined;
  },
  func: function func(f) {
    return typeof f === 'function';
  },
  number: function number(n) {
    return typeof n === 'number';
  },
  string: function string(s) {
    return typeof s === 'string';
  },
  array: Array.isArray,
  object: function object(obj) {
    return obj && !is.array(obj) && typeof obj === 'object';
  },
  promise: function promise(p) {
    return p && is.func(p.then);
  },
  iterator: function iterator(it) {
    return it && is.func(it.next) && is.func(it.throw);
  },
  iterable: function iterable(it) {
    return it && is.func(_symbol2.default) ? is.func(it[_iterator2.default]) : is.array(it);
  },
  task: function task(t) {
    return t && t[_symbols.TASK];
  },
  observable: function observable(ob) {
    return ob && is.func(ob.subscribe);
  },
  buffer: function buffer(buf) {
    return buf && is.func(buf.isEmpty) && is.func(buf.take) && is.func(buf.put);
  },
  pattern: function pattern(pat) {
    return pat && (is.string(pat) || is.symbol(pat) || is.func(pat) || is.array(pat));
  },
  channel: function channel(ch) {
    return ch && is.func(ch.take) && is.func(ch.close);
  },
  stringableFunc: function stringableFunc(f) {
    return is.func(f) && hasOwn(f, 'toString');
  },
  symbol: function symbol(sym) {
    return Boolean(sym) && typeof _symbol2.default === 'function' && sym.constructor === _symbol2.default && sym !== _symbol2.default.prototype;
  },
  multicast: function multicast(ch) {
    return is.channel(ch) && ch[_symbols.MULTICAST];
  }
};
var object = exports.object = {
  assign: function assign(target, source) {
    for (var i in source) {
      if (hasOwn(source, i)) {
        target[i] = source[i];
      }
    }
  }
};
function remove(array, item) {
  var index = array.indexOf(item);

  if (index >= 0) {
    array.splice(index, 1);
  }
}
var array = exports.array = {
  from: function from(obj) {
    var arr = Array(obj.length);

    for (var i in obj) {
      if (hasOwn(obj, i)) {
        arr[i] = obj[i];
      }
    }

    return arr;
  }
};
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    fn();
  };
}
function deferred(props) {
  if (props === void 0) {
    props = {};
  }

  var def = _extends({}, props);

  var promise = new _promise2.default(function (resolve, reject) {
    def.resolve = resolve;
    def.reject = reject;
  });
  def.promise = promise;
  return def;
}
function arrayOfDeferred(length) {
  var arr = [];

  for (var i = 0; i < length; i++) {
    arr.push(deferred());
  }

  return arr;
}
function delay(ms, val) {
  if (val === void 0) {
    val = true;
  }

  var timeoutId;
  var promise = new _promise2.default(function (resolve) {
    timeoutId = setTimeout(function () {
      return resolve(val);
    }, ms);
  });

  promise[_symbols.CANCEL] = function () {
    return clearTimeout(timeoutId);
  };

  return promise;
}
function createMockTask() {
  var _ref;

  var running = true;

  var _result, _error;

  return _ref = {}, _ref[_symbols.TASK] = true, _ref.isRunning = function isRunning() {
    return running;
  }, _ref.result = function result() {
    return _result;
  }, _ref.error = function error() {
    return _error;
  }, _ref.setRunning = function setRunning(b) {
    return running = b;
  }, _ref.setResult = function setResult(r) {
    return _result = r;
  }, _ref.setError = function setError(e) {
    return _error = e;
  }, _ref;
}
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }

  return function () {
    return ++seed;
  };
}
var uid =
/*#__PURE__*/
exports.uid = autoInc();

var kThrow = function kThrow(err) {
  throw err;
};

var kReturn = function kReturn(value) {
  return {
    value: value,
    done: true
  };
};

function makeIterator(next, thro, name) {
  if (thro === void 0) {
    thro = kThrow;
  }

  if (name === void 0) {
    name = 'iterator';
  }

  var iterator = {
    meta: {
      name: name
    },
    next: next,
    throw: thro,
    return: kReturn,
    isSagaIterator: true
  };

  if (typeof _symbol2.default !== 'undefined') {
    iterator[_iterator2.default] = function () {
      return iterator;
    };
  }

  return iterator;
}
/**
  Print error in a useful way whether in a browser environment
  (with expandable error stack traces), or in a node.js environment
  (text-only log output)
 **/

function log(level, message, error) {
  if (error === void 0) {
    error = '';
  }

  /*eslint-disable no-console*/
  if (typeof window === 'undefined') {
    console.log("redux-saga " + level + ": " + message + "\n" + (error && error.stack || error));
  } else {
    console[level](message, error);
  }
}
function deprecate(fn, deprecationWarning) {
  return function () {
    if (true) log('warn', deprecationWarning);
    return fn.apply(void 0, arguments);
  };
}
var updateIncentive = exports.updateIncentive = function updateIncentive(deprecated, preferred) {
  return deprecated + " has been deprecated in favor of " + preferred + ", please update your code";
};
var internalErr = exports.internalErr = function internalErr(err) {
  return new Error("\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: " + err + "\n");
};
var createSetContextWarning = exports.createSetContextWarning = function createSetContextWarning(ctx, props) {
  return (ctx ? ctx + '.' : '') + "setContext(props): argument " + props + " is not a plain object";
};
var wrapSagaDispatch = exports.wrapSagaDispatch = function wrapSagaDispatch(dispatch) {
  return function (action) {
    return dispatch((0, _defineProperty2.default)(action, _symbols.SAGA_ACTION, {
      value: true
    }));
  };
};

var cloneableGenerator = function cloneableGenerator(generatorFunc) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var history = [];
    var gen = generatorFunc.apply(void 0, args);
    return {
      next: function next(arg) {
        history.push(arg);
        return gen.next(arg);
      },
      clone: function clone() {
        var clonedGen = cloneableGenerator(generatorFunc).apply(void 0, args);
        history.forEach(function (arg) {
          return clonedGen.next(arg);
        });
        return clonedGen;
      },
      return: function _return(value) {
        return gen.return(value);
      },
      throw: function _throw(exception) {
        return gen.throw(exception);
      }
    };
  };
};

exports.cloneableGenerator = cloneableGenerator;

/***/ }),

/***/ "../../node_modules/redux-saga/es/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__("../../node_modules/redux-saga/es/internal/utils.js");

Object.defineProperty(exports, 'delay', {
  enumerable: true,
  get: function () {
    return _utils.delay;
  }
});
Object.defineProperty(exports, 'noop', {
  enumerable: true,
  get: function () {
    return _utils.noop;
  }
});
Object.defineProperty(exports, 'is', {
  enumerable: true,
  get: function () {
    return _utils.is;
  }
});
Object.defineProperty(exports, 'deferred', {
  enumerable: true,
  get: function () {
    return _utils.deferred;
  }
});
Object.defineProperty(exports, 'arrayOfDeferred', {
  enumerable: true,
  get: function () {
    return _utils.arrayOfDeferred;
  }
});
Object.defineProperty(exports, 'createMockTask', {
  enumerable: true,
  get: function () {
    return _utils.createMockTask;
  }
});
Object.defineProperty(exports, 'cloneableGenerator', {
  enumerable: true,
  get: function () {
    return _utils.cloneableGenerator;
  }
});

var _symbols = __webpack_require__("../../node_modules/redux-saga/es/internal/symbols.js");

Object.defineProperty(exports, 'SAGA_ACTION', {
  enumerable: true,
  get: function () {
    return _symbols.SAGA_ACTION;
  }
});
Object.defineProperty(exports, 'TASK', {
  enumerable: true,
  get: function () {
    return _symbols.TASK;
  }
});

var _io = __webpack_require__("../../node_modules/redux-saga/es/internal/io.js");

Object.defineProperty(exports, 'asEffect', {
  enumerable: true,
  get: function () {
    return _io.asEffect;
  }
});

var _proc = __webpack_require__("../../node_modules/redux-saga/es/internal/proc.js");

Object.defineProperty(exports, 'CHANNEL_END', {
  enumerable: true,
  get: function () {
    return _proc.CHANNEL_END;
  }
});

/***/ }),

/***/ "../../node_modules/redux-saga/node_modules/redux/es/redux.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__DO_NOT_USE__ActionTypes = exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _getOwnPropertyDescriptor = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _getOwnPropertySymbols = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-own-property-symbols.js");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

var _defineProperty2 = __webpack_require__("../../node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _symbolObservable = __webpack_require__("../../node_modules/symbol-observable/es/index.js");

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while ((0, _getPrototypeOf2.default)(proto) !== null) {
    proto = (0, _getPrototypeOf2.default)(proto);
  }

  return (0, _getPrototypeOf2.default)(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */

  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */

  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */

  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */

  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */

  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[_symbolObservable2.default] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2.default] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */

  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = (0, _keys2.default)(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = (0, _keys2.default)(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  (0, _keys2.default)(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */

function combineReducers(reducers) {
  var reducerKeys = (0, _keys2.default)(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = (0, _keys2.default)(finalReducers);
  var unexpectedKeyCache;

  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */

function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var keys = (0, _keys2.default)(actionCreators);
  var boundActionCreators = {};

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    (0, _defineProperty3.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = (0, _keys2.default)(source);

    if (typeof _getOwnPropertySymbols2.default === 'function') {
      ownKeys = ownKeys.concat((0, _getOwnPropertySymbols2.default)(source).filter(function (sym) {
        return (0, _getOwnPropertyDescriptor2.default)(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = createStore;
exports.combineReducers = combineReducers;
exports.bindActionCreators = bindActionCreators;
exports.applyMiddleware = applyMiddleware;
exports.compose = compose;
exports.__DO_NOT_USE__ActionTypes = ActionTypes;

/***/ }),

/***/ "../../node_modules/redux/es/applyMiddleware.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return applyMiddleware; });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux/es/compose.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose__WEBPACK_IMPORTED_MODULE_0__["default"].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),

/***/ "../../node_modules/redux/es/bindActionCreators.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return bindActionCreators; });
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),

/***/ "../../node_modules/redux/es/combineReducers.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return combineReducers; });
/* harmony import */ var _createStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux/es/createStore.js");
/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux/es/utils/warning.js");




function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore__WEBPACK_IMPORTED_MODULE_0__["ActionTypes"].INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!Object(lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore__WEBPACK_IMPORTED_MODULE_0__["ActionTypes"].INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore__WEBPACK_IMPORTED_MODULE_0__["ActionTypes"].INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        Object(_utils_warning__WEBPACK_IMPORTED_MODULE_2__["default"])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        Object(_utils_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

/***/ }),

/***/ "../../node_modules/redux/es/compose.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compose; });
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/***/ }),

/***/ "../../node_modules/redux/es/createStore.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionTypes", function() { return ActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createStore; });
/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/symbol-observable/es/index.js");



/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!Object(lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_1__["default"]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_1__["default"]] = observable, _ref2;
}

/***/ }),

/***/ "../../node_modules/redux/es/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/redux/es/createStore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return _createStore__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _combineReducers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/redux/es/combineReducers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return _combineReducers__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _bindActionCreators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/redux/es/bindActionCreators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return _bindActionCreators__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _applyMiddleware__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/redux/es/applyMiddleware.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return _applyMiddleware__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/redux/es/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/redux/es/utils/warning.js");







/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  Object(_utils_warning__WEBPACK_IMPORTED_MODULE_5__["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



/***/ }),

/***/ "../../node_modules/redux/es/utils/warning.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return warning; });
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),

/***/ "../../node_modules/sdp-transform/lib/grammar.js":
/***/ (function(module, exports) {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{ //c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{ //b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          'rtpmap:%d %s/%s/%s':
          o.rate ?
          'rtpmap:%d %s/%s':
          'rtpmap:%d %s';
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      //a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    { //a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          'rtcp:%d %s IP%d %s':
          'rtcp:%d';
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%d trr-int %d'
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          'rtcp-fb:%s %s %s':
          'rtcp-fb:%s %s';
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'uri', 'config'],
      format: function (o) {
        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');
      }
    },
    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          'crypto:%d %s %s %s':
          'crypto:%d %s %s';
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: 'ptime:%d'
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: 'maxptime:%d'
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    { //a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    { //a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    { //a=ssrc-group:FEC 1 2
      //a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { //a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    { //a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null) ?
          'sctpmap:%s %s %s' :
          'sctpmap:%s %s';
      }
    },
    { //a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      //a=imageattr:* send [x=800,y=640] recv *
      //a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        //a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        //recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      //a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        //a=simulcast:
        '^simulcast:' +
        //send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        //space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        //end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //Old simulcast draft 03 (implemented by Firefox)
      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      //a=simulcast: recv pt=97;98 send pt=97
      //a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      //a=framerate:25
      //a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    { // RFC4570
      //a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});


/***/ }),

/***/ "../../node_modules/sdp-transform/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

var parser = __webpack_require__("../../node_modules/sdp-transform/lib/parser.js");
var writer = __webpack_require__("../../node_modules/sdp-transform/lib/writer.js");

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parseParams = parser.parseParams;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


/***/ }),

/***/ "../../node_modules/sdp-transform/lib/parser.js":
/***/ (function(module, exports, __webpack_require__) {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__("../../node_modules/sdp-transform/lib/grammar.js");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/\;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};


/***/ }),

/***/ "../../node_modules/sdp-transform/lib/writer.js":
/***/ (function(module, exports, __webpack_require__) {

var grammar = __webpack_require__("../../node_modules/sdp-transform/lib/grammar.js");

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),

/***/ "../../node_modules/stackframe/stackframe.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "../../node_modules/stampit/compose.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperties = __webpack_require__("../../node_modules/babel-runtime/core-js/object/define-properties.js");

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _create = __webpack_require__("../../node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _getPrototypeOf = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, '__esModule', { value: true });

function isObject(obj) {
  var type = typeof obj;
  return !!obj && (type === 'object' || type === 'function');
}

function isFunction(obj) {
  return typeof obj === 'function';
}

var assign = _assign2.default || function assign(to) {
  var args = arguments;
  for (var s = 1; s < args.length; s += 1) {
    var from = args[s];
    if (from) {
      var keys = (0, _keys2.default)(from);
      for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];
        to[key] = from[key];
      }
    }
  }

  return to;
};

var isArray = Array.isArray;

function isPlainObject(value) {
  return !!value && typeof value === 'object' && (0, _getPrototypeOf2.default)(value) === Object.prototype;
}

function concatAssignFunctions(dstObject, srcArray, propName) {
  if (!isArray(srcArray)) {
    return;
  }

  var length = srcArray.length;
  var dstArray = dstObject[propName] || [];
  dstObject[propName] = dstArray;
  for (var i = 0; i < length; i += 1) {
    var fn = srcArray[i];
    if (isFunction(fn) && dstArray.indexOf(fn) < 0) {
      dstArray.push(fn);
    }
  }
}

function combineProperties(dstObject, srcObject, propName, action) {
  if (!isObject(srcObject[propName])) {
    return;
  }
  if (!isObject(dstObject[propName])) {
    dstObject[propName] = {};
  }
  action(dstObject[propName], srcObject[propName]);
}

function deepMergeAssign(dstObject, srcObject, propName) {
  combineProperties(dstObject, srcObject, propName, merge);
}
function mergeAssign(dstObject, srcObject, propName) {
  combineProperties(dstObject, srcObject, propName, assign);
}

/**
 * The 'src' argument plays the command role.
 * The returned values is always of the same type as the 'src'.
 * @param dst
 * @param src
 * @returns {*}
 */
function mergeOne(dst, src) {
  if (src === undefined) {
    return dst;
  }

  // According to specification arrays must be concatenated.
  // Also, the '.concat' creates a new array instance. Overrides the 'dst'.
  if (isArray(src)) {
    return (isArray(dst) ? dst : []).concat(src);
  }

  // Now deal with non plain 'src' object. 'src' overrides 'dst'
  // Note that functions are also assigned! We do not deep merge functions.
  if (!isPlainObject(src)) {
    return src;
  }

  // See if 'dst' is allowed to be mutated. If not - it's overridden with a new plain object.
  var returnValue = isObject(dst) ? dst : {};

  var keys = (0, _keys2.default)(src);
  for (var i = 0; i < keys.length; i += 1) {
    var key = keys[i];

    var srcValue = src[key];
    // Do not merge properties with the 'undefined' value.
    if (srcValue !== undefined) {
      var dstValue = returnValue[key];
      // Recursive calls to mergeOne() must allow only plain objects or arrays in dst
      var newDst = isPlainObject(dstValue) || isArray(srcValue) ? dstValue : {};

      // deep merge each property. Recursion!
      returnValue[key] = mergeOne(newDst, srcValue);
    }
  }

  return returnValue;
}

var merge = function (dst) {
  var srcs = [],
      len = arguments.length - 1;
  while (len-- > 0) srcs[len] = arguments[len + 1];

  return srcs.reduce(mergeOne, dst);
};

/**
 * Creates new factory instance.
 * @param {Descriptor} descriptor The information about the object the factory will be creating.
 * @returns {Function} The new factory function.
 */
function createFactory(descriptor) {
  return function Stamp(options) {
    var args = [],
        len = arguments.length - 1;
    while (len-- > 0) args[len] = arguments[len + 1];

    // Next line was optimized for most JS VMs. Please, be careful here!
    var obj = (0, _create2.default)(descriptor.methods || null);

    merge(obj, descriptor.deepProperties);
    assign(obj, descriptor.properties);
    (0, _defineProperties2.default)(obj, descriptor.propertyDescriptors || {});

    if (!descriptor.initializers || descriptor.initializers.length === 0) {
      return obj;
    }

    if (options === undefined) {
      options = {};
    }
    var inits = descriptor.initializers;
    var length = inits.length;
    for (var i = 0; i < length; i += 1) {
      var initializer = inits[i];
      if (isFunction(initializer)) {
        var returnedValue = initializer.call(obj, options, { instance: obj, stamp: Stamp, args: [options].concat(args) });
        obj = returnedValue === undefined ? obj : returnedValue;
      }
    }

    return obj;
  };
}

/**
 * Returns a new stamp given a descriptor and a compose function implementation.
 * @param {Descriptor} [descriptor={}] The information about the object the stamp will be creating.
 * @param {Compose} composeFunction The "compose" function implementation.
 * @returns {Stamp}
 */
function createStamp(descriptor, composeFunction) {
  var Stamp = createFactory(descriptor);

  merge(Stamp, descriptor.staticDeepProperties);
  assign(Stamp, descriptor.staticProperties);
  (0, _defineProperties2.default)(Stamp, descriptor.staticPropertyDescriptors || {});

  var composeImplementation = isFunction(Stamp.compose) ? Stamp.compose : composeFunction;
  Stamp.compose = function _compose() {
    var args = [],
        len = arguments.length;
    while (len--) args[len] = arguments[len];

    return composeImplementation.apply(this, args);
  };
  assign(Stamp.compose, descriptor);

  return Stamp;
}

/**
 * Mutates the dstDescriptor by merging the srcComposable data into it.
 * @param {Descriptor} dstDescriptor The descriptor object to merge into.
 * @param {Composable} [srcComposable] The composable
 * (either descriptor or stamp) to merge data form.
 * @returns {Descriptor} Returns the dstDescriptor argument.
 */
function mergeComposable(dstDescriptor, srcComposable) {
  var srcDescriptor = srcComposable && srcComposable.compose || srcComposable;
  if (!isObject(srcDescriptor)) {
    return dstDescriptor;
  }

  mergeAssign(dstDescriptor, srcDescriptor, 'methods');
  mergeAssign(dstDescriptor, srcDescriptor, 'properties');
  deepMergeAssign(dstDescriptor, srcDescriptor, 'deepProperties');
  mergeAssign(dstDescriptor, srcDescriptor, 'propertyDescriptors');
  mergeAssign(dstDescriptor, srcDescriptor, 'staticProperties');
  deepMergeAssign(dstDescriptor, srcDescriptor, 'staticDeepProperties');
  mergeAssign(dstDescriptor, srcDescriptor, 'staticPropertyDescriptors');
  mergeAssign(dstDescriptor, srcDescriptor, 'configuration');
  deepMergeAssign(dstDescriptor, srcDescriptor, 'deepConfiguration');
  concatAssignFunctions(dstDescriptor, srcDescriptor.initializers, 'initializers');

  return dstDescriptor;
}

/**
 * Given the list of composables (stamp descriptors and stamps) returns
 * a new stamp (composable factory function).
 * @typedef {Function} Compose
 * @param {...(Composable)} [composables] The list of composables.
 * @returns {Stamp} A new stamp (aka composable factory function)
 */
function compose() {
  var composables = [],
      len = arguments.length;
  while (len--) composables[len] = arguments[len];

  var descriptor = [this].concat(composables).filter(isObject).reduce(mergeComposable, {});
  return createStamp(descriptor, compose);
}

/**
 * The Stamp Descriptor
 * @typedef {Function|Object} Descriptor
 * @returns {Stamp} A new stamp based on this Stamp
 * @property {Object} [methods] Methods or other data used as object instances' prototype
 * @property {Array<Function>} [initializers] List of initializers called for each object instance
 * @property {Object} [properties] Shallow assigned properties of object instances
 * @property {Object} [deepProperties] Deeply merged properties of object instances
 * @property {Object} [staticProperties] Shallow assigned properties of Stamps
 * @property {Object} [staticDeepProperties] Deeply merged properties of Stamps
 * @property {Object} [configuration] Shallow assigned properties of Stamp arbitrary metadata
 * @property {Object} [deepConfiguration] Deeply merged properties of Stamp arbitrary metadata
 * @property {Object} [propertyDescriptors] ES5 Property Descriptors applied to object instances
 * @property {Object} [staticPropertyDescriptors] ES5 Property Descriptors applied to Stamps
 */

/**
 * The Stamp factory function
 * @typedef {Function} Stamp
 * @returns {*} Instantiated object
 * @property {Descriptor} compose - The Stamp descriptor and composition function
 */

/**
 * A composable object - stamp or descriptor
 * @typedef {Stamp|Descriptor} Composable
 */

exports['default'] = compose;
module.exports = exports['default'];
//# sourceMappingURL=compose.js.map

/***/ }),

/***/ "../../node_modules/symbol-observable/es/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js"), __webpack_require__("../../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../../node_modules/symbol-observable/es/ponyfill.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "../../node_modules/timer-machine/lib/timer.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */
var EventEmitter = __webpack_require__("../../node_modules/events/events.js").EventEmitter
var inherits     = __webpack_require__("../../node_modules/util/util.js").inherits

/**
 * Expose `Timer`.
 */
module.exports = Timer

/**
 * Stores named timers.
 */
var timers = {}

/**
 * Initialize a `Timer` object
 * @param {Boolean} start
 * @api public
 */
function Timer(start) {
  EventEmitter.call(this)
  this._total = 0
  this._start = null
  this._startCount = 0
  if (start) {
    this.start()
  }
}

/**
 * Timer extends EventEmitter.
 */
inherits(Timer, EventEmitter)

/**
 * Get a named timer, initialize a new one if it does not exist.
 * @param {String} name
 * @return {Timer}
 * @api public
 */
Timer.get = function (name) {
  if (!timers[name]) {
    timers[name] = new Timer()
  }
  return timers[name]
}

/**
 * Destroy an existing named timer.
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
Timer.destroy = function (name) {
  if (timers[name]) {
    return delete timers[name]
  }
  return false
}

/**
 * Get the total milliseconds the timer has run.
 * @return {Number}
 * #api public
 */
Timer.prototype.time = function () {
  var total = this._total
  total += this.timeFromStart()
  return total
}

/**
 * Get the total millisseonds the time has run and emit time event.
 * @return {Number}
 */
Timer.prototype.emitTime = function () {
  var time = this.time()
  this.emit('time', time)
  return time
}

/**
 * Get the time in milliseconds since the timer was last started.
 * @return {Number}
 * @api public
 */
Timer.prototype.timeFromStart = function () {
  return this.isStarted() ? now() - this._start : 0
}

/**
 * Check to see if the timer object is currently started.
 * @return {Boolean}
 * @api public
 */
Timer.prototype.isStarted = function () {
  return !this.isStopped()
}

/**
 * Check to see if the timer object is currently stopped.
 * @return {Boolean}
 * @api public
 */
Timer.prototype.isStopped = function () {
  return this._start === null
}

/**
 * Start the timer if it was not already started.
 * @return {Boolean}
 * @api public
 */
Timer.prototype.start = function () {
  ++this._startCount
  if (this.isStopped()) {
    this._start = now()
    this.emit('start')
    return true
  }
  return false
}

/**
 * Stop the timer if it was not already stopped.
 * @return {Boolean}
 * @api public
 */
Timer.prototype.stop = function () {
  if (this.isStarted()) {
    this._total += this.timeFromStart()
    this._start = null
    this._stopCount = 0
    this.emit('stop')
    return true
  }
  return false
}

/**
 * Stop the timer if once called equal to the number of times start was called.
 * @return {Boolean} true if timer was stopped
 * @api public
 */
Timer.prototype.stopParallel = function () {
  if (this.isStarted()) {
    --this._startCount
    if (this._startCount === 0) {
      return this.stop()
    }
  }
  return false
}

/**
 * Start or stop the timer depending on current state.
 * @return {Boolean}
 * @api public
 */
Timer.prototype.toggle = function () {
  return this.start() || this.stop()
}

/**
 * Return a string representation of the timer.
 * @return {String}
 */
Timer.prototype.toString = function () {
  return this.time() + 'ms'
}

/**
 * Return a numeric value of the timer in milliseconds.
 * @return {Number}
 */
Timer.prototype.valueOf = function () {
  return this.time()
}

/**
 * Get the current time in milliseconds.
 * @return {Number}
 * @api private
 */
function now() {
  return new Date().getTime();
}


/***/ }),

/***/ "../../node_modules/to-camel-case/index.js":
/***/ (function(module, exports, __webpack_require__) {


var space = __webpack_require__("../../node_modules/to-space-case/index.js")

/**
 * Export.
 */

module.exports = toCamelCase

/**
 * Convert a `string` to camel case.
 *
 * @param {String} string
 * @return {String}
 */

function toCamelCase(string) {
  return space(string).replace(/\s(\w)/g, function (matches, letter) {
    return letter.toUpperCase()
  })
}


/***/ }),

/***/ "../../node_modules/to-no-case/index.js":
/***/ (function(module, exports) {


/**
 * Export.
 */

module.exports = toNoCase

/**
 * Test whether a string is camel-case.
 */

var hasSpace = /\s/
var hasSeparator = /(_|-|\.|:)/
var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/

/**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */

function toNoCase(string) {
  if (hasSpace.test(string)) return string.toLowerCase()
  if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase()
  if (hasCamel.test(string)) return uncamelize(string).toLowerCase()
  return string.toLowerCase()
}

/**
 * Separator splitter.
 */

var separatorSplitter = /[\W_]+(.|$)/g

/**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function unseparate(string) {
  return string.replace(separatorSplitter, function (m, next) {
    return next ? ' ' + next : ''
  })
}

/**
 * Camelcase splitter.
 */

var camelSplitter = /(.)([A-Z]+)/g

/**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function uncamelize(string) {
  return string.replace(camelSplitter, function (m, previous, uppers) {
    return previous + ' ' + uppers.toLowerCase().split('').join(' ')
  })
}


/***/ }),

/***/ "../../node_modules/to-space-case/index.js":
/***/ (function(module, exports, __webpack_require__) {


var clean = __webpack_require__("../../node_modules/to-no-case/index.js")

/**
 * Export.
 */

module.exports = toSpaceCase

/**
 * Convert a `string` to space case.
 *
 * @param {String} string
 * @return {String}
 */

function toSpaceCase(string) {
  return clean(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
    return match ? ' ' + match : ''
  }).trim()
}


/***/ }),

/***/ "../../node_modules/util/support/isBufferBrowser.js":
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../../node_modules/util/util.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__("../../node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__("../../node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js"), __webpack_require__("../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/uuid/lib/bytesToUuid.js":
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../node_modules/uuid/lib/rng-browser.js":
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "../../node_modules/uuid/v4.js":
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__("../../node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__("../../node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/harmony-module.js":
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../node_modules/webrtc-adapter/out/adapter_no_edge.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(msidParts) {
    return msidParts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],3:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":4}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":5,"./common_shim":7,"./edge/edge_shim":1,"./firefox/firefox_shim":8,"./safari/safari_shim":10,"./utils":11}],5:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver',
            {value: {receiver: e.receiver}});
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSenderReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          var pc = this;
          var senders = origGetSenders.apply(pc, []);
          senders.forEach(function(sender) {
            sender._pc = pc;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function() {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function() {
        var sender = this;
        return this._pc.getStats().then(function(result) {
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          return filterStats(result, sender.track, true);
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function() {
          var pc = this;
          var receivers = origGetReceivers.apply(pc, []);
          receivers.forEach(function(receiver) {
            receiver._pc = pc;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function() {
        var receiver = this;
        return this._pc.getStats().then(function(result) {
          return filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function() {
      var pc = this;
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender;
        var receiver;
        var err;
        pc.getSenders().forEach(function(s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        pc.getReceivers().forEach(function(r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(pc, arguments);
    };
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  },

  fixNegotiationNeeded: function(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function(e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  },

  shimGetDisplayMedia: function(window, getSourceId) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' +
          'a function');
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      return getSourceId(constraints)
        .then(function(sourceId) {
          var widthSpecified = constraints.video && constraints.video.width;
          var heightSpecified = constraints.video && constraints.video.height;
          var frameRateSpecified = constraints.video &&
            constraints.video.frameRate;
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: frameRateSpecified || 3
            }
          };
          if (widthSpecified) {
            constraints.video.mandatory.maxWidth = widthSpecified;
          }
          if (heightSpecified) {
            constraints.video.mandatory.maxHeight = heightSpecified;
          }
          return navigator.mediaDevices.getUserMedia(constraints);
        });
    };
  }
};

},{"../utils.js":11,"./getusermedia":6}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":11}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var utils = require('./utils');

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function() {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      wrapDcSend(dataChannel, pc);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
};

},{"./utils":11,"sdp":2}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        },
        enumerable: true,
        configurable: true
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimSenderGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function() {
      return this.track ? this._pc.getStats(this.track) :
          Promise.resolve(new Map());
    };
  },

  shimReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function() {
        var pc = this;
        var receivers = origGetReceivers.apply(pc, []);
        receivers.forEach(function(receiver) {
          receiver._pc = pc;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function() {
      return this._pc.getStats(this.track);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  },

  shimRTCDataChannel: function(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  },

  shimGetDisplayMedia: function(window, preferredMediaSource) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return navigator.mediaDevices.getUserMedia(constraints);
    };
  }
};

},{"../utils":11,"./getusermedia":9}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":11}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
          }
          this.addEventListener('addstream', this._onaddstream = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

},{"../utils":11}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

},{}]},{},[3])(3)
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../fcs/src/js/sdp/codecRemover.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createCodecRemover;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * returns a function with params object
 * @param  {Array} An array of strings or objects representing the desired codecs to be removed,
 * can be passed in as a string or as objects with the following signature:
 *  [{
 *      name: 'codecname',
 *      fmtpParams: 'specific ftmp parameter target'
 *  }]
 * @return {Function}        [description]
 *
 * INSTRUCTIONS FOR EXPOSING FUNCTION TO CPAAS VERSION OF THE SDK:
 * the following code will need to be added to the appropriate index files (ie: kandy.cpaas.js)
 * this will expose the createCodecRemover function in the browser
    import createCodecRemover from '../../fcs/src/js/sdp/codecRemover';
    kandy.sdpHandlers = {
        createCodecRemover
    };
    module.exports = kandy;

 * INSTRUCTIONS USING RUNNING FUNCTION ONCE EXPOSED
 * From the browser Devtools run the following:
 * const codecRemover = createKandy.sdpHandlers.createCodecRemover(['VP8', 'VP9'])
 * const newSdp = codecRemover(<SDP Object>); // the incoming SDP object
 * console.log(newSdp)
 */
function createCodecRemover(config) {
    if (!config) {
        config = [];
    }
    // We allow the user to pass in a config of objects or strings, so here we format the strings into objects for uniformity.
    config = config.map(function (item) {
        return typeof item === 'string' ? { name: item } : item;
    });

    return function () {
        // Adding support for new callstack sdp handlers
        // Old callstack sdp pipeline passes an object to each sdp
        // handler that contains the currentSdp
        // New callstack passes 3 arguments to each sdp handler
        // newSdp, info, originalSdp
        var oldCallstack = true;
        var currentSdp = void 0;

        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
        }

        if (params[0].currentSdp) {
            currentSdp = params[0].currentSdp;
        } else if (params.length === 3) {
            oldCallstack = false;
            currentSdp = params[0];
        }

        var newSdp = (0, _fp.cloneDeep)(currentSdp);

        // This is an array of strings representing codec names we want to remove.
        var codecStringsToRemove = config.map(function (codec) {
            return codec.name;
        });

        newSdp.media.forEach(function (media) {
            // This is an array of just the codes (codec payloads) that we FOR SURE want to remove.
            var finalRemoveList = [];
            // This is an array of RTP objects who have codecs that are the same as strings passed in via config.
            var filteredRtp = [];

            // If the current rtp.codec is in the codecStringsToRemove list, add the rtp to filteredRtp
            filteredRtp = media.rtp.filter(function (rtp) {
                return codecStringsToRemove.includes(rtp.codec);
            });

            filteredRtp.forEach(function (rtp) {
                // We grab the relevantCodec config object from the passed in config, based on the name string.
                var relevantCodec = (0, _fp.find)(function (codec) {
                    return codec.name === rtp.codec;
                }, config);

                // We check the relevantCodec. If it is not present, then we have no config info for this specific rtp.
                if (relevantCodec) {
                    // If fmtpParams doesnt exist or is of length 0 then we assume we can remove all instances of this codec
                    if (!relevantCodec.fmtpParams || relevantCodec.fmtpParams && relevantCodec.fmtpParams.length === 0) {
                        // We want to delete this codec no matter what, since no fmtp params were included.
                        finalRemoveList.push(rtp.payload);
                    } else {
                        // There are fmtp values for this codec. Therefore we have to check each media.fmtp object to see if it is the right one.
                        // Then when we find the right fmtp object, we check its config to see if it has the parameters specified in the input.
                        media.fmtp.forEach(function (fmtp) {
                            // We check each iteration to see if we found the right fmtp object.
                            if (fmtp.payload === rtp.payload) {
                                // If we found the right fmtp object, we have to make sure each config param is in the fmtp.config.
                                if (relevantCodec.fmtpParams.every(function (c) {
                                    return fmtp.config.includes(c);
                                })) {
                                    finalRemoveList.push(rtp.payload);
                                }
                            }
                        });
                    }
                }
            });

            // At this point we should have an array (finalRemoveList) that contains all ORIGINAL codec payloads that we need to remove.
            // We now need to check fmtp for all rtx payloads ASSOCIATED with the original codec payload.
            media.fmtp.forEach(function (fmtp) {
                // Check if the config contains apt=, which indicates this fmtp is associated with another.
                if (fmtp.config.includes('apt=')) {
                    // If so, lets grab the whole string WITHOUT the apt= part, and convet it into an integer. This should be a payload number.
                    var payload = parseInt(fmtp.config.replace('apt=', ''));

                    // Check if the finalRemoveList contains the payload that this fmtp is associated with.
                    if (finalRemoveList.includes(payload)) {
                        // If so, then we need to add this fmtp.payload to the finalRemoveList
                        finalRemoveList.push(fmtp.payload);
                    }
                }
            });

            // We assume past this point that the finalRemoveList is all powerful.
            // For each codec in the media.payloads string, if it is in our finalRemoveList list, we remove it.
            var isNumber = false;
            if (typeof media.payloads === 'number') {
                media.payloads = media.payloads.toString();
                isNumber = true;
            }
            if (media.payloads) {
                media.payloads = media.payloads.split(' ').filter(function (payload) {
                    return !finalRemoveList.includes(parseInt(payload));
                }).join(' ');
            }
            if (media.payloads && isNumber) {
                media.payloads = parseInt(media.payloads);
            }

            // For each codec object, if the payload is in our filteredCodes list, we remove the object.
            if (media.rtp) {
                media.rtp = media.rtp.filter(function (rtp) {
                    return !finalRemoveList.includes(rtp.payload);
                });
            }

            if (media.fmtp) {
                media.fmtp = media.fmtp.filter(function (fmtp) {
                    return !finalRemoveList.includes(fmtp.payload);
                });
            }
            if (media.rtcpFb) {
                media.rtcpFb = media.rtcpFb.filter(function (rtcpFb) {
                    return !finalRemoveList.includes(rtcpFb.payload);
                });
            }
        });

        // If old callstack, then return the results of the next sdp handler
        // If new callstack, then just return the modified sdp
        return oldCallstack ? params[0].next(newSdp) : newSdp;
    };
}

/***/ }),

/***/ "../webrtc/src/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Constants relating to the Peer model.
 */
const PEER = exports.PEER = {
  TRICKLE_ICE: {
    FULL: 'FULL',
    HALF: 'HALF',
    NONE: 'NONE'
  },
  // Defined by the RTCPeerConnection.iceGatheringState spec.
  ICE_GATHERING_STATE: {
    NEW: 'new',
    GATHERING: 'gathering',
    COMPLETE: 'complete'
  },
  ENDPOINT: {
    LOCAL: 'local',
    REMOTE: 'remote'
  },
  SDP_SEMANTICS: {
    PLAN_B: 'plan-b',
    UNIFIED_PLAN: 'unified-plan'
  }

  /**
   * SDP constants for media direction.
   * @type {Object}
   */
};const MEDIA_DIR = exports.MEDIA_DIR = {
  INACTIVE: 'inactive',
  SEND_ONLY: 'sendonly',
  RECV_ONLY: 'recvonly',
  SEND_RECV: 'sendrecv'
};

/***/ }),

/***/ "../webrtc/src/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = initialize;

var _track = __webpack_require__("../webrtc/src/models/track.js");

var _track2 = _interopRequireDefault(_track);

var _media = __webpack_require__("../webrtc/src/models/media.js");

var _media2 = _interopRequireDefault(_media);

var _peer = __webpack_require__("../webrtc/src/models/peer.js");

var _peer2 = _interopRequireDefault(_peer);

var _mediaManager = __webpack_require__("../webrtc/src/managers/mediaManager.js");

var _mediaManager2 = _interopRequireDefault(_mediaManager);

var _peerManager = __webpack_require__("../webrtc/src/managers/peerManager.js");

var _peerManager2 = _interopRequireDefault(_peerManager);

var _sessionManager = __webpack_require__("../webrtc/src/managers/sessionManager.js");

var _sessionManager2 = _interopRequireDefault(_sessionManager);

var _deviceManager = __webpack_require__("../webrtc/src/managers/deviceManager.js");

var _deviceManager2 = _interopRequireDefault(_deviceManager);

var _trackManager = __webpack_require__("../webrtc/src/managers/trackManager.js");

var _trackManager2 = _interopRequireDefault(_trackManager);

var _pipeline = __webpack_require__("../webrtc/src/sdpUtils/pipeline.js");

var _pipeline2 = _interopRequireDefault(_pipeline);

var _handlers = __webpack_require__("../webrtc/src/sdpUtils/handlers.js");

var sdpHandlers = _interopRequireWildcard(_handlers);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _adapter_no_edge = __webpack_require__("../../node_modules/webrtc-adapter/out/adapter_no_edge.js");

var _adapter_no_edge2 = _interopRequireDefault(_adapter_no_edge);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// SDP helpers.
// Models.
function initialize() {
  const browserDetails = _adapter_no_edge2.default.browserDetails;
  if (browserDetails.version) {
    _loglevel2.default.debug(`Browser details: ${browserDetails.browser}, version ${browserDetails.version}.`);
  } else {
    _loglevel2.default.debug('Browser details: Not supported by webRTC adapter.');
  }

  const deviceManager = new _deviceManager2.default();
  const trackManager = new _trackManager2.default();
  const mediaManager = new _mediaManager2.default({ trackManager });
  const peerManager = new _peerManager2.default({ trackManager });
  const sessionManager = new _sessionManager2.default({ peerManager, mediaManager, trackManager });

  return {
    models: {
      Track: _track2.default,
      Media: _media2.default,
      Peer: _peer2.default
    },
    // TODO: Make naming consistent.
    managers: {
      devices: deviceManager,
      media: mediaManager,
      peerManager: peerManager,
      sessionManager,
      track: trackManager
    },
    sdp: {
      pipeline: _pipeline2.default,
      handlers: sdpHandlers
    }
  };
}

// Managers.

/***/ }),

/***/ "../webrtc/src/managers/deviceManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBRTC_DEVICE_KINDS = undefined;

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * A conversion from MediaDeviceInfo.kind values to their more common terms.
 * See: https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/kind
 * @enum {String}
 */
// Libraries.
const WEBRTC_DEVICE_KINDS = exports.WEBRTC_DEVICE_KINDS = {
  audioinput: 'microphone',
  videoinput: 'camera',
  audiooutput: 'speaker'

  /**
   * Manager for connected devices.
   * Keeps an up-to-date list of all devices.
   * @class DeviceManager
   */
};class DeviceManager extends _eventemitter2.default {
  constructor() {
    super();
    // Store each device type separately, so that `deviceId` is unique
    //    per kind (there is a `default` deviceId per kind).
    this.microphone = [];
    this.camera = [];
    this.speaker = [];

    // Check devices on initialization.
    this.checkDevices().then(() => {
      // Emit an initial event with the device lists.
      this.emit('change', this.get());
    });

    // Check devices whenever they change.
    let recentDeviceChange = false;
    navigator.mediaDevices.ondevicechange = () => {
      _loglevel2.default.info('Media device change detected.');
      // A physical device change results in one event per
      // device "kind". Group the events together.
      if (!recentDeviceChange) {
        recentDeviceChange = true;
        setTimeout(() => {
          recentDeviceChange = false;
          this.checkDevices().then(() => {
            // Emit an event with the updated device lists.
            this.emit('change', this.get());
          });
        }, 50);
      }
    };
  }

  /**
   * Updates the stored device lists with the latest devices.
   * @method checkDevices
   * @return {Promise}
   */
  checkDevices() {
    _loglevel2.default.info('Checking media devices.');
    return new _promise2.default((resolve, reject) => {
      navigator.mediaDevices.enumerateDevices().then(devices => {
        // Clear the stored devices, to prevent duplicates.
        this.microphone = [];
        this.camera = [];
        this.speaker = [];
        devices.forEach(device => {
          const kind = WEBRTC_DEVICE_KINDS[device.kind];
          this[kind].push(device);
        });
        resolve();
      }).catch(reject);
    });
  }

  /**
   * Retrieves the stored device lists.
   * @method get
   * @return {Object}
   */
  get() {
    return {
      microphone: this.microphone,
      camera: this.camera,
      speaker: this.speaker
    };
  }
}
exports.default = DeviceManager;

/***/ }),

/***/ "../webrtc/src/managers/mediaManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _map = __webpack_require__("../../node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

var _media = __webpack_require__("../webrtc/src/models/media.js");

var _media2 = _interopRequireDefault(_media);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manager for Media objects.
 * Allows the creation and retrieval of media objects.
 * @class MediaManager
 */


// Libraries.
class MediaManager extends _eventemitter2.default {
  constructor(managers) {
    super();
    this.trackManager = managers.trackManager;
    // TODO: Have this private?
    this.medias = new _map2.default();
  }

  /**
   * Retrieve a snapshot of all Media objects' current state.
   * @method getState
   * @return {Array}
   */
  getState() {
    return this.getAll().map(id => this.get(id).getState());
  }

  /**
   * Create a new local Media object.
   * Use the provided constraints to get user media as the base MediaStream.
   * @method createLocal
   * @param  {MediaStreamConstraints}  constraints
   * @return {Promise}
   */
  createLocal(constraints) {
    // Get user media, ...
    return new _promise2.default((resolve, reject) => {
      // TODO: Proper error checking.
      // TODO: Use the WebAPI directly here? Probably not.
      navigator.mediaDevices.getUserMedia(constraints).then(mediaStream => {
        // ... then create a Media object with it.
        const media = new _media2.default(mediaStream, true);
        _loglevel2.default.debug(`Creating Media with ID: ${media.id}.`);

        // Only add tracks to a Media objects using the `addTrack` method.
        mediaStream.getTracks().forEach(nativeTrack => {
          const wrappedTrack = this.trackManager.add(nativeTrack, mediaStream);
          media.addTrack(wrappedTrack);
        });

        media.once('media:stopped', mediaId => {
          this.remove(mediaId);
        });

        media.on('track:removed', trackId => {
          if (media.tracks.size === 0) {
            this.remove(media.id);
          }
        });

        media.on('track:ended', ({ mediaId, trackId }) => {
          if (media.getTracks().length === 0) {
            this.remove(mediaId);
          }
        });

        this.medias.set(media.id, media);
        // TODO: Better event. Include metadata?
        this.emit('media:new', media.id);

        resolve(media);
      }).catch(reject);
    });
  }

  /**
   * Create a new remote Media object.
   * Use provided stream/tracks as the base media objects.
   * @method createRemote
   * @param  {MediaStream} mediaStream Native MediaStream object.
   * @param  {Tracks[]} tracks Array of Track objects.
   * @return {Media}
   */
  createRemote(stream, tracks = []) {
    const media = new _media2.default(stream, false);

    tracks.forEach(track => {
      media.addTrack(track);
    });

    media.once('media:stopped', mediaId => {
      this.remove(mediaId);
    });

    media.on('track:removed', trackId => {
      if (media.tracks.size === 0) {
        this.remove(media.id);
      }
    });

    media.on('track:ended', ({ mediaId, trackId }) => {
      if (media.getTracks().length === 0) {
        this.remove(mediaId);
      }
    });

    this.medias.set(media.id, media);
    // TODO: Better event. Include metadata?
    this.emit('media:new', media.id);
    return media;
  }

  // TODO: This should be a private function.
  /**
   * Removes a Media object from the medias array.
   * @method remove
   * @param {String} mediaId
   */
  remove(mediaId) {
    const media = this.get(mediaId);
    if (media) {
      this.medias.delete(mediaId);
      this.emit('media:removed', mediaId);
    }
  }

  /**
   * Retrieve an existing Media object.
   * @method get
   * @param  {String} mediaId ID of the desired Media object.
   * @return {Media}
   */
  get(mediaId) {
    const media = this.medias.get(mediaId);
    if (!media) {
      _loglevel2.default.debug(`No media found with ID: ${mediaId}.`);
    }
    return media;
  }

  /**
   * Retrieve a list of all existing Media object's IDs.
   * @method getAll
   * @return {Array} List of Media IDs.
   */
  getAll() {
    return (0, _from2.default)(this.medias.keys());
  }

  /**
   * Finds the Media object that contains the specified Track.
   * @method findTrack
   * @param  {string}  trackId The ID of the Track to find.
   * @return {string} The ID of the Media object that contains the Track.
   */
  findTrack(trackId) {
    // Search through all Media objects for the one that has the desired track.
    const medias = (0, _from2.default)(this.medias.values());
    const media = medias.find(media => media.getTrack(trackId));
    if (media) {
      _loglevel2.default.debug(`Found Media (${media.id}) with Track ${trackId}.`);
      return media.id;
    } else {
      _loglevel2.default.debug(`Found no Media with Track ${trackId}.`);
    }
  }
}
exports.default = MediaManager; // Models that this manager directly manages.

/***/ }),

/***/ "../webrtc/src/managers/peerManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _map = __webpack_require__("../../node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

var _peer = __webpack_require__("../webrtc/src/models/peer.js");

var _peer2 = _interopRequireDefault(_peer);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manager for Peer objects.
 * Allows the creation and retrieval of peer objects.
 * @class PeerManager
 */
class PeerManager extends _eventemitter2.default {
  constructor(managers) {
    super();
    this.trackManager = managers.trackManager;
    this.peers = new _map2.default();
  }

  /**
   * Retrieve a snapshot of all Peer objects' current state.
   * @method getState
   * @return {Array}
   */
  getState() {
    return this.getAll().map(id => this.get(id).getState());
  }

  /**
   * Create a new Peer using the provided configs.
   * @method create
   * @param  {Object} [config={}]
   * @return {Peer}
   */
  create(config = {}) {
    const peer = new _peer2.default((0, _v2.default)(), config, this.trackManager);
    peer.once('peer:closed', id => this.peers.delete(id));
    this.peers.set(peer.id, peer);
    this.emit('peer:new', peer.id);
    return peer;
  }

  /**
   * Retrieves an existing Peer object.
   * @method get
   * @param  {String} id ID of the desired Peer object.
   * @return {Peer}
   */
  get(id) {
    const peer = this.peers.get(id);
    if (!peer) {
      _loglevel2.default.debug(`No Peer found with ID: ${id}.`);
    }
    return peer;
  }

  /**
   * Retrieve a list of all existing Peer object's IDs.
   * @method getAll
   * @return {Array} List of Peer IDs.
   */
  getAll() {
    return (0, _from2.default)(this.peers.keys());
  }
}
exports.default = PeerManager;

// Libraries.

/***/ }),

/***/ "../webrtc/src/managers/sessionManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _map = __webpack_require__("../../node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

var _session = __webpack_require__("../webrtc/src/models/session.js");

var _session2 = _interopRequireDefault(_session);

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manager for Session objects.
 * Allows for creation and retrieval of session objects.
 * @class SessionManager
 */
class SessionManager extends _eventemitter2.default {
  constructor(managers) {
    super();
    this.managers = managers;
    this.sessions = new _map2.default();
  }

  /**
   * Create a new Session object.
   * @method create
   * @param {Object} [config]
   * @param {Object} [config.peer] Configs for the Session's Peer object.
   * @return {Session}
   */
  create(config = {}) {
    const session = new _session2.default((0, _v2.default)(), this.managers, config);
    session.once('session:ended', id => {
      this.sessions.delete(id);
      this.emit('session:removed', id);
    });
    this.sessions.set(session.id, session);
    this.emit('session:new', session.id);
    return session;
  }

  /**
   * Retrieve an existing Session object.
   * @method get
   * @param  {String} sessionId ID of the desired Session object.
   * @return {Session}
   */
  get(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      _loglevel2.default.debug(`No session found with ID: ${sessionId}.`);
    }
    return session;
  }

  /**
   * Retrieve a list of all existing Sessions.
   * @method getAll
   * @return {Array} List of Media IDs.
   */
  getAll() {
    return (0, _from2.default)(this.sessions.values());
  }
}
exports.default = SessionManager;

// Libraries.

/***/ }),

/***/ "../webrtc/src/managers/trackManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _map = __webpack_require__("../../node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

exports.default = TrackManager;

var _track = __webpack_require__("../webrtc/src/models/track.js");

var _track2 = _interopRequireDefault(_track);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manager / store for Track objects.
 * @method TrackManager
 */
function TrackManager() {
  /**
   * The Track objects being managed.
   * @type {Map}
   */
  const tracks = new _map2.default();
  const emitter = new _eventemitter2.default();

  /**
   * Retrieve a Track object.
   * @method get
   * @param  {string} trackId
   * @return {Track}
   */
  function get(trackId) {
    return tracks.get(trackId);
  }

  /**
   * Retrieve a list of Track objects.
   * If no tracks are specified, will return all tracks.
   * @method getTracks
   * @param  {Array} [trackIds] List of tracks to retrieve.
   * @return {Array}
   */
  function getTracks(trackIds) {
    if (trackIds) {
      return trackIds.map(trackId => tracks.get(trackId));
    } else {
      return (0, _from2.default)(tracks.values());
    }
  }

  /**
   * Wraps a MediaStreamTrack into a Track object and adds
   *    it to the manager.
   * @method add
   * @param  {MediaStreamTrack} track A native track object.
   * @param  {MediaStream} stream
   * @return {Track} The added/wrapped Track object.
   */
  function add(track, stream) {
    const targetTrack = tracks.get(track.id);

    // Chrome issue: track.stream is outdated and needs to be updated to newStream.
    // targetTrack.stream.active is false & targetTrack.stream.getTracks() gives us an empty array.
    // stream.active is true & stream.getTracks() gives us the correct array of tracks.
    // Set/update the new stream as the track's stream
    if (targetTrack && !targetTrack.stream.active && stream.active) {
      // The track was previously registered and is being re-added with new stream
      targetTrack.stream = stream;
      return targetTrack;
    } else if (targetTrack) {
      // This track is already registered.
      return targetTrack;
    } else {
      // Wrap the track as a Track object.
      const wrappedTrack = new _track2.default(track, stream);
      tracks.set(track.id, wrappedTrack);

      // Remove the track from the manager when it ends.
      wrappedTrack.once('ended', remove);

      emitter.emit('add', wrappedTrack.id);
      return wrappedTrack;
    }
  }

  /**
   * Remove a Track from the manager.
   * @method remove
   * @param  {string} trackId
   * @return {Boolean} Whether the Track existed (and hence removed).
   */
  function remove(trackId) {
    const track = get(trackId);
    if (track) {
      tracks.delete(trackId);
      // Clean up any listeners.
      track.off('ended', remove);
      emitter.emit('remove', trackId);
    }

    return Boolean(track);
  }

  function on(...args) {
    return emitter.on(...args);
  }

  function once(...args) {
    return emitter.once(...args);
  }

  function off(...args) {
    return emitter.off(...args);
  }

  /**
   * The exposed API.
   */
  return {
    get,
    getTracks,
    add,
    remove,
    on,
    once,
    off
  };
}

// Libraries.

/***/ }),

/***/ "../webrtc/src/models/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__("../../node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _map = __webpack_require__("../../node_modules/babel-runtime/core-js/map.js");

var _map2 = _interopRequireDefault(_map);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class to represent a "media" object.
 * Wraps a MediaStream object.
 * @class Media
 * TODO: Rename to Stream? Would be more straight-forward since Tracks can be
 *    managed directly (with trackManager), instead of through a "Media" object.
 */
// Libraries.
class Media extends _eventemitter2.default {
  constructor(nativeStream, isLocal) {
    super();
    this.id = nativeStream.id;
    this.isLocal = isLocal;
    this.stream = nativeStream;
    /**
     * Mapping of the IDs of this Media object's tracks to the Track object.
     * @type {Map}
     */
    this.tracks = new _map2.default();
    this.stream.onremovetrack = event => {
      this.tracks.delete(event.track.id);
      this.emit('track:removed', event.track.id);
    };
  }

  /**
   * Retrieve a snapshot of the Media object's current state.
   * @method getState
   * @return {Object}
   */
  getState() {
    return {
      id: this.id,
      tracks: (0, _from2.default)(this.tracks.values()).map(track => track.getState()),
      isLocal: this.isLocal
    };
  }

  /**
   * Add a track to this Media object.
   * @method addTrack
   * @param {Track} track The Track object to add to the Media object.
   */
  addTrack(track) {
    if (this.tracks.has(track.id)) {
      _loglevel2.default.debug(`Track (${track.id}) is already in Media (${this.id}).`);
      return;
    }

    // Add the native MediaStreamTrack to the MediaStream.
    this.stream.addTrack(track.track);
    // Add the Track to the Media object.
    this.tracks.set(track.id, track);

    /**
     * When a track ends, remove it from the Media object then clean it up.
     */
    track.on('ended', () => {
      const removedTrack = this.removeTrack(track.id);
      removedTrack.cleanup();
      this.emit('track:ended', {
        mediaId: this.id,
        trackId: removedTrack.id
      });
    });
    // TODO: Emit event or return result?
    this.emit('track:new', {
      mediaId: this.id,
      trackId: track.id
    });
  }

  /**
   * Remove a track from the Media object.
   * @method removeTrack
   * @param  {string} trackId The Track to remove.
   */
  removeTrack(trackId) {
    const track = this.getTrack(trackId);
    if (track) {
      this.tracks.delete(trackId);
      return track;
    }
  }

  /**
   * Render all tracks of this Media object inside the specified element.
   * @method renderIn
   * @param  {HTMLElement} element The DOM element to be rendered in.
   * @param  {String} [speakerId] The device ID to be used for audio output.
   */
  renderIn(element, speakerId) {
    this.getTracks().forEach(track => {
      track.renderIn(element, speakerId);
    });
  }

  /**
   * Stop rendering all tracks of this Media object from the specified element.
   * @method removeFrom
   * @param  {HTMLElement} element The DOM element to be removed from.
   */
  removeFrom(element) {
    this.getTracks().forEach(track => {
      track.removeFrom(element);
    });
  }

  /**
   * Moves the rendered Media object to only the specified element.
   * @method moveTo
   * @param  {HTMLElement} element The DOM element to be move to.
   */
  moveTo(element) {
    this.getTracks().forEach(track => {
      track.moveTo(element);
    });
  }

  /**
   * Stop all Tracks within this Media object.
   * @method stop
   */
  stop() {
    this.getTracks().forEach(track => {
      track.stop();
    });
    this.emit('media:stopped', this.id);
  }

  /**
   * Clean-up the Media object by stopping all Tracks and removing any rendered media.
   * @method cleanup
   */
  cleanup() {
    this.getTracks().forEach(track => {
      track.cleanup();
    });
    this.emit('media:stopped', this.id);
  }

  /**
   * Retrieve the list of Track object this this Media object manages.
   * @method getTracks
   * @return {Array} The list of Track objects.
   */
  getTracks() {
    return (0, _from2.default)(this.tracks.values());
  }

  /**
   * Retrieve a specific Track object from within the Media object.
   * @method getTrack
   * @param  {String} trackId ID of the Track to retrieve.
   * @return {Track}
   */
  getTrack(trackId) {
    return this.tracks.get(trackId);
  }
}
exports.default = Media;

/***/ }),

/***/ "../webrtc/src/models/peer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _constants = __webpack_require__("../webrtc/src/constants.js");

var _pipeline = __webpack_require__("../webrtc/src/sdpUtils/pipeline.js");

var _handlers = __webpack_require__("../webrtc/src/sdpUtils/handlers.js");

var _sdpSemantics = __webpack_require__("../webrtc/src/sdpUtils/sdpSemantics.js");

var _utils = __webpack_require__("../webrtc/src/utils.js");

var _transceiverUtils = __webpack_require__("../webrtc/src/sdpUtils/transceiverUtils.js");

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _timerMachine = __webpack_require__("../../node_modules/timer-machine/lib/timer.js");

var _timerMachine2 = _interopRequireDefault(_timerMachine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Configuration object for a Peer.
 * @typedef {Object} PeerConfig
 * @property {Object} [rtcConfig] Configuration for the native RTCPeerConnection.
 * @property {String} [trickleIceMode=FULL] The initial mode the Peer will use when receiving ICE candidates.
 * @property {Number} [iceTimeout=10000] Duration (in ms) that the Peer should wait for ICE candidate collection.
 * @property {Function} [halfTrickleThreshold] Function that determines whether the threshold has been met when in HALF trickle mode.
 */


// SDP Helpers.
const defaultConfig = {
  rtcConfig: {
    sdpSemantics: _constants.PEER.SDP_SEMANTICS.PLAN_B
  },
  trickleIceMode: _constants.PEER.TRICKLE_ICE.FULL,
  removeBundling: true,
  iceTimeout: 10000,
  halfTrickleThreshold: isPassedHalfTrickleThreshold

  /**
   * Default function for determining whether the HALF trickle ICE threshold has
   *    been met, to start trickling ICE candidates.
   * Defines the threshold as one relay candidate being gathered.
   * @method isPassedHalfTrickleThreshold
   * @param  {String}             sdp          The local SDP of the Peer.
   * @param  {RTCIceCandidate}    iceCandidate The native candidate object that triggered this check.
   * @param  {Number}             time         The amount of time (ms) since ICE collection began.
   * @return {Boolean} Whether the "half trickle" threshold has been passed.
   */
};

// Libraries.
// Helpers.
function isPassedHalfTrickleThreshold({ sdp, iceCandidate, time }) {
  const passedHalf = iceCandidate.candidate.indexOf('relay') !== -1;
  _loglevel2.default.debug(`Peer's half trickle threshold ${!passedHalf ? 'not ' : ''}reached.`);
  return passedHalf;
}

/**
 * Wrapper class for a native RTCPeerConnection object.
 * Ref: https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
 * @class Peer
 * TODO: Should this be renamed to PeerConnection or Connection? Just so its clearer?
 */
class Peer extends _eventemitter2.default {
  constructor(id, config = {}, trackManager) {
    super();
    this.config = (0, _utils.mergeValues)(defaultConfig, config);
    this.trackManager = trackManager;

    _loglevel2.default.info(`Creating peer connection with ID: ${id}.`, this.config);
    this.id = id;
    this.peerConnection = new RTCPeerConnection(this.config.rtcConfig);
    this.iceTimer = _timerMachine2.default.get(`ice-${this.id}`);

    // Bubble up the RTCPeerConnection events.
    const events = ['oniceconnectionstatechange', 'onsignalingstatechange', 'onnegotiationneeded'];

    /**
     * Intercept the PeerConnection onicecandidate event.
     * Handle the candidate as defined by the current trickle ICE mode config.
     * Trickle ICE scenarios:
     *   - FULL: Trickle.
     *   - HALF, pre-half: Wait for "half" or null candidate.
     *   - HALF, post-half: Trickle.
     *   - NONE: Wait for null candidate.
     */
    this.peerConnection.onicecandidate = event => {
      _loglevel2.default.debug(`ICE candidate received (trickling?: ${this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.FULL}): `, event.candidate);

      if (this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.FULL) {
        // If trickling is enabled, emit an event for every ICE candidate. The
        //    Peer is already ready for negotiation at this point.
        if (event.candidate) {
          // Only trickle non-null (ie. actual) candidates.
          this.emit('onicecandidate', event);
        }
      } else if (event.candidate === null) {
        // If we received the last candidate (null), then gathering is done and
        //    Peer is ready for negotiation (no matter the scenario).
        _loglevel2.default.debug('ICE collection process complete; ready for negotiation.');
        this.emit('onnegotiationready');
      } else if (this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.HALF) {
        // For half trickle, only start trickling after a certain threshold.
        //    Peer will be considered ready for negotiation after that point.
        const haveHalf = this.config.halfTrickleThreshold({
          sdp: this.peerConnection.localDescription.sdp,
          iceCandidate: event.candidate,
          time: this.iceTimer.timeFromStart()
        });

        if (haveHalf) {
          _loglevel2.default.debug('Half ICE collection process complete; ready for negotiation.');
          this.config.trickleIceMode = _constants.PEER.TRICKLE_ICE.FULL;
          this.emit('onnegotiationready');
        }
      }
    };

    /**
     * Intercept the PeerConnection onicegatheringstatechange event.
     * Time how long ICE collection takes and handles scenarios when it takes
     *    too long.
     * TODO: Figure out how we should do events. Makes events simpler/better,
     *    with proper formats.
     */
    this.peerConnection.onicegatheringstatechange = event => {
      const gatheringState = event.target.iceGatheringState;
      _loglevel2.default.debug(`Peer's iceGatheringState changed to ${gatheringState}.`);

      if (gatheringState === _constants.PEER.ICE_GATHERING_STATE.GATHERING) {
        this.iceTimer.start();
        // TODO: Handle "ICE collection taking too long" scenario.
      } else if (gatheringState === _constants.PEER.ICE_GATHERING_STATE.COMPLETE) {
        _loglevel2.default.debug(`Peer took ${this.iceTimer.timeFromStart()}ms to collect ICE candidates.`);
        this.iceTimer.stop();
      }
      // Bubble the event up.
      this.emit('onicegatheringstatechange', event);
    };

    // TODO: Is this how we want business logic to listen for PeerConnection events?
    events.forEach(eventType => {
      this.peerConnection[eventType] = event => {
        _loglevel2.default.debug(`Peer ${eventType} event.`, event);
        // TODO: Should this be eventType or event.type?
        this.emit(eventType, event);
      };
    });

    /**
     * Intercept the PeerConnection ontrack event.
     * Check whether the track is from a new MediaStream or not.
     * TODO: Figure out how we should do events. Makes events simpler/better,
     *    with proper formats.
     */
    this.peerConnection.ontrack = event => {
      /**
       * transceiver: The RTCRtpTransceiver for this remote track. (Available in unified-plan)
       * receiver: The RTCRtpReceiver for this remote track.
       * track: The remote MediaStreamTrack.
       * streams: Array of MediaStreams the track is in.
       */
      // event object contains transceiver which already has track attached to its receiver
      const { track: nativeTrack, streams } = event;

      // When remote side adds track on a previously unused transceiver sender via `replaceTrack`,
      //  a stream is not associated with it so we get no stream here.
      // So we create our own stream here.
      // In the future, support will be available for `sender.setStreams` on the remote side
      //  so this is a temporary workaround.
      let targetStream;
      if (streams.length === 0) {
        targetStream = new MediaStream([nativeTrack]);
      } else {
        targetStream = streams[0];
      }

      // Convert the native MediaStreamTrack into a Track object.
      const track = this.trackManager.add(nativeTrack, targetStream);

      _loglevel2.default.debug(`Peer (${this.id}) received track (${track.id}).`);
      this.emit('ontrack', track);
    };
  }

  /**
   * @property {Array} localTracks List of active Track objects added to the Peer locally.
   */
  get localTracks() {
    // Return the list of Tracks from active senders.
    return this.peerConnection.getSenders()
    /**
     * Remove any Senders that do not have an associated track.
     * We only want to retrieve Senders that do have tracks, because those are
     *    the local tracks that have been added to the Peer.
     * Senders without tracks are part of a Transceiver where the Receiver has
     *    a remote track, but no local track has been added to it. We don't
     *    care about this for the "get local tracks" operation.
     */
    .filter(sender => Boolean(sender.track)).map(sender => this.trackManager.get(sender.track.id)).filter(track => {
      // Make sure the trackManager has the track and that its active.
      // It's possble that Peer has the sender but not the actual track yet.
      return track && track.getState().state === 'live' && track.stream.active;
    });
  }

  /**
   * @property {Array} remoteTracks List of active Track objects the Peer has received remotely.
   */
  get remoteTracks() {
    // Return the list of Tracks from active receivers.
    return this.peerConnection.getReceivers()
    /**
     * Remove any Receivers that do not have an associated track.
     * We only want to retrieve Receivers that do have tracks, because those are
     *    the remote tracks that have been added to the Peer.
     * Receivers without tracks are part of a Transceiver where the Sender has
     *    a local track, but no remote track has been added to it. We don't
     *    care about this for the "get remote tracks" operation.
     */
    .filter(receiver => Boolean(receiver.track)).map(receiver => this.trackManager.get(receiver.track.id)).filter(track => {
      // Make sure the trackManager has the track and that its active.
      // It's possble that Peer has the receiver but not the actual track yet.
      return track && track.getState().state === 'live' && track.stream.active;
    });
  }

  /**
   * Retrieve a snapshot of the Peer object's current state.
   * @method getState
   * @return {Object}
   */
  getState() {
    return {
      id: this.id,
      config: this.config,
      localDesc: this.localDescription,
      signalingState: this.peerConnection.signalingState,
      localTracks: this.localTracks,
      remoteTracks: this.remoteTracks
    };
  }

  /**
   * Creates an SDP offer.
   * @method createOffer
   * @param  {RTCOfferOptions} [options={}] Options used to customize the offer.
   * @param  {Object} [options.mediaDirections] Directions to use for media.
   * @param  {string} [options.mediaDirections.audio]
   * @param  {string} [options.mediaDirections.video]
   * @return {Promise} Resolves with the offer.
   */
  createOffer(options = {}) {
    // If using unified-plan, remove options.mediaDirections.
    // This is because directions are now set in transceivers.
    if ((0, _sdpSemantics.isUnifiedPlan)(this.config.rtcConfig.sdpSemantics)) {
      delete options.mediaDirections;
    }

    return new _promise2.default((resolve, reject) => {
      this.peerConnection.createOffer(options).then(offer => {
        const sdpHandlers = [];
        if (this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.NONE) {
          // Modify the offer to claim the Peer doesn't suport trickle ICE.
          sdpHandlers.push(_handlers.removeTrickleIce);
        }
        if (this.config.removeBundling) {
          // Modify the offer to remove media bundling
          sdpHandlers.push(_handlers.removeBundling);
        }
        if (options.mediaDirections) {
          // Modify the offer to set media directions as desired.
          sdpHandlers.push((0, _handlers.changeMediaDirection)(options.mediaDirections));
        }
        if (sdpHandlers.length > 0) {
          // Run the SDP pipeline with only these handlers.
          offer.sdp = (0, _pipeline.runPipeline)(sdpHandlers, offer.sdp, {
            type: offer.type,
            endpoint: _constants.PEER.ENDPOINT.LOCAL
          });
        }
        resolve(offer);
      }).catch(reject);
    });
  }

  /**
   * Creates an SDP answer, given that a remote offer has been set.
   * @method createOffer
   * @param  {RTCAnswerOptions} [options={}] Options used to customize the answer.
   * @param  {Object} [options.mediaDirections] Directions to use for media.
   * @param  {string} [options.mediaDirections.audio]
   * @param  {string} [options.mediaDirections.video]
   * @return {Promise} Resolves with the answer.
   */
  createAnswer(options = {}) {
    // If using unified-plan, remove options.mediaDirections.
    // This is because directions are now set in transceivers.
    if ((0, _sdpSemantics.isUnifiedPlan)(this.config.rtcConfig.sdpSemantics)) {
      delete options.mediaDirections;
    }

    return new _promise2.default((resolve, reject) => {
      this.peerConnection.createAnswer(options).then(answer => {
        const sdpHandlers = [];
        if (this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.NONE) {
          // Modify the answer to claim the Peer doesn't suport trickle ICE.
          sdpHandlers.push(_handlers.removeTrickleIce);
        }
        if (this.config.removeBundling) {
          // Modify the offer to remove media bundling
          sdpHandlers.push(_handlers.removeBundling);
        }
        if (options.mediaDirections) {
          // Modify the answer to set media directions as desired.
          sdpHandlers.push((0, _handlers.changeMediaDirection)(options.mediaDirections));
        }
        if (sdpHandlers.length > 0) {
          // Run the SDP pipeline with only these handlers.
          answer.sdp = (0, _pipeline.runPipeline)(sdpHandlers, answer.sdp, {
            type: answer.type,
            endpoint: _constants.PEER.ENDPOINT.LOCAL
          });
        }
        resolve(answer);
      }).catch(reject);
    });
  }

  /**
   * The SDP for the local end of the connection.
   * @property localDescription
   */
  get localDescription() {
    const localDesc = this.peerConnection.localDescription;
    if (localDesc && localDesc.sdp && localDesc.type) {
      return localDesc;
    } else {
      return undefined;
    }
  }

  /**
   * Sets an SDP as the local description of the connection.
   * The returned Promise will resolve when the Peer is ready for negotiation,
   *    taking into account the Peer's `trickleIceMode` configuration.
   * @method setLocalDescription
   * @param  {RTCSessionDescription} sessionDesc
   * @return {Promise}
   */
  setLocalDescription(sessionDesc) {
    // TODO: SDP pipeline here.
    _loglevel2.default.info(`Setting local description ${sessionDesc.type}:`, sessionDesc.sdp);

    return new _promise2.default((resolve, reject) => {
      // We always want to wait for the PeerConnection to be ready for
      //    negotiation before resolving setLocalDescription.
      // Each trickle ICE option (FULL/HALF/NONE) emits "negotiation ready" event once.
      this.once('onnegotiationready', () => {
        if (this.iceTimer.isStarted()) {
          // In a HALF trickle scenario, the Peer will be ready for negotiation
          //    before ICE collection has completed. Log that timing.
          _loglevel2.default.debug(`Peer took ${this.iceTimer.timeFromStart()}ms to collect ICE candidates before negotiation.`);
        }
        resolve();
      });

      this.peerConnection.setLocalDescription(sessionDesc).then(() => {
        if (this.config.trickleIceMode === _constants.PEER.TRICKLE_ICE.FULL) {
          // Trickling ICE candidates means that we can begin negotiation immediately.
          _loglevel2.default.debug('Local description set; ready for negotiation (full trickleICE).');
          this.emit('onnegotiationready');
        } else {
          // ICE candidates aren't always gathered (only initially and when something
          //  changes), but we rely on "gathering complete" to know when the Peer is
          //  ready for negotiation. Give the Peer some time to start gathering
          //  before deciding if we need to wait for gathering to complete or not.
          // The timeout is needed because of a bug in Chrome:
          //    https://bugs.chromium.org/p/webrtc/issues/detail?id=1873
          // Known issue: If candidate collection takes less time than this timeout,
          //  the logged message will be incorrect, but will functionality still work.
          setTimeout(() => {
            if (this.peerConnection.iceGatheringState === 'complete') {
              // Gathering is "complete", so we are ready for negotiation.
              _loglevel2.default.debug(`Local description set, ICE candidate collection not needed; ready for negotiation.`);
              this.emit('onnegotiationready');
            } else {
              _loglevel2.default.debug(`Local description set, waiting for ICE collection process (${this.config.trickleIceMode}).`);
              // TODO: Handle this scenario properly.
              // If ICE collection never finishes, we need to time it out at some point.
              setTimeout(() => this.emit('onnegotiationready'), 3000);
            }
          }, 25);
        }
      }).catch(reject);
    });
  }

  /**
   * Sets an SDP as the remote description of the connection.
   * @method setRemoteDescription
   * @param  {RTCSessionDescription} sessionDesc
   */
  setRemoteDescription(sessionDesc) {
    // TODO: SDP pipeline here.
    // TODO: Update `this.config.trickleIceMode` to either NONE or FULL (from HALF)
    //    depending on remote support, since HALF is only needed for initial.
    _loglevel2.default.info(`Setting remote description ${sessionDesc.type}:`, sessionDesc.sdp);
    return this.peerConnection.setRemoteDescription(sessionDesc);
  }

  /**
   * Finds a specific transceiver depending on the options passed in
   * @method findTransceiver
   * @param {Object} [options] Only one of these options will be taken. They are ordered by priority.
   * @param {string} [options.trackId] The transceiver with the specific sender.track.id.
   * @return {Object} The transceiver that was found (undefined if not found).
   */
  findTransceiver(options) {
    const transceivers = this.peerConnection.getTransceivers();
    if (options.trackId) {
      return transceivers.find(transceiver => transceiver.sender.track && transceiver.sender.track.id === options.trackId);
    }
  }

  /**
   * Replaces a specified transceiver's sender.track.
   * @method replaceTrack
   * @param {Object} [options] Options for specifying which transceiver's sender should be replaced. They are ordered by priority.
   * @param {Array} [options.trackId] The track id whose transceivers we want to set the direction of.
   * @param {Object} track The MediaStreamTrack we want to place into the sender.
   * @return {Object} A Promise object which is fulfilled once the track has been replaced
   */
  replaceTrack(options, track) {
    const targetTransceiver = this.findTransceiver(options);
    return new _promise2.default((resolve, reject) => {
      if (targetTransceiver) {
        targetTransceiver.sender.replaceTrack(track).then(resolve).catch(reject);
      } else {
        reject(new Error(`Transceiver ${options} not found.`));
      }
    });
  }

  /**
   * Finds a transceiver that can be reused.
   * A transceiver can be reused if it satisfies the following conditions:
   *   - it does not have a track on its sender
   *   - it has the same kind (audio or video) as what we specified
   *   - it has been used before (if it has not been used then we are not "reusing" it)
   * @method findReusableTransceiver
   * @param {string} kind The kind of transceiver to find (audio or video)
   * @returns {Object} Transceiver object that matches kind, has no sender track, and has currentDirection. Otherwise undefined.
   */
  findReusableTransceiver(kind) {
    if ((0, _sdpSemantics.isUnifiedPlan)(this.config.rtcConfig.sdpSemantics)) {
      const transceivers = this.peerConnection.getTransceivers();
      return transceivers.find(transceiver => transceiver.sender.track == null && transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind && transceiver.currentDirection // If this has been set, then transceiver has been used before.
      );
    } else {
      _loglevel2.default.info(`Transceivers are only available in unified-plan.`);
    }
  }

  /**
   * Add a Track to the connection.
   * @method addTrack
   * @param  {Track} track A Track object.
   * @return {RTCRtpSender}
   */
  addTrack(track) {
    // Ensure the track wasn't already added to the Peer.
    if (this.localTracks.findIndex(localTrack => localTrack.id === track.id) > -1) {
      _loglevel2.default.debug(`Track (${track.id}) already added to Peer (${this.id}).`);
      return;
    }

    let sender;
    try {
      sender = this.peerConnection.addTrack(track.track, track.stream);
    } catch (err) {
      // TODO: Better error handling.
      _loglevel2.default.debug(err.message);
    }
    // TODO: What to return here? Probably shouldn't expose the rtpSender itself.
    return sender;
  }

  /**
   * Add an ICE candidate to the connection.
   * @method addIceCandidate
   * @param  {RTCIceCandidate} candidate A native candidate object.
   * @return {Promise} Resolves when the candidate is successfully added.
   */
  addIceCandidate(candidate) {
    return new _promise2.default((resolve, reject) => {
      if (this.peerConnection.remoteDescription.type && this.peerConnection.remoteDescription.sdp) {
        this.peerConnection.addIceCandidate(candidate).then(resolve).catch(reject);
      } else {
        _loglevel2.default.debug(`Peer ${this.id} cannot set remote ICE candidate without a remote description.`);
        // TODO: Better error.
        reject(new Error(`Peer ${this.id} cannot set remote ICE candidate without a remote description.`));
      }
    });
  }

  /**
   * Clean the Peer by closing the RTCPeerConnection.
   * @method close
   */
  close() {
    this.peerConnection.close();
    this.emit('peer:closed', this.id);
  }

  /**
   * Remove a Track from the connection.
   * @method removeTrack
   * @param  {string} trackId An id for a Track object.
   */
  removeTrack(trackId) {
    const track = this.localTracks.find(track => track.id === trackId);
    if (!track) {
      _loglevel2.default.debug(`Invalid track ID ${trackId}; cannot remove track.`);
      return;
    } else if (this.peerConnection.signalingState === ' closed') {
      _loglevel2.default.debug(`Peer ${this.id} is closed; cannot remove track.`);
      return;
    }

    // Get the RtpSender for the Track we want to remove.
    const sender = this.peerConnection.getSenders().filter(sender => sender.track !== null).find(sender => sender.track.id === trackId);
    this.peerConnection.removeTrack(sender);
  }

  /**
   * Event handler when tone is played.
   * @method handleToneChangeEvent
   * @param  {event} event
   */
  handleToneChangeEvent(event) {
    if (event.tone !== '') {
      _loglevel2.default.debug('Tone played: ' + event.tone);
    } else {
      _loglevel2.default.debug('All tones have played.');
    }
  }

  /**
   * Helper function to sendDTMF tones .
   * @method insertDTMF
   * @param {sender} object
   * @param {string} tone
   * @param {number} duration
   * @param {number} intertoneGap
   * @param {Function} callback
   */
  insertDTMF(sender, tone, duration, intertoneGap, callback) {
    if (sender.dtmf) {
      const dtmfSender = sender.dtmf;
      if (callback) {
        dtmfSender.ontonechange = callback;
      } else {
        dtmfSender.ontonechange = this.handleToneChangeEvent;
      }
      try {
        dtmfSender.insertDTMF(tone, duration, intertoneGap);
        return true;
      } catch (err) {
        _loglevel2.default.debug(err.message);
        return false;
      }
    } else {
      _loglevel2.default.debug('The sender requires DTMF which is not support by this browser.');
      return false;
    }
  }

  /**
   * Send DTMF tones.
   * @method sendDTMF
   * @param {Object} DTMFOptions The DTMF options.
   * @param {string} DTMFOptions.tone DTMF tone to send. Valid values are [0,1,2,3,4,5,6,7,8,9,#].
   * @param {number} DTMFOptions.duration=100 The amount of time, in milliseconds, that each DTMF tone should last.
   * @param {number} DTMFOptions.intertoneGap=70 The length of time, in milliseconds, to wait between tones.
   * @param {Object} [sendOptions] The send options.
   * @param {func} [sendOptions.callback] Optional callback for tone event .
   * @param {string} [sendOptions.trackId] The trackId of the sender to use.
   * @return {Boolean} Whether the DTMF tones were inserted
   */
  sendDTMF({ tone, duration = 100, intertoneGap = 70 }, { callback, trackId }) {
    if (!this.peerConnection.getSenders) {
      _loglevel2.default.debug('RTCPeerConnection method getSenders() is required which is not support by this browser.');
      return false;
    }
    const senders = this.peerConnection.getSenders();
    // Use the trackId if it was provided
    if (trackId) {
      let sender = senders.find(sender => sender.track.id === trackId);
      if (!sender) {
        _loglevel2.default.debug('No sender with that trackId');
        return false;
      }
      this.insertDTMF(sender, tone, duration, intertoneGap, callback);
      return true;
    } else {
      let result;
      for (let i = 0; i < senders.length; i++) {
        result = this.insertDTMF(senders[i], tone, duration, intertoneGap, callback);
        if (result) {
          return true;
        }
      }
      _loglevel2.default.debug('No appropriate senders were found');
      return false;
    }
  }

  /**
   * Retrieve RTCStatsReport for a sender or the peerConnection.
   * @method getStats
   * @param {string} [TrackId] Return stats for peerConnection if trackId is not provided
   * @return {Promise} Resolves with the RTCStatsReport
   */
  getStats(trackId) {
    // If no trackId is supplied, get the stats from the RTCPeerConnection. Otherwise, find an RTCSender
    // associated with the trackId and get the stats from it.

    // Use the trackId if it was provided
    if (trackId) {
      return new _promise2.default((resolve, reject) => {
        const senders = this.peerConnection.getSenders();
        // search for a sender associated with the trackId
        const sender = senders.find(sender => sender.track.id === trackId);
        if (sender) {
          sender.getStats().then(resolve).catch(reject);
        } else {
          const errMsg = `Cannot find sender with trackId: ${trackId}`;
          _loglevel2.default.debug(errMsg);
          reject(new Error(errMsg));
        }
      });
    } else {
      // get the stats associated with the peerConnection if no trackId is supplied
      return this.peerConnection.getStats();
    }
  }

  /**
   * Sets the direction of transceivers.
   * @method setTransceiversDirection
   * @param {string} targetDirection The desired direction to set the transceivers to.
   * @param {Object} [options] Options for specifying which transceivers should be affected. They are ordered by priority.
   * @param {Array} [options.trackIds] The optional list of track ids whose transceivers we want to set the direction of.
   * @return {Object} An object containing an `error` flag and  an array `failures` of transceivers whose directions weren't changed.
   */
  setTransceiversDirection(targetDirection, options = {}) {
    if ((0, _sdpSemantics.isUnifiedPlan)(this.config.rtcConfig.sdpSemantics)) {
      let transceivers = this.peerConnection.getTransceivers();

      if (options.trackIds) {
        transceivers = transceivers.filter(transceiver => options.trackIds.includes(transceiver.sender.track.id));
      }

      const failures = [];
      transceivers.forEach(transceiver => {
        if (!(0, _transceiverUtils.setTransceiverDirection)(transceiver, targetDirection)) {
          failures.push(transceiver);
        }
      });
      return {
        error: failures.length !== 0,
        failures
      };
    } else {
      _loglevel2.default.info(`Transceiver direction modification is only available in unified-plan.`);
      return {
        error: true
      };
    }
  }
}
exports.default = Peer;

/***/ }),

/***/ "../webrtc/src/models/session.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _constants = __webpack_require__("../webrtc/src/constants.js");

var _pipeline = __webpack_require__("../webrtc/src/sdpUtils/pipeline.js");

var _pipeline2 = _interopRequireDefault(_pipeline);

var _sdpSemantics = __webpack_require__("../webrtc/src/sdpUtils/sdpSemantics.js");

var _handlers = __webpack_require__("../webrtc/src/sdpUtils/handlers.js");

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class to represent a webRTC Session for a single peer.
 * "Session" being an abstraction of a webRTC connection between another peer.
 * Performs logic for initializing and connecting a peer connection.
 * Manages media added to / received from the peer connection.
 * @class Session
 */


// Libraries.
// Helpers.
class Session extends _eventemitter2.default {
  constructor(id, managers, config = {}) {
    super();

    // Keeps track of who started the initial offer.
    // We need this for calls with firefox so that DTLS roles aren't interpreted by other browsers (chrome)
    //  as being switched when the one that didn't initiate a call tries to start renegotiation offer.
    // See more details on the issue here https://groups.google.com/forum/#!topic/discuss-webrtc/gsw3OEAwNKo.
    this.isInitialOfferrer = undefined;

    _pipeline2.default.setHandlers([_handlers.setDtlsSetupToPassiveIfInitialOfferrer]);

    // The session's unique id
    this.id = id;
    this.config = config;
    this.peerManager = managers.peerManager;
    this.mediaManager = managers.mediaManager;
    this.trackManager = managers.trackManager;

    // Create and initialize the peer
    const peer = this.peerManager.create(this.config.peer);
    if (peer) {
      // The id of the created peer
      this.peerId = peer.id;

      // TODO: Use `uniqueLabel` when setting event listeners (and bubbling events).
      // When the peer gets an ICE candidate, emit it as
      //  a message to be sent to the other end.
      peer.on('onicecandidate', event => {
        this.emit('onicecandidate', {
          candidate: event.candidate
        });
      });

      // Handle when the Peer receives a new remote track.
      peer.on('ontrack', track => {
        let media = this.mediaManager.get(track.stream.id);
        if (media) {
          // Add the new Track to its Media object.
          media.addTrack(track);
        } else {
          // Create a new Media object using the Track.
          media = this.mediaManager.createRemote(track.stream, [track]);
        }

        track.once('ended', () => {
          this.emit('track:ended', {
            local: false,
            trackId: track.id
          });
        });

        // Indicate that the Session has a new Track.
        this.emit('new:track', {
          local: false,
          trackId: track.id
        });
      });
    } else {
      throw new Error(`Peer creation error in Session ${this.id}.`);
    }
  }

  /**
   * @property {Array} localTracks List of active Track objects the Session has added locally.
   */
  get localTracks() {
    const peer = this.peerManager.get(this.peerId);
    if (peer) {
      return peer.localTracks;
    } else {
      return [];
    }
  }

  /**
   * @property {Array} remoteTracks List of active Track objects the Session has received remotely.
   */
  get remoteTracks() {
    const peer = this.peerManager.get(this.peerId);
    if (peer) {
      return peer.remoteTracks;
    } else {
      return [];
    }
  }

  /**
   * Retrieve a snapshot of the Session object's current state.
   * @method getState
   * @return {Object}
   */
  getState() {
    return {
      id: this.id,
      localTracks: this.localTracks,
      remoteTracks: this.remoteTracks
    };
  }

  /**
   * Setup a warm PeerConnection.
   * @method warmup
   */
  warmup() {}

  /**
   * Add Track objects to the Session.
   * @method addTracks
   * @param  {Array} tracks List of Track objects.
   */
  addTracks(tracks) {
    const peer = this.peerManager.get(this.peerId);
    // TODO: Better error handling?
    if (peer) {
      const addTrackOrReuseTransceiverPromises = tracks.map(track => {
        return new _promise2.default((resolve, reject) => {
          // We try to find a reusable transceiver that we can attach the track to achieve the following:
          // - Avoid transceiver pollution and needing to create a brand new transceiver to attach the track to.
          // - Allow re-adding of the same track type that has been previously removed.
          //   (This is so that we can still have re-adding of tracks when using the "basic" media API which imposes a 1-audio & 1-video limit)
          const reusableTransceiver = peer.findReusableTransceiver(track.track.kind);

          // If we can find a reusable transceiver, reuse it.
          if ((0, _sdpSemantics.isUnifiedPlan)(this.config.peer.rtcConfig.sdpSemantics) && reusableTransceiver) {
            // Current limitations of transceiver reuse method:
            // - We cannot attach the track's associated stream to the sender (lack of `sender.setStreams` support atm)
            // So the local transceiver's sender track & remote transceiver's receiver track must have been used before so that it already has a stream attached to the sender.
            // If the local transceiver's sender has not been used before, we should ideally be able to do the following:
            // transceiver.sender.setStreams([<someStream>]) <- Not yet supported
            // transceiver.sender.replaceTrack(<someTrack>)
            // However, because of lack of support for `setStreams`, if we just tried to do `replaceTrack` on a transceiver that has not been used before,
            //  the sender will not have a stream and the SDP generated will have no associated stream which can cuase issues such as not triggering events on the local stream during renegotiation.
            // Once `setStreams` is supported, we can use the transceiver reuse method above even on transceivers that have not been used to send data before.
            reusableTransceiver.sender.replaceTrack(track.track).then(() => {
              reusableTransceiver.direction = reusableTransceiver.direction === 'recvonly' ? 'sendrecv' : 'sendonly';
              resolve(`Track (${track.track.kind} : ${track.id}) reused transceiver (mid: ${reusableTransceiver.mid}).`);
            }).catch(err => {
              _loglevel2.default.error(err);
              reject(err);
            });
          } else {
            // To get around the current limitation described above, we use peerConnection's `addTrack` when we can't find a reusable transceiver.
            // `addTrack` does one of the following when called:
            // - Create a new transceiver and attaches the track and stream to the sender
            // - Find and use an existing transceiver that has never been used to send data before and attach the track and stream to the sender.
            peer.addTrack(track);
            resolve(`Added track (${track.track.kind} : ${track.id}).`);
          }
        }).then(message => {
          // Set event emitters and handlers
          _loglevel2.default.info(message);

          // Indicate that the Session has a new Track.
          this.emit('new:track', {
            local: true,
            trackId: track.id
          });

          track.once('ended', () => {
            // If the PeerConnection is closed, we don't need to worry about
            //    removing the track (and it would throw an error anyway).
            if (peer.peerConnection.signalingState !== 'closed') {
              peer.removeTrack(track.id);
              this.emit('track:ended', {
                local: true,
                trackId: track.id
              });
            }
          });
        });
      });

      return _promise2.default.all(addTrackOrReuseTransceiverPromises);
    }
  }

  /**
   * Generates (and sets) a local SDP offer.
   * @method generateOffer
   * @param  {Object} [options] Options for configuring the SDP.
   * @param  {Object} [options.mediaDirections] Directions to use for media.
   * @param  {Array}  [options.sdpHandlers] SDP handlers for modifying the local offer.
   * @return {Promise} Resolves with the offer.
   */
  generateOffer(options = {}) {
    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
      }

      // If using unified-plan, remove options.mediaDirections.
      // This is because directions are now set in transceivers.
      if ((0, _sdpSemantics.isUnifiedPlan)(this.config.peer.rtcConfig.sdpSemantics)) {
        if (options.mediaDirections) {
          const audioTransceiverTargetDir = options.mediaDirections.audio;
          const videoTransceiverTargetDir = options.mediaDirections.video;

          if (audioTransceiverTargetDir) {
            const result = peer.setTransceiversDirection(audioTransceiverTargetDir, {
              trackIds: peer.localTracks.filter(track => track.track.kind === 'audio').map(track => track.id)
            });
            if (result.error) {
              _loglevel2.default.info(`Failed to process the following transceivers: ${result.failures}`);
            }
          }
          if (videoTransceiverTargetDir) {
            const result = peer.setTransceiversDirection(videoTransceiverTargetDir, {
              trackIds: peer.localTracks.filter(track => track.track.kind === 'video').map(track => track.id)
            });
            if (result.error) {
              _loglevel2.default.info(`Failed to process the following transceivers: ${result.failures}`);
            }
          }
          delete options.mediaDirections;
        }
      }

      peer.createOffer(options).then(offer => {
        // If initialOfferrer flag not set and offering, that means we are the initial offerrer.
        if (this.isInitialOfferrer === undefined) {
          this.isInitialOfferrer = true;
        }

        if (options.sdpHandlers || _pipeline2.default.getHandlers().length) {
          _loglevel2.default.debug('Modifying local offer with SDP pipeline.');
          offer.sdp = _pipeline2.default.run(options.sdpHandlers, offer.sdp, {
            type: offer.type,
            endpoint: _constants.PEER.ENDPOINT.LOCAL,
            isInitiator: this.isInitialOfferrer
          });
        }
        peer.setLocalDescription(offer).then(() => {
          // Resolve with the _current_ local description, which may be
          //    different than the provided offer due trickle ICE config.
          resolve(peer.localDescription);
        }).catch(reject);
      }).catch(reject);
    });
  }

  /**
   * Replaces a specified transceiver's sender.track.
   * @method replaceTrack
   * @param {Object} [options]
   * @param {String} [options.trackId] The transceiver with the specific sender.track.id.
   * @param {String} [options.mid] The transceiver with the specific media id.
   * @param {Object} track The MediaStreamTrack we want to place into the sender.
   * @return {Object} A Promise object which is fulfilled once the track has been replaced
   */
  replaceTrack(options, track) {
    const peer = this.peerManager.get(this.peerId);
    return peer.replaceTrack(options, track);
  }

  /**
   * Sets the direction of transceivers.
   * @method setTransceiversDirection
   * @param {String} targetDirection The desired direction to set the transceivers to.
   * @param {Object} [options] Options for specifying which transceivers should be affected.
   *  trackIds option has priority
   * @param {Array} [options.trackIds] The optional list of track ids whose transceivers we want to set the direction of.
   * @return {Object} An object containing an `error` flag and  an array `failures` of transceiver "mid"s whose directions weren't changed.
   */
  setTransceiversDirection(targetDirection, options = {}) {
    if ((0, _sdpSemantics.isUnifiedPlan)(this.config.peer.rtcConfig.sdpSemantics)) {
      const peer = this.peerManager.get(this.peerId);
      return peer.setTransceiversDirection(targetDirection, options);
    } else {
      _loglevel2.default.info(`Transceiver direction modification is only available in unified-plan.`);
      return { error: true };
    }
  }

  /**
   * Processes (and sets) a remote SDP offer.
   * @method processOffer
   * @param  {RTCSessionDescription} offer
   * @param  {Object} [options] Options for configuring the SDP.
   * @param  {Array}  [options.sdpHandlers] SDP handlers for modifying the remote offer.
   * @return {Promise}
   */
  processOffer(offer, options = {}) {
    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
      }

      if (options.sdpHandlers || _pipeline2.default.getHandlers().length) {
        _loglevel2.default.debug('Modifying remote offer with SDP pipeline.');
        offer.sdp = _pipeline2.default.run(options.sdpHandlers, offer.sdp, {
          type: offer.type,
          endpoint: _constants.PEER.ENDPOINT.REMOTE,
          isInitiator: this.isInitialOfferrer
        });
      }

      peer.setRemoteDescription(offer).then(resolve).catch(reject);
    });
  }

  /**
   * Generates (and sets) a local SDP answer.
   * @method generateAnswer
   * @param  {Object} [options] Options for configuring the SDP.
   * @param  {Object} [options.mediaDirections] Directions to use for media.
   * @param  {Array}  [options.sdpHandlers] SDP handlers for modifying the local answer.
   * @return {Promise} Resolves with the answer.
   */
  generateAnswer(options = {}) {
    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
      }

      // If using unified-plan, remove options.mediaDirections.
      // This is because directions are now set in transceivers.
      if ((0, _sdpSemantics.isUnifiedPlan)(this.config.peer.rtcConfig.sdpSemantics)) {
        if (options.mediaDirections) {
          const audioTransceiverTargetDir = options.mediaDirections.audio;
          const videoTransceiverTargetDir = options.mediaDirections.video;

          if (audioTransceiverTargetDir) {
            const result = peer.setTransceiversDirection(audioTransceiverTargetDir, {
              trackIds: peer.localTracks.filter(track => track.track.kind === 'audio').map(track => track.id)
            });
            if (result.error) {
              _loglevel2.default.info(`Failed to process the following transceivers: ${result.failures}`);
            }
          }
          if (videoTransceiverTargetDir) {
            const result = peer.setTransceiversDirection(videoTransceiverTargetDir, {
              trackIds: peer.localTracks.filter(track => track.track.kind === 'video').map(track => track.id)
            });
            if (result.error) {
              _loglevel2.default.info(`Failed to process the following transceivers: ${result.failures}`);
            }
          }
          delete options.mediaDirections;
        }
      }

      peer.createAnswer(options).then(answer => {
        // If initialOfferrer flag not set and answering, that means we aren't the initial offerrer.
        if (this.isInitialOfferrer === undefined) {
          this.isInitialOfferrer = false;
        }

        if (options.sdpHandlers || _pipeline2.default.getHandlers().length) {
          _loglevel2.default.debug('Modifying local answer with SDP pipeline.');
          answer.sdp = _pipeline2.default.run(options.sdpHandlers, answer.sdp, {
            type: answer.type,
            endpoint: _constants.PEER.ENDPOINT.LOCAL,
            isInitiator: this.isInitialOfferrer
          });
        }
        peer.setLocalDescription(answer).then(() => {
          // Resolve with the _current_ local description, which may be
          //    different than the provided answer due trickle ICE config.
          resolve(peer.localDescription);
        });
      }).catch(reject);
    });
  }

  /**
   * Processes (and sets) a remote SDP answer.
   * @method processAnswer
   * @param  {RTCSessionDescription} answer
   * @param  {Object} [options] Options for configuring the SDP.
   * @param  {Array}  [options.sdpHandlers] SDP handlers for modifying the remote answer.
   * @return {Promise}
   */
  processAnswer(answer, options = {}) {
    if (options.sdpHandlers || _pipeline2.default.getHandlers().length) {
      _loglevel2.default.debug('Modifying remote answer with SDP pipeline.');
      answer.sdp = _pipeline2.default.run(options.sdpHandlers, answer.sdp, {
        type: answer.type,
        endpoint: _constants.PEER.ENDPOINT.REMOTE,
        isInitiator: this.isInitialOfferrer
      });
    }

    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
      }

      peer.setRemoteDescription(answer).then(() => {
        resolve();
      }).catch(reject);
    });
  }

  /**
   * Add an ICE candidate from the remote endpoint.
   * @method addIceCandidate
   * @param  {RTCIceCandidate} candidate
   * @param  {Object} [options]
   * @param  {string} [options.label] The Peer to perform the operation on.
   * @return {Promise}
   */
  addIceCandidate(candidate, options = {}) {
    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
      }

      peer.addIceCandidate(candidate).then(resolve).catch(reject);
    });
  }

  /**
   * End the Session.
   * @method end
   */
  end() {
    const peer = this.peerManager.get(this.peerId);
    if (peer) {
      peer.close();
    }
    this.emit('session:ended', this.id);
  }

  /**
   * Removes specified Track objects from the Session.
   * @method removeTrack
   * @param  {Array} trackIds List of IDs of Track objects to remove.
   */
  removeTracks(trackIds) {
    const peer = this.peerManager.get(this.peerId);
    if (peer) {
      trackIds.forEach(trackId => {
        if (this.localTracks.findIndex(track => track.id === trackId) > -1) {
          peer.removeTrack(trackId);
        }
      });
    }
  }

  /**
   * Send DTMF tones on specified Track object from the Session.
   * @method sendDTMF
   * @param {Object} options The DTMF options.
   * @param {string} options.tone DTMF tone to send. Valid values are [0,1,2,3,4,5,6,7,8,9,#].
   * @param {number} [options.duration=100] The amount of time, in milliseconds, that each DTMF tone should last.
   * @param {number} [options.intertoneGap=70] The length of time, in milliseconds, to wait between tones.
   * @param {Object} [sendOptions] The send options.
   * @param {func} [sendOptions.callback] Optional callback for tone event .
   * @param {string} [sendOptions.trackId] The trackId of the sender to use.
   * @return {boolean} The success or fail indicator
   */
  sendDTMF(DTMFOptions, sendOptions = {}) {
    const peer = this.peerManager.get(this.peerId);
    if (peer) {
      return peer.sendDTMF(DTMFOptions, sendOptions);
    } else {
      return false;
    }
  }

  /**
   * Retrieve RTCStatsReport from a sender.
   * @method getStats
   * @param  {string} trackId The track id associated with a sender.
   * @return {Promise}
   */
  getStats(trackId) {
    return new _promise2.default((resolve, reject) => {
      const peer = this.peerManager.get(this.peerId);
      if (!peer) {
        reject(new Error(`Peer not found in Session ${this.id}.`));
        return;
      }
      peer.getStats(trackId).then(resolve).catch(reject);
    });
  }
}
exports.default = Session;

// SDP Helpers.

/***/ }),

/***/ "../webrtc/src/models/track.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _eventemitter = __webpack_require__("../../node_modules/eventemitter3/index.js");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _utils = __webpack_require__("../webrtc/src/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wrapper class for a native MediaStreamTrack object.
 * Ref: https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack
 * @class Track
 */
class Track extends _eventemitter2.default {
  constructor(mediaTrack, mediaStream) {
    super();
    this.id = mediaTrack.id;
    this.track = mediaTrack;
    this.stream = mediaStream;
    this.containers = [];
    this.constraints = {};

    /**
     * When a track ends, the Track itself doesn't do anything about it.
     * It "bubbles" the event up to be handled at a higher level.
     */
    this.track.onended = event => {
      _loglevel2.default.debug('Event emitted: ', event);
      this.emit('ended', this.track.id);
    };
  }

  /**
   * Retrieve a snapshot of the Track object's current state.
   * @method getState
   * @return {Object}
   */
  getState() {
    return {
      id: this.id,
      streamId: this.stream.id,
      kind: this.track.kind,
      label: this.track.label,
      muted: !this.track.enabled,
      disabled: this.track.muted,
      state: this.track.readyState,
      containers: this.containers.map(element => element.id)
    };
  }

  /**
   * Renders this Track as a subelement of the specified element.
   * @method renderIn
   * @param  {HTMLElement} element The DOM element to be rendered in.
   * @param  {String} [speakerId] The device ID to be used for audio output.
   */
  renderIn(element, speakerId) {
    if (this.containers.indexOf(element) > -1) {
      // Already rendered in element.
      _loglevel2.default.debug(`Track ${this.id} already rendered in element.`, element);
      return;
    }

    this.containers.push(element);

    let type = this.track.kind;
    let renderer = document.createElement(type);

    // Make id safe for css (Firefox ids come wrapped in curly braces)
    // This makes it easier to do other manipulation on the rendering side
    // as we don't need to escape curly braces when doing element.querySelector (See removeFrom).
    renderer.id = `${type}-${(0, _utils.makeSafeForCSS)(this.id)}`;
    renderer.style.height = '100%';
    renderer.style.width = '100%';

    try {
      renderer.srcObject = this.stream;
    } catch (error) {
      _loglevel2.default.debug('srcObject property not supported; reverting to createObjectURL.');
      // TODO: AdapterJS handles this, we should remove this.
      renderer.src = window.URL.createObjectURL(this.stream);
    }

    renderer.autoplay = 'true';

    if (type === 'video') {
      renderer.muted = 'true';
      // Needed for Android.
      renderer.play().catch(err => _loglevel2.default.error(`video tag (#${renderer.id}) - play() - ${err}`));
    }

    // Set speaker if it was provided and it's supported.
    if (speakerId && typeof renderer.setSinkId !== 'undefined') {
      // TODO: Better then/catch handling.
      renderer.setSinkId(speakerId).then(() => {
        _loglevel2.default.debug('Set to use speaker: ', speakerId);
      }).catch(error => {
        _loglevel2.default.debug('Could not set speaker to use. ' + speakerId, error);
      });
    }

    element.appendChild(renderer);

    // TODO: Emit event to notify of changes?
    return true;
  }

  /**
   * Stop rendering this Track from the specified element.
   * @method removeFrom
   * @param  {HTMLElement} element The DOM element to be removed from.
   */
  removeFrom(element) {
    let index = this.containers.indexOf(element);
    if (index === -1) {
      // Not rendered in element.
      _loglevel2.default.debug(`Track ${this.id} not rendered in element.`, element);
      return;
    }
    this.containers.splice(index, 1);

    // TODO: This id may not be unique.
    // Make id safe for css (Firefox ids come wrapped in curly braces)
    // This makes it easier to do other manipulation on the rendering side
    // as we don't need to escape curly braces when doing element.querySelector.
    let rendererId = `${this.track.kind}-${(0, _utils.makeSafeForCSS)(this.id)}`;
    const renderer = element.querySelector(`#${rendererId}`);

    if (renderer.srcObject) {
      renderer.srcObject = null;
    } else if (renderer.src) {
      renderer.src = null;
    }
    element.removeChild(renderer);

    // TODO: Emit event to notify of changes?
    return true;
  }

  /**
   * Moves the rendered track to only the specified element.
   * @method moveTo
   * @param  {HTMLElement} element The DOM element to be moved to.
   */
  moveTo(element) {
    // Iterate over the array backwards since `removeFrom` changes the length
    //    of the array. This ensures that indexes aren't skipped.
    for (let i = this.containers.length; i > 0; i--) {
      this.removeFrom(this.containers[i - 1]);
    }
    this.renderIn(element);
  }

  /**
   * Clean-up the Track by removing it wherever it is rendered and stopping the
   *    track itself.
   * @method cleanup
   */
  cleanup() {
    // Iterate over the array backwards since `removeFrom` changes the length
    //    of the array. This ensures that indexes aren't skipped.
    for (let i = this.containers.length; i > 0; i--) {
      this.removeFrom(this.containers[i - 1]);
    }
    // Stop the track if it isn't already stopped.
    if (this.track.readyState === 'live') {
      this.stop();
    }
  }

  /**
   * Set this Track to be disabled and disallow the Track to render the source stream.
   * @method mute
   */
  mute() {
    this.track.enabled = false;
  }

  /**
   * Set this Track to be enabled and allow the Track to render the source stream.
   * @method unmute
   */
  unmute() {
    this.track.enabled = true;
  }

  /**
   * Calls native stop() function to deassociate the source and the track.
   * @method stop
   */
  stop() {
    this.track.stop();
    /**
     * Treat stopping the track the same as it being ended.
     * Noramlly, onended is not triggered when `stop` is called, only when it is
     *    "remotely ended".
     */
    this.track.onended();
  }

  /**
   * Gets the currently set constraints for the track.
   * @method getConstraints
   * @return {Object}
   */
  getConstraints() {
    return this.constraints;
  }

  /**
   * Set the values for constrainable properties of the track.
   * @method applyConstraints
   * @param  {Object} constraints The list of constrainable properties.
   */
  setConstraints(constraints) {
    this.constraints = constraints;
  }

  /**
   * Retrieves the list of containers where the Track is rendered.
   * @method getContainers
   * @return {Array} List of HTMLElements.
   */
  getContainers() {
    return this.containers;
  }
}
exports.default = Track; // Libraries.

/***/ }),

/***/ "../webrtc/src/sdpUtils/handlers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__("../../node_modules/babel-runtime/core-js/object/values.js");

var _values2 = _interopRequireDefault(_values);

exports.removeTrickleIce = removeTrickleIce;
exports.removeBundling = removeBundling;
exports.changeMediaDirection = changeMediaDirection;
exports.setDtlsSetupToPassiveIfInitialOfferrer = setDtlsSetupToPassiveIfInitialOfferrer;

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _constants = __webpack_require__("../webrtc/src/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SDP handler to remove the trickle ICE option from media groups.
 * Modifies the SDP so it claims to not support trickle ICE.
 * @method removeTrickleIce
 * @param  {Object} sdp
 * @param  {Object} info
 * @param  {String} info.type
 * @param  {String} info.endpoint
 * @param  {Object} originalSdp
 * @return {Object}
 */
// Libraries.
function removeTrickleIce(sdp, info, originalSdp) {
  sdp.media.forEach(media => {
    if (media.iceOptions === 'trickle') {
      _loglevel2.default.debug(`Removing trickle ICE option from ${media.type} media.`);
      delete media.iceOptions;
    }
  });

  return sdp;
}

/**
 * SDP handler to delete the bundle groupings line from the SDP.
 * PeerConnections do not have an option to completely disable bundling, so
 *    manually removing the line from the SDP is needed to prevent bundling.
 * @method removeBundling
 * @param  {Object}     sdp           The session description.
 * @param  {Object}     info          Information about the session description.
 * @param  {RTCSdpType} info.type     The session description's type.
 * @param  {String}     info.endpoint Which end of the connection created the SDP.
 * @param  {Object}     originalSdp   The original SDP before any modifications.
 * @return {Object}
 */


// Constants.
function removeBundling(sdp, info, originalSdp) {
  if (sdp.groups) {
    delete sdp.groups;
  }

  return sdp;
}

/**
 * Currying function to create an SDP handler.
 * The SDP handler modifies the SDP to change the direction of media.
 * @method changeMediaDirection
 * @param  {Object} mediaDirections
 * @param  {string} [audio] Direction to set for audio.
 * @param  {string} [video] Direction to set for video.
 * @return {Function} SDP handler.
 */
function changeMediaDirection({ audio, video }) {
  function isValid(direction) {
    return (0, _values2.default)(_constants.MEDIA_DIR).includes(direction);
  }

  /**
   * SDP handler to change the direction of media a-lines.
   */
  return (sdp, info, originalSdp) => {
    sdp.media.forEach(media => {
      if (media.type === 'audio' && isValid(audio)) {
        media.direction = audio;
      } else if (media.type === 'video' && isValid(video)) {
        media.direction = video;
      }
    });
    return sdp;
  };
}

/**
 * Sets the DTLS setup to passive if it is active and if the following conditions hold:
 *  - This session initiated the call with the first offer.
 *  - We created the SDP.
 *  - We are answering an offer.
 * @param {Object} newSdp The sdp so far (could have been modified by previous handlers).
 * @param {RTCSdpType} info Information about the session description.
 * @param {RTCSdpType} info.type The session description's type.
 * @param {string} info.endpoint Which end of the connection created the SDP.
 * @param {boolean} info.isInitiator Whether this session initiated the call or not.
 * @param {Object} originalSdp The sdp in its initial state.
 */
function setDtlsSetupToPassiveIfInitialOfferrer(newSdp, info, originalSdp) {
  // Hack: If we are the initial offerrer, we created the sdp, and we're answering,
  //  we need to set DTLS setup to passive if it's active.
  if (info.isInitiator && info.endpoint === 'local' && info.type === 'answer') {
    for (let mLine of newSdp.media) {
      if (mLine.setup && mLine.setup === 'active') {
        mLine.setup = 'passive';
      }
    }
  }
  return newSdp;
}

/***/ }),

/***/ "../webrtc/src/sdpUtils/pipeline.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _freeze = __webpack_require__("../../node_modules/babel-runtime/core-js/object/freeze.js");

var _freeze2 = _interopRequireDefault(_freeze);

exports.runPipeline = runPipeline;

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _sdpTransform = __webpack_require__("../../node_modules/sdp-transform/lib/index.js");

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Basic SDP pipeline runner.
 * Does not include any default handlers.
 * @method sdpPipeline
 * @param  {Array}      handlers       List of functions that transform the SDP.
 * @param  {String}     sdp            The session description.
 * @param  {RTCSdpType} info           Information about the session description.
 * @param  {RTCSdpType} info.type      The session description's type.
 * @param  {String}     info.endpoint  Which end of the connection created the SDP.
 * @param  {Boolean}    info.isInitiator Whether this session initiated the connection or not.
 * @return {String}     The modified session description.

 */
function runPipeline(handlers, sdp, info) {
  let objectSdp = _sdpTransform2.default.parse(sdp);

  const originalSdp = (0, _freeze2.default)(objectSdp);
  let newSdp = (0, _fp.cloneDeep)(originalSdp);

  if ((0, _fp.isArray)(handlers)) {
    handlers.forEach(handler => {
      if ((0, _fp.isFunction)(handler)) {
        newSdp = handler(newSdp, info, originalSdp);
      } else {
        _loglevel2.default.error(`SDP handler not a function; skipping.`);
      }
    });
  }

  return _sdpTransform2.default.write(newSdp);
}

/**
 * Create an instance of the SDP pipeline.
 * Allows for persistent SDP handlers to be set and implictly used.
 * @method createPipeline
 * @return {Object} An SDP pipeline.
 */
// Libraries.
function createPipeline() {
  /**
   * SDP handlers that should be included with every pipeline run.
   * @type {Array}
   */
  let defaultHandlers = [];

  /**
   * Use the pipeline to process an SDP.
   * @method run
   * @param  {Array}      handlers      List of functions that transform the SDP.
   * @param  {String}     sdp           The session description.
   * @param  {RTCSdpType} info          Information about the session description.
   * @param  {RTCSdpType} info.type     The session description's type.
   * @param  {String}     info.endpoint Which end of the connection created the SDP.
   * @return {String}     The modified session description.
   */
  function run(handlers = [], sdp, info) {
    return runPipeline(handlers.concat(defaultHandlers), sdp, info);
  }

  /**
   * Set the SDP handlers that should be included with every pipeline run.
   * @method setHandlers
   * @param  {Array} handlers List of SDP handler functions.
   */
  function setHandlers(handlers) {
    if ((0, _fp.isArray)(handlers)) {
      defaultHandlers = defaultHandlers.concat(handlers);
    }
  }

  /**
   * Get the SDP handlers that are included with every pipeline run.
   * @method getHandlers
   * @return {Array} List of SDP handler functions.
   */
  function getHandlers() {
    return defaultHandlers;
  }

  return {
    run,
    setHandlers,
    getHandlers
  };
}

// Export an instance of the pipeline to be used by everything.
exports.default = createPipeline();

/***/ }),

/***/ "../webrtc/src/sdpUtils/sdpSemantics.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUnifiedPlan = isUnifiedPlan;
exports.getSdpSemanticsList = getSdpSemanticsList;

var _constants = __webpack_require__("../webrtc/src/constants.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Checks whether the current sdp semantics is unified-plan
 * @method isUnifiedPlan
 * @param {String} sdpSemantics The current sdp semantics being used
 * @return {Boolean}
 */
function isUnifiedPlan(sdpSemantics) {
  return sdpSemantics === _constants.PEER.SDP_SEMANTICS.UNIFIED_PLAN;
}

/**
 * Generates a list of sdp semantics.
 * @method getSdpSemanticsList
 * @return {Array}
 */
function getSdpSemanticsList() {
  return (0, _fp.values)(_constants.PEER.SDP_SEMANTICS);
}

/***/ }),

/***/ "../webrtc/src/sdpUtils/transceiverUtils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTransceiverDirection = setTransceiverDirection;

var _constants = __webpack_require__("../webrtc/src/constants.js");

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets a transceiver's direction.
 * Checks that the desired direction is a valid one.
 * @method setTransceiverDirection
 * @param {Object} transceiver The transceiver that we want to modify.
 * @param {String} targetDirection The desired direction we want to change to.
 * @return {Boolean} Indicator on whether the transceiver direction was successfully changed.
 */
function setTransceiverDirection(transceiver, targetDirection) {
  if (!(0, _fp.includes)(targetDirection, (0, _fp.values)(_constants.MEDIA_DIR))) {
    _loglevel2.default.info(`Invalid direction "${targetDirection}"`);
    return false;
  }

  // Only in Safari:
  //  - has transceiver.setDirection
  //  - transceiver.direction is readOnly
  if (transceiver.setDirection) {
    transceiver.setDirection(targetDirection);
  } else {
    transceiver.direction = targetDirection;
  }
  return true;
}

/***/ }),

/***/ "../webrtc/src/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeValues = mergeValues;
exports.makeSafeForCSS = makeSafeForCSS;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

// TODO: This function was copied from Kandy, we should eventually create a common project that
// can contain all of these utils that are useful in multiple packages.

/**
 * Deeply merges the values of multiple objects. Objects on the left receive the values from objects on their right.
 * Unlike lodash's default merge behavior this doesn't merge arrays.
 *
 * @name mergeValues
 * @param {...Object} objects - Objects to merge
 * @return {Object} A new object containing the merged values.
 */
function mergeValues(...objects) {
  return (0, _fp.mergeAllWith)((leftValue, rightValue) => {
    // Overwrite the default behavior of lodash's merge for arrays and simply
    // clobber what's on the left so we don't end up with merged arrays.
    if ((0, _fp.isArray)(leftValue)) {
      return rightValue;
    }
  }, objects);
}

function makeSafeForCSS(name) {
  if (!name) {
    return name;
  } else {
    return name.replace(/[^a-z0-9]/g, '');
  }
}

/***/ }),

/***/ "./node_modules/query-string/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const strictUriEncode = __webpack_require__("./node_modules/strict-uri-encode/index.js");
const decodeComponent = __webpack_require__("../../node_modules/decode-uri-component/index.js");

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return (key, value, index) => {
				return value === null ? [
					encode(key, options),
					'[',
					index,
					']'
				].join('') : [
					encode(key, options),
					'[',
					encode(index, options),
					']=',
					encode(value, options)
				].join('');
			};
		case 'bracket':
			return (key, value) => {
				return value === null ? [encode(key, options), '[]'].join('') : [
					encode(key, options),
					'[]=',
					encode(value, options)
				].join('');
			};
		default:
			return (key, value) => {
				return value === null ? encode(key, options) : [
					encode(key, options),
					'=',
					encode(value, options)
				].join('');
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};
		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function extract(input) {
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parse(input, options) {
	options = Object.assign({decode: true, arrayFormat: 'none'}, options);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof input !== 'string') {
		return ret;
	}

	input = input.trim().replace(/^[?#&]/, '');

	if (!input) {
		return ret;
	}

	for (const param of input.split('&')) {
		let [key, value] = param.replace(/\+/g, ' ').split('=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : decode(value, options);

		formatter(decode(key, options), value, ret);
	}

	return Object.keys(ret).sort().reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (obj, options) => {
	if (!obj) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none'
	}, options);

	const formatter = encoderForArrayFormat(options);
	const keys = Object.keys(obj);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = obj[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			const result = [];

			for (const value2 of value.slice()) {
				if (value2 === undefined) {
					continue;
				}

				result.push(formatter(key, value2, result.length));
			}

			return result.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (input, options) => {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return {
		url: input.split('?')[0] || '',
		query: parse(extract(input), options)
	};
};


/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);


/***/ }),

/***/ "./src/auth/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Possible subscription states.
 * @type {Object}
 */
const SUBSCRIPTION_STATE = exports.SUBSCRIPTION_STATE = {
  FULL: 'FULL',
  PARTIAL: 'PARTIAL',
  NONE: 'NONE'
};

/***/ }),

/***/ "./src/auth/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = authCpaas2;

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _events = __webpack_require__("./src/auth/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _interface = __webpack_require__("./src/auth/interface/index.js");

var _actions2 = __webpack_require__("./src/config/interface/actions.js");

var _utils = __webpack_require__("./src/common/utils.js");

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Utilities.


// The interface to follow.
// Redux-Saga
const log = (0, _logs.getLogManager)().getLogger('AUTH');

/**
 * Configuration options for the Authentication feature.
 * @public
 * @name config.authentication
 * @memberof config
 * @instance
 * @param {Object} authentication Authentication configs.
 * @param {Object} authentication.server Information for how to reach the platform.
 * @param {string} authentication.server.base Server to be used for requests.
 * @param {string} [authentication.server.protocol=https] Protocol to be used for requests.
 * @param {Number} [authentication.server.port=443] Port to be used for requests.
 * @param {string} [authentication.server.version=v1] Version of the REST API to be used.
 * @param {string} authentication.clientCorrelator Unique ID for the client. This is required by the platform to identify an instance of the application used by the specific device.
 */

/**
 * CPaaS authentication implementation factory.
 * @method authCpaas
 * @param {Object} options - Configuration options for authentication. See above.
 * @return {Object} plugin - An authentication plugin.
 */


/**
 * selector for exposed authentication state
 */


// State setters.

// Events
function authCpaas2(options = {}) {
  const defaultOptions = {
    server: {
      protocol: 'https',
      base: undefined,
      version: 'v1',
      port: '443'
    },
    clientCorrelator: undefined
  };

  options = (0, _utils.mergeValues)(defaultOptions, options);

  if (!options.server.base || !options.clientCorrelator) {
    log.error('Missing required configurations. Please provide proper authentication configurations.');
  }

  function* init() {
    // Send the provided options to the store.
    // This will be `state.config[name]`.
    yield (0, _effects.put)((0, _actions2.update)(options, _interface.name));
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));
  }

  const capabilities = ['cpaas2auth'];

  return {
    capabilities,
    init,
    api: _interface.api,
    selector: _selectors.getExposedState,
    reducer: _interface.reducer,
    name: _interface.name
  };
}

/***/ }),

/***/ "./src/auth/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/';

const CONNECT = exports.CONNECT = prefix + 'CONNECT';
const CONNECTION_OCCURRED = exports.CONNECTION_OCCURRED = prefix + 'CONNECTION_OCCURRED';
const CONNECT_FINISHED = exports.CONNECT_FINISHED = prefix + 'CONNECT_FINISHED';
const GET_USER_DETAILS = exports.GET_USER_DETAILS = prefix + 'GET_USER_DETAILS';
const USER_DETAILS_RECEIVED = exports.USER_DETAILS_RECEIVED = prefix + 'USER_DETAILS_RECEIVED';
const DISCONNECT = exports.DISCONNECT = prefix + 'DISCONNECT';
const DISCONNECT_FINISHED = exports.DISCONNECT_FINISHED = prefix + 'DISCONNECT_FINISHED';
const RESUBSCRIPTION_FINISHED = exports.RESUBSCRIPTION_FINISHED = prefix + 'RESUBSCRIPTION_FINISHED';
const REFRESH_TOKENS = exports.REFRESH_TOKENS = prefix + 'REFRESH_TOKENS';
const REFRESH_TOKENS_FINISHED = exports.REFRESH_TOKENS_FINISHED = prefix + 'REFRESH_TOKENS_FINISHED';

const UPDATE_SUBSCRIPTION = exports.UPDATE_SUBSCRIPTION = prefix + 'UPDATE_SUBSCRIPTION';
const UPDATE_SUBSCRIPTION_FINISH = exports.UPDATE_SUBSCRIPTION_FINISH = prefix + 'UPDATE_SUBSCRIPTION_FINISH';

const SET_TOKEN = exports.SET_TOKEN = prefix + 'SET_TOKEN';

/***/ }),

/***/ "./src/auth/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = connect;
exports.connectionOccured = connectionOccured;
exports.connectFinished = connectFinished;
exports.getUserDetails = getUserDetails;
exports.userDetailsReceived = userDetailsReceived;
exports.disconnect = disconnect;
exports.disconnectFinished = disconnectFinished;
exports.resubscribeFinished = resubscribeFinished;
exports.refreshTokens = refreshTokens;
exports.refreshTokensFinished = refreshTokensFinished;
exports.updateSubscription = updateSubscription;
exports.updateSubscriptionFinished = updateSubscriptionFinished;
exports.setTokens = setTokens;

var _actionTypes = __webpack_require__("./src/auth/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Creates a connect action that takes a credentials object.
 *
 * @method connect
 * @param {Object} credentials The credentials to pass to the connect action.
 * @return {Object} A flux standard action.
 */
function connect(credentials) {
  return {
    type: actionTypes.CONNECT,
    payload: { credentials },
    meta: {
      isSensitive: true
    }
  };
}

/**
 * Connection Occured action.
 * Signifies that a connection has been made to a service, but that the connection
 *      workflow has not finished yet. Intended for use in scenarios where the
 *      workflow connects to multiple services, to represent the "intermediate"
 *      connections.
 *
 * @method connectionOccured
 * @param  {Object} $0
 * @param  {Object} $0.subscription
 * @param  {Object} $0.connection
 * @param  {Object} [$0.error] An error message. Only present if an error occured.
 * @param  {string} platform The backend platform used for the connection.
 * @return {Object} A flux standard action.
 */
function connectionOccured({ subscription, connection, error }, platform) {
  var action = {
    type: actionTypes.CONNECTION_OCCURRED,
    meta: { platform }
  };

  if (error) {
    action.error = true;
    action.payload = error;
  } else {
    action.payload = { subscription, connection };
  }

  return action;
}

/**
 * Create a connect finished action that takes a userInfo object on success and possibly
 * an error object.
 *
 * @method connectFinished
 * @param {Object} $0
 * @param {Object} $0.subscription A subscription object. Contains what services to subscribe to.
 * @param {Object} $0.userInfo An object representing the user information.
 * @param {Object} $0.connection A connection object. Information about how to connect to the backend services.
 * @param {string} [$0.error] An error message. Only present if an error occured.
 * @param {string} platform The backend platform we are currently on.
 * @param {boolean} isSSO Boolean for whether the current connection scenario is SSO or not.
 * @return {Object} A flux standard action.
 */
function connectFinished({ subscription, userInfo, connection, error }, platform, isSSO = false) {
  var action = {
    type: actionTypes.CONNECT_FINISHED,
    meta: {
      platform,
      isSSO,
      isSensitive: true
    }
  };

  if (error) {
    action.error = true;
    action.payload = error;
  } else {
    action.payload = { subscription, userInfo, connection };
  }

  return action;
}

/**
 * Creates a getUserDetails action
 *
 * @method getUserDetails
 * @return {Object} A flux standard action.
 */
function getUserDetails() {
  return { type: actionTypes.GET_USER_DETAILS };
}

/**
 * Create a user details received action
 *
 * @method userDetailsReceived
 * @param  {Object} userDetailsResponse An object representing the REST response of a user details request.
 * @return {Object} A flux standard action.
 */
function userDetailsReceived(userDetailsResponse) {
  var action = {
    type: actionTypes.USER_DETAILS_RECEIVED,
    payload: {
      firstName: userDetailsResponse.firstName || userDetailsResponse.user_first_name,
      user_first_name: userDetailsResponse.user_first_name || userDetailsResponse.firstName,
      lastName: userDetailsResponse.lastName || userDetailsResponse.user_last_name,
      user_last_name: userDetailsResponse.user_last_name || userDetailsResponse.lastName,
      photoURL: userDetailsResponse.photoURL,
      emailAddress: userDetailsResponse.emailAddress || userDetailsResponse.user_email,
      user_email: userDetailsResponse.user_email || userDetailsResponse.emailAddress,
      username: userDetailsResponse.username
    }
  };

  return action;
}

/**
 * Creates a disconnect action.
 *
 * @method disconnect
 * @return {Object} A flux standard action.
 */
function disconnect() {
  return { type: actionTypes.DISCONNECT };
}

/**
 * Create a disconnectFinished action that possibly takes an error object on failure.
 *
 * @method disconnectFinished
 * @param {Object} $0
 * @param {string} [$0.error] An error message. Only present if an error occurred.
 * @param {Boolean} [$0.forced] Whether the disconnect was forcefully disconnected.
 * @return {Object} A flux standard action.
 */
function disconnectFinished({ error, forced } = {}) {
  var action = {
    type: actionTypes.DISCONNECT_FINISHED,
    payload: {}
  };

  if (error) {
    action.error = true;
    action.payload = error;
  }
  action.payload.forced = forced;

  return action;
}

/**
 * Action creator representing the finish of a resubscription request.
 * Payload mirrors a connect finished action.
 *
 * @method resubscribeFinished
 * @param {Object} $0
 * @param {string} [$0.error] An error message. Only present if an error occured.
 * @param {string} [$0.attemptNum] The attempt number of this resubscription.
 * @param {string} platform The backend platform we are currently on.
 * @return {Object} A flux standard action.
 */
function resubscribeFinished({ error, attemptNum }, platform) {
  var action = {
    type: actionTypes.RESUBSCRIPTION_FINISHED,
    meta: { platform }
  };

  if (error) {
    action.error = true;
    action.payload = error;
    action.payload.attemptNum = attemptNum;
  } else {
    action.payload = {
      attemptNum
    };
  }

  return action;
}

/**
 * Creates a refreshTokens action with the given credentials as a payload.
 *
 * @method refreshTokens
 * @param {Object} credentials A crendetials object containing tokens.
 * @return {Object} A flux standard action.
 */
function refreshTokens(credentials) {
  var action = {
    type: actionTypes.REFRESH_TOKENS,
    payload: { credentials }
  };
  return action;
}

/**
 * Creates a refreshTokensFinished action with connection and platform information.
 * Optionally includes an error.
 *
 * @method refreshTokensFinished
 * @param {Object} $0
 * @param {Object} [$0.error] An optional error object.
 * @param {Object} $0.connection Connection information.
 * @param {string} platform The backend platform we are currently on.
 * @return {Object} A flux standard action.
 */
function refreshTokensFinished({ error, connection }, platform) {
  var action = {
    type: actionTypes.REFRESH_TOKENS_FINISHED,
    payload: { connection },
    meta: { platform }
  };
  if (error) {
    action.error = true;
    action.payload = error;
  }

  return action;
}

/**
 * Represents a request to update a current subscription.
 * @method updateSubscription
 * @param  {Object} subscription Information used to update subscription.
 * @return {Object} A flux standard action.
 */
function updateSubscription(subscription) {
  return {
    type: actionTypes.UPDATE_SUBSCRIPTION,
    payload: subscription
  };
}

/**
 * Represents that the current subscription has been updated.
 * @method updateSubscriptionFinished
 * @param  {Object} $0
 * @param  {Object} $0.subscription New subscription state to be updated.
 * @param  {Object} [$0.error] Error object, in the case of an error.
 * @param  {string} platform The backend platform used for the subscription.
 * @return {Object} A flux standard action.
 */
function updateSubscriptionFinished({ subscription, error }, platform) {
  var action = {
    type: actionTypes.UPDATE_SUBSCRIPTION_FINISH,
    meta: { platform }
  };

  if (error) {
    action.error = true;
    action.payload = error;
  } else {
    action.payload = subscription;
  }
  return action;
}

/**
 * Sets the token information in the state.
 * @method setTokens
 * @param {Object} params Dictionary object of parameters.
 * @param {string} accessToken An access token retrieved using the authentication APIs of the platform.
 * @param {string} idToken An identity token retrieved using the authentication APIs of the platform.
 * @return {Object} A flux standard action.
 */
function setTokens({ accessToken, idToken }) {
  return {
    type: actionTypes.SET_TOKEN,
    payload: { accessToken, idToken }
  };
}

/***/ }),

/***/ "./src/auth/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/auth/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _constants = __webpack_require__("./src/auth/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Authentication API.
 * @method api
 * @param  {Function} $0
 * @param  {Function} $0.dispatch - The redux store's dispatch function.
 * @param  {Function} $0.getState - The redux store's getState function.
 * @return {Object} api - The authentication API object.
 */
function api({ dispatch, getState }) {
  return {
    /**
     * Connect with user credentials.
     *
     * @public
     * @memberof Authentication
     * @requires userCredentialsAuth
     * @method connect
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username including the application's domain.
     * @param {string} credentials.password The user's password.
     * @param {string} [credentials.authname] The user's authorization name.
     * @example
     * client.connect({
     *   username: 'alfred@example.com',
     *   password: '********'
     *   authname: '********'
     * });
     */
    /**
     * Connect with user credentials.
     *
     * @public
     * @memberof Authentication
     * @requires userCredentialsDAKAuth
     * @method connect
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.domainApiKey The Api key for the application's domain.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.password The user's password.
     * @example
     * client.connect({
     *   domainApiKey: 'DAK1111111111111111111',
     *   username: 'alfred',
     *   password: '********'
     * });
     */
    /**
     * Connect by providing an access token. You can optionally provide a refresh token and the SDK will automatically get new access tokens.
     *
     * @public
     * @memberof Authentication
     * @requires accessTokenAuth
     * @method connect
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.accessToken An access token for the user with the provided user Id.
     * @param {string} [credentials.refreshToken] A refresh token for the same user.
     * @param {number} [credentials.expires] The time in seconds until the access token will expire.
     * @example
     * client.connect({
     *   username: 'alfred@example.com',
     *   accessToken: 'AT0V1fswAiJadokx1iJMQdG04pRf',
     *   refreshToken: 'RTG9SV3QAoJaeUSEQCZAHqrhde1yT',
     *   expires: 3600
     * });
     */
    /**
     * Connect by providing a refresh token.
     *
     * @public
     * @memberof Authentication
     * @requires accessTokenAuth
     * @method connect
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.refreshToken A refresh token for the same user.
     * @param {number} [credentials.expires] The time in seconds until the access token will expire.
     * @example
     * client.connect({
     *   username: 'alfred@example.com',
     *   refreshToken: 'RTG9SV3QAoJaeUSEQCZAHqrhde1yT'
     *   expires: 3600
     * });
     */
    /**
     * Connect by providing an OAuth token.
     *
     * @public
     * @memberof Authentication
     * @requires oauthToken
     * @method connect
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.oauthToken An OAuth token provided by an outside service.
     * @example
     * client.connect({
     *   username: 'alfred@example.com',
     *   oauthToken: 'RTG9SV3QAoJaeUSEQCZAHqrhde1yT'
     * });
     */
    connect(credentials) {
      dispatch(actions.connect(credentials));
    },

    /**
     * Disconnects from the backend. This will close the websocket and you will stop receiving events.
     *
     * @public
     * @requires userCredentialsAuth
     * @requires userCredentialsDAKAuth
     * @requires accessTokenAuth
     * @memberof Authentication
     * @method disconnect
     */
    disconnect() {
      dispatch(actions.disconnect());
    },

    /**
     * If you're authenticating with tokens that expire and have not provided a refresh token to the `connect` function, you can update your access token with `updateToken` before it expires to stay connected.
     *
     * @public
     * @memberof Authentication
     * @requires accessTokenAuth
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.accessToken The new access token.
     * @method updateToken
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.accessToken An access token for the user with the provided user Id.
     */
    /**
     * If you're authenticating with tokens that expire and have not provided a refresh token to the `connect` function, you can update your access token with `updateToken` before it expires to stay connected.
     *
     * @public
     * @memberof Authentication
     * @requires oauthToken
     * @method updateToken
     * @param {Object} credentials The credentials object.
     * @param {string} credentials.username The username without the application's domain.
     * @param {string} credentials.oauthToken An OAuth token provided by an outside service.
     * @example
     * client.updateToken({
     *   username: 'alfred@example.com',
     *   oauthToken: 'RTG9SV3QAoJaeUSEQCZAHqrhde1yT'
     * });
     */
    updateToken(credentials) {
      dispatch(actions.refreshTokens(credentials));
    },

    /**
     * Updates the current connection.
     *
     * @public
     * @memberof Authentication
     * @requires updateConnection
     * @method updateConnection
     * @param {Object} connection
     * @param {Array} connection.services Services to subscribe to for notifications.
     * @example
     * client.updateConnection({
     *   services: ['IM', 'Presence', 'call']
     * })
     */
    updateConnection(connection) {
      dispatch(actions.updateSubscription(connection));
    },

    /**
     * Retrieves information about the current user.
     *
     * @public
     * @memberof Authentication
     * @method getUserInfo
     * @returns {Object} user The user data.
     * @returns {string} user.username The username of the current user. Note that this username can take different encoded forms.
     *                                 It's not meant to be displayed to a user.
     * @returns {string} user.token The current access token.
     */
    getUserInfo() {
      return (0, _selectors.getUserInfo)(getState());
    },

    /**
     * Get the connection state.
     *
     * @public
     * @memberof Authentication
     * @requires connect
     * @method getConnection
     * @returns {Object} connection The connection state.
     * @returns {boolean} connection.isConnected Whether the authenticated user is currently connected.
     * @returns {boolean} connection.isPending Whether the authenticated user's connection is currently pending.
     * @returns {Object} connection.error The error object if an error occured.
     * @returns {string} connection.error.message The error message.
     * @returns {string} connection.error.stack The stack trace of the error.
     */
    getConnection() {
      const { isConnected, isPending, error } = getState().authentication;
      return {
        isConnected,
        isPending,
        error,
        subscription: (0, _selectors.getServices)(getState())
      };
    },

    /**
     * Retrieves the services that the user is subscribed for.
     *
     * @public
     * @memberof Authentication
     * @requires services
     * @method getServices
     * @return {Array} A list of subscribed-to services.
     */
    getServices() {
      return (0, _selectors.getServices)(getState());
    },

    /**
     * Possible subscription states of the user.
     *
     * @public
     * @memberof Authentication
     * @requires connect
     * @property {string} FULL All requested feature subscriptions exist.
     * @property {string} PARTIAL Some feature subscriptions exist.
     * @property {string} NONE No feature subscriptions exist.
     */
    subscriptionStates: _constants.SUBSCRIPTION_STATE,

    /**
     * Sets the authentication tokens necessary to make requests to the platform. The access token
     * provided establishes what can be accessed by the SDK. The identity token represents who is authenticated.
     *
     * @public
     * @memberof Authentication
     * @requires cpaas2auth
     * @method setTokens
     * @param {Object} params Dictionary object of parameters.
     * @param {string} params.accessToken An access token retrieved using the authentication APIs of the platform.
     * @param {string} params.idToken An identity token retrieved using the authentication APIs of the platform.
     * @example
     * client.setTokens({
     *   accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
     *   idToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
     * })
     */
    setTokens({ accessToken, idToken }) {
      dispatch(actions.setTokens({ accessToken, idToken }));
    }
  };
} /**
   * The authentication feature allows for setting authentication token which will be used for all communications
   * with the platform. Authentication is used by all other features for
   * fulfilling requests made to the backend server.
   * @public
   * @requires cpaas2auth
   * @module Authentication
   */

/**
 * The authentication feature handles connecting and disconnecting from any
 * backend services that the SDK deals with. As well, it handles and stores
 * authentication information on the behalf of the user. This allows the user to
 * interact with the server without worrying about authenticating.
 *
 * @public
 * @requires connect
 * @module Authentication
 */

/***/ }),

/***/ "./src/auth/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Authentication state has changed. You can get the new state by calling `getConnection()`.
 *
 * @public
 * @memberof Authentication
 * @requires connect
 * @event auth:change
 * @param {Object} params
 * @param {boolean} params.forced For a disconnection, whether the change was forced by the system.
 */
const AUTH_CHANGE = exports.AUTH_CHANGE = 'auth:change';

/**
 * There was an error with authentication.
 *
 * @public
 * @memberof Authentication
 * @requires connect
 * @event auth:error
 * @param {Object} params
 * @param {BasicError} params.error The Basic error object.
 *
 */
const AUTH_ERROR = exports.AUTH_ERROR = 'auth:error';

/**
 * An attempt to extend the current user's subscription was made.
 *
 * In a failure scenario, the current user is still connected, and further
 * resubscription attempts will be made, but may become disconnected if the
 * session expires.
 * @public
 * @memberof Authentication
 * @requires connect
 * @event auth:resub
 * @param {Object} params
 * @param {number} params.attemptNum The attempt number of this resubscription.
 * @param {boolean} params.isFailure Whether the resubscription failed or not.
 * @param {BasicError} [params.error] The Basic error object.
 */
const AUTH_RESUB = exports.AUTH_RESUB = 'auth:resub';

/***/ }),

/***/ "./src/auth/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/auth/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/auth/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function authChangedEvent(action) {
  return {
    type: action.error ? eventTypes.AUTH_ERROR : eventTypes.AUTH_CHANGE,
    args: action.error ? { error: action.payload } : {}
  };
}

const eventsMap = {};

eventsMap[actionTypes.CONNECT_FINISHED] = authChangedEvent;
eventsMap[actionTypes.USER_DETAILS_RECEIVED] = authChangedEvent;
eventsMap[actionTypes.CONNECT] = authChangedEvent;
eventsMap[actionTypes.DISCONNECT] = authChangedEvent;
eventsMap[actionTypes.REFRESH_TOKENS_FINISHED] = authChangedEvent;
eventsMap[actionTypes.UPDATE_SUBSCRIPTION_FINISH] = authChangedEvent;

eventsMap[actionTypes.DISCONNECT_FINISHED] = function (action) {
  let discEvent = authChangedEvent(action);
  discEvent.args.forced = action.payload.forced;
  return discEvent;
};

eventsMap[actionTypes.RESUBSCRIPTION_FINISHED] = function (action) {
  let resubEvent = {
    type: eventTypes.AUTH_RESUB,
    args: {
      attemptNum: action.payload.attemptNum,
      isFailure: action.error || false
    }
  };

  if (action.error) {
    resubEvent.args.error = action.payload;
  }
  return resubEvent;
};

exports.default = eventsMap;

/***/ }),

/***/ "./src/auth/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.api = exports.name = exports.reducer = undefined;

var _reducers = __webpack_require__("./src/auth/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

var _name = __webpack_require__("./src/auth/interface/name.js");

var _name2 = _interopRequireDefault(_name);

var _api = __webpack_require__("./src/auth/interface/api.js");

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.reducer = _reducers2.default;
exports.name = _name2.default;
exports.api = _api2.default;

/***/ }),

/***/ "./src/auth/interface/name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This interface is for an authentication plugin.
 * @type {string}
 */
const name = 'authentication';
exports.default = name;

/***/ }),

/***/ "./src/auth/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/auth/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _jwtDecode = __webpack_require__("../../node_modules/jwt-decode/lib/index.js");

var _jwtDecode2 = _interopRequireDefault(_jwtDecode);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

reducers[actionTypes.CONNECT] = {
  next(state) {
    return (0, _extends3.default)({}, state, {
      isPending: true,
      error: undefined
    });
  }
};

reducers[actionTypes.CONNECT_FINISHED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      isConnected: true,
      isPending: false,
      error: undefined,
      isSSO: action.meta.isSSO,
      platform: action.meta.platform,
      // Separate subscription, connection info based on the platform used.
      // Store platform subscription information.
      subscription: (0, _extends3.default)({}, state.subscription, {
        [action.meta.platform]: action.payload.subscription
      }),
      // Store platform connection information to be procided to other plugins.
      connection: (0, _extends3.default)({}, state.connection, {
        [action.meta.platform]: action.payload.connection
      }),
      // Store user information to be provided to developers.
      userInfo: action.payload.userInfo
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isConnected: false,
      isPending: false,
      error: action.payload
    });
  }
};

// On connection occured, store the connection information into state, but do
// not update any status state. The connection has not yet finished.
reducers[actionTypes.CONNECTION_OCCURRED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      // Separate subscription, connection info based on the platform used.
      // Store platform subscription information.
      subscription: (0, _extends3.default)({}, state.subscription, {
        [action.meta.platform]: action.payload.subscription
      }),
      // Store platform connection information to be procided to other plugins.
      connection: (0, _extends3.default)({}, state.connection, {
        [action.meta.platform]: action.payload.connection
      })
    });
  }
};

reducers[actionTypes.DISCONNECT] = {
  next(state) {
    return (0, _extends3.default)({}, state, {
      isPending: true,
      error: undefined
    });
  }
};

reducers[actionTypes.DISCONNECT_FINISHED] = {
  next() {
    return {
      isConnected: false,
      isPending: false,
      error: undefined
    };
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      // Treat an error as if we are still disconnected.
      isConnected: false,
      isPending: false,
      error: action.payload
    });
  }
};

reducers[actionTypes.REFRESH_TOKENS_FINISHED] = {
  next(state, action) {
    // Merge the updated requestOptions into the current state.
    let requestOptions = (0, _fp.merge)(state.connection[action.meta.platform].requestOptions, action.payload.connection.requestOptions);

    return (0, _extends3.default)({}, state, {
      connection: (0, _extends3.default)({}, state.connection, {
        [action.meta.platform]: (0, _extends3.default)({}, state.connection[action.meta.platform], action.payload.connection, {
          requestOptions
        })
      }),
      userInfo: (0, _extends3.default)({}, state.userInfo, {
        accessToken: action.payload.connection.accessToken,
        refreshToken: action.payload.connection.refreshToken
      })
    });
  }
};

/*
 * Updates the subscription information for a specified platform.
 */
reducers[actionTypes.UPDATE_SUBSCRIPTION_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      subscription: (0, _extends3.default)({}, state.subscription, {
        [action.meta.platform]: (0, _extends3.default)({}, state.subscription[action.meta.platform], action.payload)
      })
    });
  }
};

reducers[actionTypes.SET_TOKEN] = {
  next(state, action) {
    // We received an idToken which is a JWT token that represents the identity of
    // the user. This token contains information about the user. For now we only need
    // the username. In the future we might use more from this token.

    const idTokenPayload = (0, _jwtDecode2.default)(action.payload.idToken);

    return (0, _extends3.default)({}, state, {
      userInfo: (0, _extends3.default)({}, state.userInfo, {
        accessToken: action.payload.accessToken,
        username: idTokenPayload.preferred_username
      })
    });
  }
};

/**
 * Auth Interface reducer
 * @method reducer
 * @param  {Object}  state - The current redux state.
 * @param  {Object}  action - A flux standard action.
 * @return {Object}  - The new redux state.
 * @example
 * Auth state structure example; connected.
 * authState = {
 *     isConnected: true,
 *     isPending: false,
 *     error: undefined,
 *     subscription: { ... },
 *     connection: { ... },
 *     userInfo: { ... }
 * }
 */
const reducer = (0, _reduxActions.handleActions)(reducers, {
  isConnected: false,
  isPending: false
});
exports.default = reducer;

/***/ }),

/***/ "./src/auth/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExposedState = getExposedState;
exports.getAuthConfig = getAuthConfig;
exports.getSubscriptionInfo = getSubscriptionInfo;
exports.getConnectionInfo = getConnectionInfo;
exports.getDomain = getDomain;
exports.getUserInfo = getUserInfo;
exports.getAuthScenario = getAuthScenario;
exports.getServices = getServices;
exports.getPlatform = getPlatform;
exports.getRequestInfo = getRequestInfo;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _constants = __webpack_require__("./src/auth/constants.js");

var _constants2 = __webpack_require__("./src/constants.js");

/**
 * Plugin selector function to expose state globally
 * @param  {Object} pluginState The localized (plugin) state
 * @return {Object}             The exposed state
 */
function getExposedState(pluginState) {
  // TODO: Filter out unwanted auth stuff from public state.
  return (0, _fp.cloneDeep)(pluginState);
}

/*
 * Redux-saga selector functions.
 * Used with the `select` effect in sagas to Retrieves
 *      specific portions of the state.
 */

/**
 * Retrieves the config options provided by the auth plugin.
 * @method getAuthConfig
 * @return {Object}
 */
function getAuthConfig(state) {
  return (0, _fp.cloneDeep)(state.config.authentication);
}

/**
 * Retrieves the subscription information of a platform.
 * @method getSubscriptionInfo
 * @param  {string} [platform] - The backend platform in use.
 * @return {Object}
 */
function getSubscriptionInfo(state, platform) {
  if (!platform) {
    platform = getPlatform(state);
  }

  if (state.authentication.subscription) {
    return (0, _fp.cloneDeep)(state.authentication.subscription[platform]);
  } else {
    return undefined;
  }
}

/**
 * Retrieves the connection information of a platform.
 * Includes the info needed to make requests to that platform.
 * @method getConnectionInfo
 * @param  {string} [platform] - The backend platform in use.
 * @return {Object}
 */
function getConnectionInfo(state, platform) {
  if (!platform) {
    platform = getPlatform(state);
  }

  if (state.authentication.connection) {
    return (0, _fp.cloneDeep)(state.authentication.connection[platform]);
  } else {
    return undefined;
  }
}

/**
 * Retrieves the domain of the callee address information of a platform.
 * @method getDomain
 * @return {string}
 */
function getDomain(state) {
  const connection = getConnectionInfo(state);
  return (0, _fp.cloneDeep)(connection.username.substr(connection.username.indexOf('@')));
}

/**
 * Retrieves the user information.
 * @method getUserInfo
 * @return {Object}
 */
function getUserInfo(state) {
  return (0, _fp.cloneDeep)(state.authentication.userInfo) || {};
}

/**
 * Retrieves a flag from the store representing if the login scenario was SSO or not.
 * @method getAuthScenario
 * @return {boolean}
 */
function getAuthScenario(state) {
  return (0, _fp.cloneDeep)(state.authentication.isSSO);
}

/**
 * Retrieves information about the services that the user is subscribed for.
 * @method getServices
 * @return {Object}
 */
function getServices(state, platform) {
  let subscription = getSubscriptionInfo(state, platform);

  if (subscription && subscription.servicesInfo) {
    return subscription.servicesInfo;
  } else {
    return {
      // TODO: Have default as part of the reducer.
      requested: [],
      received: [],
      missing: [],
      status: _constants.SUBSCRIPTION_STATE.NONE,
      services: {}
    };
  }
}

/**
 * Retrieves the name of the backend platform the user is currently subscribed to.
 * @method getPlatform
 * @return {string}
 */
function getPlatform(state) {
  return (0, _fp.cloneDeep)(state.authentication.platform);
}

/**
 * Retrieves info needed to make a REST request for the different platforms.
 * @method getRequestInfo
 * @return {Object}
 */
function getRequestInfo(state, platform) {
  if (!platform) {
    platform = getPlatform(state);
  }

  const { server, subscription, clientCorrelator } = getAuthConfig(state);
  const { userInfo } = (0, _fp.cloneDeep)(state.authentication);
  let requestInfo;
  switch (platform) {
    case _constants2.platforms.CPAAS2:
      requestInfo = {
        baseURL: `${server.protocol}://${server.base}:${server.port}`,
        version: server.version,
        username: userInfo.username,
        // TODO: Token doesn't need to be here if its in requestOptions.
        token: userInfo.accessToken,
        clientCorrelator,
        // TODO: DO NOT hardcode this here (?). The original idea was that this
        //    is set in state after connection.
        options: {
          headers: {
            Accept: 'application/json',
            Authorization: `Bearer ${userInfo.accessToken}`,
            'Content-Type': 'application/json'
          }
        }
      };
      break;
    case _constants2.platforms.CPAAS:
    case _constants2.platforms.LINK:
      requestInfo = {
        baseURL: `${subscription.protocol}://${subscription.server}:${subscription.port}`,
        version: subscription.version,
        username: userInfo.username
      };
      break;
    default:
      return {};
  }

  const connInfo = getConnectionInfo(state, platform);
  if (connInfo && connInfo.requestOptions) {
    requestInfo.requestOptions = connInfo.requestOptions;
  }

  return requestInfo;
}

/***/ }),

/***/ "./src/basePlugins.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _logs = __webpack_require__("./src/logs/index.js");

var _logs2 = _interopRequireDefault(_logs);

var _config = __webpack_require__("./src/config/index.js");

var _config2 = _interopRequireDefault(_config);

var _events = __webpack_require__("./src/events/index.js");

var _events2 = _interopRequireDefault(_events);

var _request = __webpack_require__("./src/request/index.js");

var _request2 = _interopRequireDefault(_request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is a list of base plugins that most solutions will need. These plugins provide service-like capabilities
 * to the SDK.
 */
exports.default = [{ name: 'logs', fn: _logs2.default }, { name: 'config', fn: _config2.default }, { name: 'events', fn: _events2.default }, { name: 'request', fn: _request2.default }];

/***/ }),

/***/ "./src/call/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ICE_MEDIA_STATES = exports.FCS_ICE_MEDIA_STATES = exports.WEBRTC_DEVICE_KINDS = exports.CALL_DIRECTION = exports.OPERATIONS = exports.CALL_MEDIA_STATES = exports.CALL_STATES = exports.CALL_STATES_FCS = exports.FCS_CALL_STATES = undefined;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Helper function. Converts an object so that its keys are the same as its values.
 * @method mapValuesToKeys
 * @param  {Object} source
 * @return {Object}
 */
function mapValuesToKeys(source) {
  return (0, _fp.mapKeys)(function (value) {
    return source[value];
  })(source);
}

/**
 * Enum of FCS call states.
 * Key is the "code" that FCS uses, and value is the text representation.
 * These are taken from FCS callManager.js, but inversed.
 *      See `fcs.call.States`.
 * @type {Object}
 */
const FCS_CALL_STATES = exports.FCS_CALL_STATES = {
  0: 'IN_CALL',
  1: 'ON_HOLD',
  2: 'RINGING',
  3: 'ENDED',
  4: 'REJECTED',
  5: 'OUTGOING',
  6: 'INCOMING',
  7: 'ANSWERING',
  8: 'JOINED',
  9: 'RENEGOTIATION',
  10: 'TRANSFERRED',
  11: 'ON_REMOTE_HOLD',
  12: 'CALL_IN_PROGRESS',
  13: 'EARLY_MEDIA',
  14: 'TRANSFER_FAILURE',
  15: 'REPLACING'

  /**
   * Call states.
   * Same as FCS_CALL_STATES, except both key and value are the text representation.
   * @name CALL_STATES_FCS
   */
};const CALL_STATES_FCS = exports.CALL_STATES_FCS = mapValuesToKeys(FCS_CALL_STATES);

/**
 * Call states
 * Call states used in the cpaas2 and link call plugins
 * @name CALL_STATES
 */
const CALL_STATES = exports.CALL_STATES = {
  INITIATING: 'Initiating',
  INITIATED: 'Initiated',
  RINGING: 'Ringing',
  CANCELLED: 'Cancelled',
  CONNECTED: 'Connected',
  ON_HOLD: 'On Hold',
  ENDED: 'Ended'

  /**
   * Possible states a call's media can be in.
   * Describes whether media is flowing or if an endpoint is preventing media flow.
   * @name CALL_MEDIA_STATES
   * @type {Object}
   * @property {string} CONNECTED Both call endpoints allow for media to flow.
   * @property {string} LOCAL_HOLD Local endpoint disallows media from flowing.
   * @property {string} REMOTE_HOLD Remote endpoint disallows media from flowing.
   * @property {string} DUAL_HOLD Both endpoints disallow media from flowing.
   */
};const CALL_MEDIA_STATES = exports.CALL_MEDIA_STATES = {
  CONNECTED: 'Connected',
  LOCAL_HOLD: 'Local Hold',
  REMOTE_HOLD: 'Remote Hold',
  DUAL_HOLD: 'Dual Hold'

  /**
   * Call operations that require negotiation.
   * @name OPERATIONS
   * @type {Object}
   * @property {string} CHANGE_MEDIA Media flow remains the same, includes non-flow related media changes.
   * @property {string} HOLD_MEDIA   Media flow stops. May include non-flow related media changes.
   * @property {string} UNHOLD_MEDIA Media flow restarts. May include non-flow related media changes.
   * @property {string} MUSIC_ON_HOLD Media flow changes to sendonly.
   */
};const OPERATIONS = exports.OPERATIONS = {
  CHANGE_MEDIA: 'Change Media',
  HOLD_MEDIA: 'Hold Media',
  UNHOLD_MEDIA: 'Unhold Media',
  MUSIC_ON_HOLD: 'Music on hold'

  /**
   * Call direction
   * Indication of which direction the call is going
   * @name CALL_DIRECTION
   */
};const CALL_DIRECTION = exports.CALL_DIRECTION = {
  INCOMING: 'incoming',
  OUTGOING: 'outgoing'

  /*
   * A conversion from MediaDeviceInfo.kind values to their more common terms.
   * See: https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/kind
   */
};const WEBRTC_DEVICE_KINDS = exports.WEBRTC_DEVICE_KINDS = {
  audioinput: 'microphone',
  videoinput: 'camera',
  audiooutput: 'speaker'

  /**
   * Enum of ICE media states.
   * These are taken from FCS call, but inversed.
   *      See `fcs.call.MediaStates`.
   * @name FCS_ICE_MEDIA_STATES
   * @type {Object}
   */
};const FCS_ICE_MEDIA_STATES = exports.FCS_ICE_MEDIA_STATES = {
  0: 'NEW',
  1: 'CHECKING',
  2: 'CONNECTED',
  3: 'COMPLETED',
  4: 'FAILED',
  5: 'DISCONNECTED',
  6: 'CLOSED'

  /**
   * ICE media states.
   * Same as FCS_ICE_MEDIA_STATES, except both key and value are the text representation.
   * @name ICE_MEDIA_STATES
   */
};const ICE_MEDIA_STATES = exports.ICE_MEDIA_STATES = mapValuesToKeys(FCS_ICE_MEDIA_STATES);

/***/ }),

/***/ "./src/call/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cpaas2Calls;

var _interfaceNew = __webpack_require__("./src/call/interfaceNew/index.js");

var _interfaceNew2 = _interopRequireDefault(_interfaceNew);

var _sagas = __webpack_require__("./src/call/cpaas2/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _events = __webpack_require__("./src/call/interfaceNew/events.js");

var _events2 = _interopRequireDefault(_events);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _actions2 = __webpack_require__("./src/config/interface/actions.js");

var _utils = __webpack_require__("./src/callstack/utils/index.js");

var _utils2 = __webpack_require__("./src/common/utils.js");

var _codecRemover = __webpack_require__("../fcs/src/js/sdp/codecRemover.js");

var _codecRemover2 = _interopRequireDefault(_codecRemover);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Configuration options for the call feature.
 * @public
 * @name config.call
 * @memberof config
 * @instance
 * @param {Object} call The call configuration object.
 * @param {Object} [call.iceServers] ICE servers to be used for calls.
 * @param {boolean} [call.serverTurnCredentials=true] Whether server-provided TURN credentials should be used.
 * @param {Array} [call.sdpHandlers] List of SDP handler functions to modify SDP. Advanced usage.
 * @param {boolean} [call.removeH264Codecs=true] Whether to remove "H264" codec lines from incoming and outgoing SDP messages.
 */

// Libraries.


// Helpers.
// Call plugin.
function cpaas2Calls(options = {}) {
  const defaultOptions = {
    // The list of TURN/STUN servers to use.

    // TODO: Remove this default once the CPaaS server configuration feature is implemented. These
    // servers should be sent to us by CPaaS. This default is just here fo ease of use in production.
    iceServers: [{
      url: 'turns:turn-ucc-1.genband.com:443?transport=tcp',
      credential: ''
    }, {
      url: 'turns:turn-ucc-2.genband.com:443?transport=tcp',
      credential: ''
    }],
    // TODO: Remove this once all the browsers use unified-plan
    sdpSemantics: 'unified-plan',
    // Whether the SDK should fetch turn credentials.
    serverTurnCredentials: true,
    // Trickle ICE method to use for calls.
    trickleIceMode: 'NONE',
    // SDP handlers to be included in the pipeline for every operation.
    sdpHandlers: [],
    // filter out H264 Codec
    removeH264Codecs: true
  };
  options = (0, _utils2.mergeValues)(defaultOptions, options);

  function* init({ webRTC }) {
    yield (0, _effects.put)((0, _actions2.update)(options, _interfaceNew2.default.name));
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));

    /*
     * Set SDP handlers to be used for every operation:
     *
     * 1. Application provided SDP handlers.
     *
     * 2. Disable DTLS-SDES crypto method (ie. delete the line) if there's a better
     *    crypto method enabled. WebRTC only allows one method to be enabled.
     *    This is needed for interopability with non-browser endpoints that include
     *    SDES as a fallback method.
     *
     * 3. [optional] Disable H264 Codecs for video calls, used to reduce SDP size
     *
    */
    let sdpHandlers = options.sdpHandlers;
    if (options.removeH264Codecs) {
      sdpHandlers.push((0, _codecRemover2.default)(['H264']));
    }
    sdpHandlers.push(_utils.sanitizeSdesFromSdp);
    webRTC.sdp.pipeline.setHandlers(sdpHandlers);

    // Wrap the call sagas in a function that provides them with the webRTC stack.
    const wrappedSagas = (0, _fp.values)(sagas).map(saga => {
      return (0, _utils2.autoRestart)(() => saga(webRTC.managers));
    });

    // Run all of the sagas.
    for (let saga of wrappedSagas) {
      yield (0, _effects.fork)(saga);
    }
  }

  return {
    name: _interfaceNew2.default.name,
    api: _interfaceNew2.default.api,
    reducer: _interfaceNew2.default.reducer,
    init
  };
}

// Other plugins.

/***/ }),

/***/ "./src/call/cpaas2/requests/calls.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.createSession = createSession;
exports.answerSession = answerSession;
exports.fetchCredentials = fetchCredentials;
exports.updateSession = updateSession;
exports.updateSessionStatus = updateSessionStatus;
exports.endSession = endSession;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _helpers = __webpack_require__("./src/common/helpers/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * REST request to create a webRTC session.
 * @method createSession
 * @param  {Object} requestInfo
 * @param  {Object} callInfo
 * @return {Object}
 */
// Helpers.
function* createSession(requestInfo, callInfo) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/webrtcsignaling/${requestInfo.version}/${requestInfo.username}/sessions`,
    body: (0, _stringify2.default)({
      wrtcsSession: {
        clientCorrelator: requestInfo.clientCorrelator,
        tParticipantAddress: callInfo.participantAddress,
        // The backend does not use/support participant name yet.
        tParticipantName: undefined,
        offer: {
          sdp: callInfo.offer
        }
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Create session')
    };
  } else {
    return response.payload.body.wrtcsSession;
  }
}

/**
 * REST request to answer a webRTC session.
 * @method answerSession
 * @param  {Object} requestInfo
 * @param  {Object} callInfo
 * @return {Object}
 */
function* answerSession(requestInfo, callInfo) {
  const requestOptions = {
    method: 'PUT',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `sessions/${callInfo.sessionId}/answer`,
    body: (0, _stringify2.default)({
      wrtcsAnswer: {
        clientCorrelator: requestInfo.clientCorrelator,
        sdp: callInfo.answer
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Answer session')
    };
  } else {
    return response.payload.body.wrtcsAnswer;
  }
}

/**
 * Fetch a set of TURN credentials.
 * @method fetchCredentials
 * @param  {Object} requestInfo
 */
function* fetchCredentials(requestInfo) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `turn`,
    body: (0, _stringify2.default)({
      wrtcsTurnCredentials: {
        clientCorrelator: requestInfo.clientCorrelator
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Fetch credentials')
    };
  } else {
    return response.payload.body.wrtcsTurnCredentials;
  }
}

/**
 * Update an existing webRTC session with a new offer.
 * @method updateSession
 * @param  {Object} requestInfo
 * @param  {Object} callInfo
 * @param  {string} callInfo.sessionId The ID the backend uses to track the session.
 * @param  {string} callInfo.offer The updated offer.
 * @return {Object}
 */
function* updateSession(requestInfo, callInfo) {
  const requestOptions = {
    method: 'PUT',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `sessions/${callInfo.sessionId}/update`,
    body: (0, _stringify2.default)({
      wrtcsOffer: {
        clientCorrelator: requestInfo.clientCorrelator,
        sdp: callInfo.offer
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);
  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Update session')
    };
  } else {
    return response.payload.body.wrtcsOffer;
  }
}

/**
 * REST PUT request to send webRTC session status.
 * @method updateSessionStatus
 * @param  {Object} requestInfo
 * @param  {Object} callInfo
 * @param  {string} status The desired status to change the call state to
 * @return {Object}
 */
function* updateSessionStatus(requestInfo, callInfo, status) {
  const requestOptions = {
    method: 'PUT',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `sessions/${callInfo.wrtcsSessionId}/status`,
    body: (0, _stringify2.default)({
      wrtcsSessionStatus: {
        clientCorrelator: requestInfo.clientCorrelator,
        status
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Session Status Update')
    };
  } else {
    return response.payload.body.wrtcsSessionStatus;
  }
}

/**
 * REST request to end a webRTC session.
 * @method endSession
 * @param  {Object} requestInfo
 * @param  {Object} callInfo
 * @return {Object}
 */
function* endSession(requestInfo, callInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `sessions/${callInfo.sessionId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'End session')
    };
  } else {
    return {
      error: false
    };
  }
}

/***/ }),

/***/ "./src/call/cpaas2/requests/subscriptions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.callSubscribe = callSubscribe;
exports.callUnsubscribe = callUnsubscribe;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Request saga. Generates and sends a REST request to the backend.
 * @method callSubscribe
 * @param  {Object} requestInfo
 * @param  {Object} subInfo
 * @return {Object}
 */
// Helpers.
function* callSubscribe(requestInfo, channelInfo) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `subscriptions`,
    body: (0, _stringify2.default)({
      wrtcsNotificationSubscription: {
        callbackReference: {
          notifyURL: channelInfo.callbackURL
        },
        clientCorrelator: requestInfo.clientCorrelator
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      // TODO: An actual error.
      error: new _errors2.default({
        message: 'Failed to subscribe for call notifications',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      subscription: response.payload.body.wrtcsNotificationSubscription
    };
  }
}

/**
 * Request saga. Generates and sends a REST request to the backend.
 * @method callUnsubscribe
 * @param  {Object} requestInfo
 * @param  {Object} subInfo
 * @return {Object}
 */
function* callUnsubscribe(requestInfo, subInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/` + `webrtcsignaling/${requestInfo.version}/${requestInfo.username}/` + `subscriptions/${subInfo.subscriptionId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to unsubscribe from call notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      error: false
    };
  }
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/establish.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeCall = makeCall;
exports.answerCall = answerCall;

var _calls = __webpack_require__("./src/call/cpaas2/requests/calls.js");

var _actions = __webpack_require__("./src/call/interfaceNew/actions/index.js");

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _constants = __webpack_require__("./src/call/constants.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _establish = __webpack_require__("./src/callstack/sagas/establish.js");

var _midcall = __webpack_require__("./src/callstack/sagas/midcall.js");

var _constants2 = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

// Helpers.


// Other plugins.
/**
 * "Establish sagas" handle establishing a call (ie. start or respond to a call).
 *
 * The sagas about starting a call locally assume there is no session established
 *    (since that's what it is doing). The sagas about responding to a call
 *    assume that there is a session (both webRTC and server).
 */

// Call plugin.
const log = (0, _logs.getLogManager)().getLogger('CALL');

/**
 * Start a call.
 * @method makeCall
 * @param {Object} webRTC an instance of WebRTC
 * @param {Object} action An action of type `MAKE_CALL`.
 */


// Libraries.
function* makeCall(webRTC, action) {
  // Create a new local media object for this call.
  const mediaConstraints = {
    video: action.payload.mediaConstraints.video,
    audio: action.payload.mediaConstraints.audio
  };

  if (!mediaConstraints.audio) {
    log.warn('Making calls without audio is not currently supported; enabling audio for outgoing call.');
    mediaConstraints.audio = true;
  }

  const turnInfo = yield (0, _effects.select)(_selectors.getTurnInfo);
  const { trickleIceMode, sdpSemantics } = yield (0, _effects.select)(_selectors.getOptions);

  const { offerSdp, sessionId, mediaId } = yield (0, _effects.call)(_establish.setupCall, webRTC, mediaConstraints, {
    sdpSemantics,
    turnInfo,
    trickleIceMode
  });

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);
  const callInfo = {
    participantAddress: action.payload.participantAddress,
    offer: offerSdp
  };

  const response = yield (0, _effects.call)(_calls.createSession, requestInfo, callInfo);
  log.debug('Received session response:', response);

  if (!response.error) {
    yield (0, _effects.put)(_actions.callActions.makeCallFinish(action.payload.id, {
      state: _constants.CALL_STATES.INITIATED,
      // The ID that the backend uses to track this webRTC session.
      wrtcsSessionId: response.resourceURL.split('sessions/')[1],
      // The ID that the webRTC stack uses to track this webRTC session.
      webrtcSessionId: sessionId,
      // The local Media object associated with this call.
      mediaId: mediaId
    }));
  } else {
    // The call failed, so stop the Media object created for the call.
    // TODO: Update redux state that the Media object is stopped.
    //    Need an event from Media model to notify about the stop, and listener
    //    set on Media when it is created (in `createLocalMedia` saga).
    yield (0, _effects.call)(_midcall.closeCall, webRTC, sessionId);

    yield (0, _effects.put)(_actions.callActions.makeCallFinish(action.payload.id, {
      state: _constants.CALL_STATES.ENDED,
      error: response.error
    }));
  }
}

/**
 * Answer a call.
 * @method answerCall
 * @param  {Object} action An action of type `ANSWER_CALL`.
 */
function* answerCall(webRTC, action) {
  const incomingCall = yield (0, _effects.select)(_selectors.getCallById, action.payload.id);

  if (!incomingCall) {
    log.error(`Error: Call ${action.payload.id} not found.`);
    return;
  }

  const mediaConstraints = {
    video: action.payload.mediaConstraints.video,
    audio: action.payload.mediaConstraints.audio
  };

  if (!mediaConstraints.audio) {
    // TODO: Does the backend require answering with audio?
    log.warn('Answering calls without audio is not currently supported; enabling audio for incoming call.');
    mediaConstraints.audio = true;
  }

  const sessionOptions = { sessionId: incomingCall.webrtcSessionId };
  const { answerSDP, mediaId } = yield (0, _effects.call)(_establish.answerWebrtcSession, webRTC, mediaConstraints, sessionOptions);

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);
  const callInfo = {
    answer: answerSDP,
    sessionId: incomingCall.wrtcsSessionId
  };

  const response = yield (0, _effects.call)(_calls.answerSession, requestInfo, callInfo);

  if (!response.error) {
    yield (0, _effects.put)(_actions.callActions.answerCallFinish(action.payload.id, {
      // TODO: Determine when we're actually "in call".
      state: _constants.CALL_STATES.CONNECTED,
      startTime: new Date().getTime(),
      // The local Media object associated with this call.
      mediaId: mediaId
    }, {
      // CPaaS2 does not check for / support slow start yet.
      isSlowStart: false
    }));
  } else {
    yield (0, _effects.put)(_actions.callActions.answerCallFinish(action.payload.id, {
      error: response.error
    }));
  }
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerCall = registerCall;
exports.createCall = createCall;
exports.answerCall = answerCall;
exports.holdCall = holdCall;
exports.unholdCall = unholdCall;
exports.addMedia = addMedia;
exports.removeMedia = removeMedia;
exports.sendDTMF = sendDTMF;
exports.incomingCallNotification = incomingCallNotification;
exports.callAcceptedNotification = callAcceptedNotification;
exports.callStatusNotification = callStatusNotification;
exports.callAudit = callAudit;
exports.callOfferNotification = callOfferNotification;
exports.callAnswerNotification = callAnswerNotification;
exports.endCall = endCall;
exports.getStats = getStats;
exports.setTurnCredentials = setTurnCredentials;

var _subscriptions = __webpack_require__("./src/call/cpaas2/sagas/subscriptions.js");

var subSagas = _interopRequireWildcard(_subscriptions);

var _establish = __webpack_require__("./src/call/cpaas2/sagas/establish.js");

var establishSagas = _interopRequireWildcard(_establish);

var _notifications = __webpack_require__("./src/call/cpaas2/sagas/notifications.js");

var notificationSagas = _interopRequireWildcard(_notifications);

var _midcall = __webpack_require__("./src/call/cpaas2/sagas/midcall.js");

var midcallSagas = _interopRequireWildcard(_midcall);

var _support = __webpack_require__("./src/call/cpaas2/sagas/support.js");

var supportSagas = _interopRequireWildcard(_support);

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _effects = __webpack_require__("./src/subscription/interface/effects.js");

var _actionTypes2 = __webpack_require__("./src/subscription/interface/actionTypes.js");

var _actionTypes3 = __webpack_require__("./src/notifications/interface/actionTypes.js");

var _effects2 = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Register the call service for subscriptions.
 * @method registerCall
 */


// Other plugins.
/**
 * Call saga index.
 * Defines which actions trigger which sagas.
 */

// Call plugin.
function* registerCall() {
  yield (0, _effects.registerService)('call', subSagas.subscribe, subSagas.unsubscribe);
}

/**
 * Call operations.
 */

/**
 * Start an outgoing call.
 * @method createCall
 * @param  {Object} webRTC The webRTC stack.
 */


// Libraries.
function* createCall(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.MAKE_CALL, establishSagas.makeCall, webRTC);
}

/**
 * Answer a ringing call.
 * @method answerCall
 */
function* answerCall(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.ANSWER_CALL, establishSagas.answerCall, webRTC);
}

/**
 * Put a call on hold.
 * Currently, "hold" is defined as setting media directions to inactive.
 * TODO: There will be different "hold" scenarios. Need to determine how to
 *    differentiate between them to know which saga to trigger.
 * @method holdCall
 */
function* holdCall(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.CALL_HOLD, midcallSagas.offerInactiveMedia, webRTC);
}

/**
 * Take a call off hold.
 * Currently, "unhold" is defined as setting media directions to sendrecv.
 * TODO: There will be different "unhold" scenarios. Need to determine how to
 *    differentiate between them to know which saga to trigger.
 * @method unholdCall
 */
function* unholdCall(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.CALL_UNHOLD, midcallSagas.offerFullMedia, webRTC);
}

/**
 * Add media to a call.
 * @method addMedia
 */
function* addMedia(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.ADD_MEDIA, midcallSagas.addMedia, webRTC);
}

/**
 * Remove media from a call.
 * @method removeMedia
 */
function* removeMedia(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.REMOVE_MEDIA, midcallSagas.removeMedia, webRTC);
}

/**
 * Send DTMF tones for a call.
 * @method sendDTMF
 */
function* sendDTMF(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.SEND_DTMF, midcallSagas.sendDTMF, webRTC);
}

/**
 * Call notifications.
 */

/**
 * Handle a "call incoming" notification.
 * @method incomingCallNotification
 * @param  {Object} webRTC The webRTC stack.
 */
function* incomingCallNotification(webRTC) {
  // Redux-saga take() pattern.
  function incomingCallPattern(action) {
    return action.type === _actionTypes3.NOTIFICATION_RECEIVED && action.payload.wrtcsSessionInvitationNotification;
  }
  yield (0, _effects2.takeEvery)(incomingCallPattern, notificationSagas.incomingCall, webRTC);
}

/**
 * Handle a "call accepted" notification.
 * @method callAcceptedNotification
 * @param  {Object} webRTC The webRTC stack.
 */
function* callAcceptedNotification(webRTC) {
  // Redux-saga take() pattern.
  function callResponsePattern(action) {
    return action.type === _actionTypes3.NOTIFICATION_RECEIVED && action.payload.wrtcsAcceptanceNotification;
  }

  yield (0, _effects2.takeEvery)(callResponsePattern, notificationSagas.callAccepted, webRTC);
}

/**
 * Handle a call status websocket notification.
 * @method callStatusNotification
 * @param  {Object} webRTC The webRTC stack.
 */
function* callStatusNotification(webRTC) {
  function statusUpdatePattern(status) {
    return function statusPattern(action) {
      return action.type === _actionTypes3.NOTIFICATION_RECEIVED && action.payload.wrtcsEventNotification && action.payload.wrtcsEventNotification.eventType === status;
    };
  }

  // Handle specific call statuses
  yield (0, _effects2.takeEvery)(statusUpdatePattern('Ringing'), notificationSagas.callStatusUpdateRinging, webRTC);
  yield (0, _effects2.takeEvery)(statusUpdatePattern('SessionEnded'), notificationSagas.callStatusUpdateEnded, webRTC);
  yield (0, _effects2.takeEvery)(statusUpdatePattern('Cancelled'), notificationSagas.callStatusUpdateCancelled, webRTC);
}

/**
 * Handle sending a call audit request
 * @method callAudit
 * @param  {Object} webRTC The webRTC stack.
 */
function* callAudit(webRTC) {
  const actionTypesToDoAuditOn = [actionTypes.ANSWER_CALL, actionTypes.CALL_ACCEPTED];

  function callStartAuditPattern(action) {
    return actionTypesToDoAuditOn.indexOf(action.type) !== -1 && !action.error;
  }

  yield (0, _effects2.takeEvery)([callStartAuditPattern, actionTypes.CALL_AUDIT], supportSagas.sendCallAudit, webRTC);
}

/**
 * Handle a "call offer" notification.
 * @method callOfferNotification
 * @param  {Object} webRTC The webRTC stack.
 */
function* callOfferNotification(webRTC) {
  // Redux-saga take() pattern.
  function callOfferPattern(action) {
    return action.type === _actionTypes3.NOTIFICATION_RECEIVED && action.payload.wrtcsOfferNotification;
  }

  yield (0, _effects2.takeEvery)(callOfferPattern, notificationSagas.receivedOffer, webRTC);
}

/**
 * Handle a "call answer" notification.
 * @method callAnswerNotification
 * @param  {Object} webRTC The webRTC stack.
 */
function* callAnswerNotification(webRTC) {
  // Redux-saga take() pattern.
  function callAnswerPattern(action) {
    return action.type === _actionTypes3.NOTIFICATION_RECEIVED && action.payload.wrtcsAnswerNotification;
  }

  yield (0, _effects2.takeEvery)(callAnswerPattern, notificationSagas.handleAnswerNotification, webRTC);
}

/**
 * End an ongoing call.
 * @method endCall
 * @param  {Object} webRTC The webRTC stack.
 */
function* endCall(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.END_CALL, midcallSagas.endCall, webRTC);
}

/**
 * Get RTCStatsReport.
 * @method getStats
 * @param  {Object} webRTC The webRTC stack.
 */
function* getStats(webRTC) {
  yield (0, _effects2.takeEvery)(actionTypes.GET_STATS, midcallSagas.getStats, webRTC);
}

/**
 * Other.
 */

/**
 * After subscribing for the call service, set turn information for calls.
 * @method setTurnCredentials
 */
function* setTurnCredentials() {
  function callSubscribePattern(action) {
    return action.type === _actionTypes2.PLUGIN_SUBSCRIPTION_FINISHED && action.payload.service === 'call' && !action.error;
  }

  yield (0, _effects2.takeEvery)(callSubscribePattern, supportSagas.setTurnCredentials);
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/midcall.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.endCall = endCall;
exports.offerInactiveMedia = offerInactiveMedia;
exports.offerFullMedia = offerFullMedia;
exports.addMedia = addMedia;
exports.removeMedia = removeMedia;
exports.sendDTMF = sendDTMF;
exports.getStats = getStats;

var _calls = __webpack_require__("./src/call/cpaas2/requests/calls.js");

var _actions = __webpack_require__("./src/call/interfaceNew/actions/index.js");

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _constants = __webpack_require__("./src/constants.js");

var _utils = __webpack_require__("./src/call/cpaas2/utils/index.js");

var _selectors2 = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _midcall = __webpack_require__("./src/callstack/sagas/midcall.js");

var _constants2 = __webpack_require__("./src/call/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries.


// Other plugins.
/**
 * "Midcall sagas" handle performing local mid-call operations.
 *
 * These sagas assume that there is an established session (webRTC and server-
 *    side) to perform the operation on. Otherwise, it is considered an error.
 */

// Call plugin.
const log = (0, _logs.getLogManager)().getLogger('CALL');

/**
 * End a call.
 * @method endCall
 * @param  {Object} action An action of type `END_CALL`.
 */


// Helpers.
function* endCall(webRTC, action) {
  const { id } = action.payload;
  const { error } = yield (0, _effects.call)(_utils.getSessionInfoByCallId, webRTC, id);

  if (error) {
    log.debug(`Failed to end call: ${error.message}`);
    yield (0, _effects.put)(_actions.callActions.endCallFinish(id, { error }));
    return;
  }

  const { wrtcsSessionId, webrtcSessionId } = yield (0, _effects.select)(_selectors2.getCallById, id);

  yield (0, _effects.call)(_midcall.closeCall, webRTC, webrtcSessionId);

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const callInfo = {
    sessionId: wrtcsSessionId
  };

  const response = yield (0, _effects.call)(_calls.endSession, requestInfo, callInfo);

  if (!response.error) {
    yield (0, _effects.put)(_actions.callActions.endCallFinish(id));
  } else {
    yield (0, _effects.put)(_actions.callActions.endCallFinish(id, {
      error: response.error
    }));
  }
}

/**
 * Updates an existing session to have inactive media.
 * Can be used as a "hold" operation for plain webRTC scenarios.
 * @method offerInactiveMedia
 * @param  {Object} action An action of type `CALL_HOLD`.
 */
function* offerInactiveMedia(webRTC, action) {
  const { targetCall, error } = yield (0, _effects.call)(_utils.getSessionInfoByCallId, webRTC, action.payload.id);

  if (error) {
    log.debug(`Failed to re-offer: ${error.message}`);
    yield (0, _effects.put)(_actions.callActions.holdCallFinish(action.payload.id, {
      local: true,
      error
    }));
    return;
  } else if (targetCall.localHold) {
    log.debug('Invalid state for hold operation: already held locally.');

    yield (0, _effects.put)(_actions.callActions.holdCallFinish(action.payload.id, {
      local: true,
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_STATE,
        message: 'Invalid state for hold operation: already held locally.'
      })
    }));
    return;
  }

  const offer = yield (0, _effects.call)(_midcall.generateOffer, webRTC, targetCall.webrtcSessionId, {
    audio: 'inactive',
    video: 'inactive'
  });

  if (!offer) {
    log.debug('Failed to generate SDP offer');
    yield (0, _effects.put)(_actions.callActions.holdCallFinish(action.payload.id, {
      local: true,
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_OFFER,
        message: 'Failed to generate SDP offer'
      })
    }));
    return;
  }

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const callInfo = {
    sessionId: targetCall.wrtcsSessionId,
    offer: offer.sdp
  };

  const response = yield (0, _effects.call)(_calls.updateSession, requestInfo, callInfo);

  if (response.error) {
    log.debug('Failed to send hold offer.');
    yield (0, _effects.put)(_actions.callActions.holdCallFinish(action.payload.id, {
      local: true,
      error: response.error
    }));
  } else {
    log.debug('Successfully sent hold offer.');
    yield (0, _effects.put)(_actions.callActions.holdCallFinish(action.payload.id, {
      local: true
    }));
  }
}

/**
 * Updates an existing session to have "full" (sendrecv) media.
 * Can be used as an "unhold" operation in plain webRTC scenarios,
 * @method offerFullMedia
 * @param  {Object} action A "call unhold" action.
 */
function* offerFullMedia(webRTC, action) {
  const { targetCall, error } = yield (0, _effects.call)(_utils.getSessionInfoByCallId, webRTC, action.payload.id);

  if (error) {
    log.debug(`Failed to re-offer: ${error.message}`);
    yield (0, _effects.put)(_actions.callActions.unholdCallFinish(action.payload.id, {
      local: true,
      error
    }));
    return;
  } else if (!targetCall.localHold) {
    log.debug('Invalid state for unhold operation: not held locally.');
    yield (0, _effects.put)(_actions.callActions.unholdCallFinish(action.payload.id, {
      local: true,
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_STATE,
        message: 'Invalid state for unhold operation: not held locally.'
      })
    }));
    return;
  }

  // TODO: Make sure the session is in the correct signaling state to start a
  //    renegotiation operation.
  const offer = yield (0, _effects.call)(_midcall.generateOffer, webRTC, targetCall.webrtcSessionId, {
    audio: 'sendrecv',
    video: 'sendrecv'
  });

  if (!offer) {
    log.debug('Invalid SDP offer or SDP offer not received.');
    yield (0, _effects.put)(_actions.callActions.unholdCallFinish(action.payload.id, {
      local: true,
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_OFFER,
        message: 'Invalid SDP offer or SDP offer not received'
      })
    }));
    return;
  }

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const callInfo = {
    sessionId: targetCall.wrtcsSessionId,
    offer: offer.sdp
  };

  const response = yield (0, _effects.call)(_calls.updateSession, requestInfo, callInfo);

  if (response.error) {
    log.debug('Failed to send unhold offer.');
    yield (0, _effects.put)(_actions.callActions.unholdCallFinish(action.payload.id, {
      local: true,
      error: response.error
    }));
  } else {
    log.debug('Successfully sent unhold offer.');
    yield (0, _effects.put)(_actions.callActions.unholdCallFinish(action.payload.id, {
      local: true
    }));
  }
}

/**
 * Updates an existing session with additional (sendrecv) media.
 * @method addMedia
 * @param  {Object} action An "add media" action.
 */
function* addMedia(webRTC, action) {
  // Make sure the call state is what we expect
  const stateError = yield (0, _effects.call)(_utils.validateCallState, action.payload.id, { state: _constants2.CALL_STATES.CONNECTED });
  if (stateError) {
    log.debug(`Invalid call state: ${stateError.message}`);
    yield (0, _effects.put)(_actions.callActions.addMediaFinish(action.payload.id, {
      local: true,
      error: stateError
    }));
    return;
  }

  // Get some call data.
  const { webrtcSessionId, wrtcsSessionId } = yield (0, _effects.select)(_selectors2.getCallById, action.payload.id);

  // Create media and add tracks using webRTC
  const { sdp, media } = yield (0, _effects.call)(_midcall.webRtcAddMedia, webRTC, action.payload.mediaConstraints, {
    sessionId: webrtcSessionId
  });

  // Get the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const callInfo = {
    sessionId: wrtcsSessionId,
    offer: sdp
  };

  const response = yield (0, _effects.call)(_calls.updateSession, requestInfo, callInfo);

  if (response.error) {
    log.debug('Failed to send add media offer.');
    yield (0, _effects.put)(_actions.callActions.addMediaFinish(action.payload.id, {
      local: true,
      error: response.error
    }));
  } else {
    log.debug('Successfully sent add media offer.');
    yield (0, _effects.put)(_actions.callActions.addMediaFinish(action.payload.id, {
      local: true,
      mediaId: media.id,
      tracks: media.tracks.map(track => track.id)
    }));
  }
}

/**
 * Removes media from an existing session.
 * @method removeMedia
 * @param  {Object} action A "remove media" action.
 */
function* removeMedia(webRTC, action) {
  // Handle scenario where no track ids are provided or not in an array.
  if (!(0, _fp.isArray)(action.payload.tracks) || (0, _fp.isEmpty)(action.payload.tracks)) {
    log.debug(`No track ids specified to remove.`);
    yield (0, _effects.put)(_actions.callActions.removeMediaFinish(action.payload.id, {
      local: true,
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_PARAM,
        message: 'No track ids specified to remove.'
      })
    }));
    return;
  }

  // Make sure the call state is what we expect
  const stateError = yield (0, _effects.call)(_utils.validateCallState, action.payload.id, { state: _constants2.CALL_STATES.CONNECTED });
  if (stateError) {
    log.debug(`Invalid call state:  ${stateError.message}`);
    yield (0, _effects.put)(_actions.callActions.removeMediaFinish(action.payload.id, {
      local: true,
      stateError
    }));
    return;
  }
  // Get some call data.
  const { webrtcSessionId, wrtcsSessionId } = yield (0, _effects.select)(_selectors2.getCallById, action.payload.id);

  // Remove media and tracks using webRTC
  const { sdp, error } = yield (0, _effects.call)(_midcall.webRtcRemoveMedia, webRTC, {
    sessionId: webrtcSessionId,
    tracks: action.payload.tracks
  });
  if (error) {
    log.debug(`Failed to remove media: ${error.message}`);
    yield (0, _effects.put)(_actions.callActions.removeMediaFinish(action.payload.id, {
      local: true,
      error
    }));
    return;
  }

  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const callInfo = {
    sessionId: wrtcsSessionId,
    offer: sdp
  };

  const response = yield (0, _effects.call)(_calls.updateSession, requestInfo, callInfo);

  if (response.error) {
    log.debug('Failed to send add media offer.');
    yield (0, _effects.put)(_actions.callActions.removeMediaFinish(action.payload.id, {
      local: true,
      error: response.error
    }));
  } else {
    log.debug('Successfully sent add media offer.');
    yield (0, _effects.put)(_actions.callActions.removeMediaFinish(action.payload.id, {
      local: true,
      tracks: action.payload.tracks
    }));
  }
}

/**
 * Sends DTMF tones.
 * @method sendDTMF
 * @param  {Object} action A "send DTMF" action.
 */
function* sendDTMF(webRTC, action) {
  // Handle scenario where no tone is provided.
  if ((0, _fp.isUndefined)(action.payload.tone)) {
    yield (0, _effects.put)(_actions.callActions.sendDTMFFinish(action.payload.id, {
      error: new _errors2.default({
        code: _errors.callCodes.INVALID_PARAM,
        message: 'No tone specifed.'
      })
    }));
    return;
  }

  const { session, error } = yield (0, _effects.call)(_utils.getSessionInfoByCallId, webRTC, action.payload.id);
  const { tone, duration, intertoneGap } = action.payload;

  if (error) {
    log.debug(`Failed to send DTMF: ${error.message}`);
    yield (0, _effects.put)(_actions.callActions.sendDTMFFinish(action.payload.id, { error }));
    return;
  }
  // Send DTMF tones.
  const result = yield (0, _effects.call)([session, 'sendDTMF'], { tone, duration, intertoneGap });
  if (result) {
    log.debug('Successfully sent DTMF tones.');
    yield (0, _effects.put)(_actions.callActions.sendDTMFFinish(action.payload.id));
  } else {
    log.debug('Failed to send DTMF tones.');
    yield (0, _effects.put)(_actions.callActions.sendDTMFFinish(action.payload.id, {
      error: new _errors2.default({
        code: _errors.callCodes.GENERIC_ERROR,
        message: 'Unable to send DTMF tones.'
      })
    }));
  }
}
/**
 * Gets RTCStatsReport.
 * @method getStats
 * @param  {Object} action A "get Stats" action.
 */
function* getStats(webRTC, action) {
  const trackId = action.payload.trackId;
  const { session, error } = yield (0, _effects.call)(_utils.getSessionInfoByCallId, webRTC, action.payload.id);
  if (error) {
    yield (0, _effects.put)(_actions.callActions.getStatsFinish(action.payload.id, { error, trackId }));
    return;
  }

  // Retrieve the RTCStatsReport from the session.
  let result;
  try {
    result = yield (0, _effects.call)([session, 'getStats'], trackId);
    log.debug('Successfully got RTCStatsReport.');
  } catch (error) {
    yield (0, _effects.put)(_actions.callActions.getStatsFinish(action.payload.id, {
      error: new _errors2.default({
        code: _errors.callCodes.GENERIC_ERROR,
        message: error.message
      }),
      trackId
    }));
  }
  if (result) {
    yield (0, _effects.put)(_actions.callActions.getStatsFinish(action.payload.id, { result, trackId }));
  }
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/notifications.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.incomingCall = incomingCall;
exports.callAccepted = callAccepted;
exports.callStatusUpdateRinging = callStatusUpdateRinging;
exports.callStatusUpdateCancelled = callStatusUpdateCancelled;
exports.callStatusUpdateEnded = callStatusUpdateEnded;
exports.receivedOffer = receivedOffer;
exports.handleAnswerNotification = handleAnswerNotification;

var _calls = __webpack_require__("./src/call/cpaas2/requests/calls.js");

var _actions = __webpack_require__("./src/call/interfaceNew/actions/index.js");

var _constants = __webpack_require__("./src/call/constants.js");

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _midcall = __webpack_require__("./src/callstack/sagas/midcall.js");

var _negotiation = __webpack_require__("./src/callstack/sagas/negotiation.js");

var _establish = __webpack_require__("./src/callstack/sagas/establish.js");

var _constants2 = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries.


// Other plugins.
/**
 * "Notification sagas" handle received notifications.
 * Each saga handles a single websocket notification that may be received from
 *    the backend.
 *
 * There may not be an established webRTC session for these sagas. This may be
 *    because (1) the notification is a new incoming call, or (2) there is a
 *    de-sync between SDK state and server state. This may or may not be
 *    considered as an error scenario (eg. a "call ended" notification for a
 *    call the SDK doesn't know about may be safely ignored).
 */

// Call plugin.
const log = (0, _logs.getLogManager)().getLogger('CALL');

/**
 * Handle an incoming call notification.
 * @method incomingCall
 * @param  {Object} action An action representing an incoming call notification.
 */


// Helpers.
function* incomingCall(webRTC, action) {
  const { originatorAddress, originatorName, link, offer } = action.payload.wrtcsSessionInvitationNotification;
  const wrtcsSessionId = link[0].href.split('sessions/')[1];

  const turnInfo = yield (0, _effects.select)(_selectors.getTurnInfo);
  const { trickleIceMode, sdpSemantics } = yield (0, _effects.select)(_selectors.getOptions);

  const sessionId = yield (0, _effects.call)(_establish.setupIncomingCall, webRTC, {
    offer,
    trickleIceMode,
    sdpSemantics,
    turnInfo
  });

  // Send update that the wrtcsSessionStatus is 'Ringing'
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);
  const callInfo = { wrtcsSessionId };
  const updateStatusResponse = yield (0, _effects.call)(_calls.updateSessionStatus, requestInfo, callInfo, 'Ringing');

  if (updateStatusResponse.error) {
    log.error(`Error: Update session status error - ${updateStatusResponse.error.code}: ${updateStatusResponse.error.message}.`);
  }

  const callId = yield (0, _effects.call)(_v2.default);
  yield (0, _effects.put)(_actions.callActions.callIncoming(callId, {
    // TODO: Proper constants.
    direction: 'incoming',
    state: _constants.CALL_STATES.RINGING,
    remoteParticipant: {
      displayName: originatorAddress,
      displayNumber: originatorName
    },
    // The ID that the backend uses to track this webRTC session.
    wrtcsSessionId,
    // The ID that the webRTC stack uses to track this webRTC session.
    webrtcSessionId: sessionId
  }));
}

/**
 * Handles a notification that the remote end accepted the call.
 * @method callAccepted
 * @param  {Object} action An action representing a call accepted notification.
 */
function* callAccepted(webRTC, action) {
  const wrtcsSession = action.payload.wrtcsAcceptanceNotification;
  const wrtcsSessionId = wrtcsSession.link[0].href.split('sessions/')[1];

  const calls = yield (0, _effects.select)(_selectors.getCalls);
  // TODO: `find` --> IE11 support.
  const currentCall = calls.find(call => call.wrtcsSessionId === wrtcsSessionId);

  if (!currentCall) {
    log.error(`Error: wrtcs session call ${wrtcsSessionId} not found.`);
    return;
  }

  const sessionOptions = { sessionId: currentCall.webrtcSessionId, answerSdp: wrtcsSession.answer.sdp };
  const error = yield (0, _effects.call)(_negotiation.receivedAnswer, webRTC, sessionOptions, currentCall);

  if (!error) {
    yield (0, _effects.put)(_actions.callActions.callAccepted(currentCall.id, {
      // TODO: Determine when we're actually "in call".
      state: _constants.CALL_STATES.CONNECTED,
      startTime: wrtcsSession.dateTime
    }));
  } else {
    // TODO: Need to handle errors in webrtc before we know what to handle here.
  }
}

/**
 * Handles a notification that the remote end call status is 'Ringing'.
 * @method callStatusUpdateRinging
 * @param  {Object} action An action representing a call notification.
 */
function* callStatusUpdateRinging(webRTC, action) {
  const wrtcsSessionId = action.payload.wrtcsEventNotification.link[0].href.split('sessions/')[1];

  const calls = yield (0, _effects.select)(_selectors.getCalls);
  // TODO: `find` --> IE11 support.
  const currentCall = calls.find(call => call.wrtcsSessionId === wrtcsSessionId);

  if (!currentCall) {
    log.error(`Error: wrtcs session call ${wrtcsSessionId} not found.`);
    return;
  }

  yield (0, _effects.put)(_actions.callActions.callRinging(currentCall.id));
}

/**
 * Handles a notification that the remote end call status is 'Cancelled'.
 * @method callStatusUpdateCancelled
 * @param  {Object} action An action representing a call notification.
 */
function* callStatusUpdateCancelled(webRTC, action) {
  const wrtcsSessionId = action.payload.wrtcsEventNotification.link[0].href.split('sessions/')[1];

  const targetCall = yield (0, _effects.select)(_selectors.getCallByWrtcsSessionId, wrtcsSessionId);

  if (!targetCall) {
    log.debug(`Call for session ${wrtcsSessionId} not found.`);
    return;
  }

  yield (0, _effects.call)(_midcall.closeCall, webRTC, targetCall.id);

  yield (0, _effects.put)(_actions.callActions.callCancelled(targetCall.id));
}

/**
 * Handles a notification that the remote end call status is 'SessionEnded'.
 * @method callStatusUpdateEnded
 * @param  {Object} action An action representing a call notification.
 */
function* callStatusUpdateEnded(webRTC, action) {
  const wrtcsSessionId = action.payload.wrtcsEventNotification.link[0].href.split('sessions/')[1];

  const calls = yield (0, _effects.select)(_selectors.getCalls);
  // TODO: `find` --> IE11 support.
  const currentCall = calls.find(call => call.wrtcsSessionId === wrtcsSessionId);

  if (!currentCall) {
    log.debug(`Error: wrtcs session call ${wrtcsSessionId} not found.`);
    return;
  }

  if (currentCall.state === _constants.CALL_STATES.ENDED) {
    log.debug(`Error: wrtcs session call ${wrtcsSessionId} already in 'Ended' state.`);
    return;
  }

  yield (0, _effects.call)(_midcall.closeCall, webRTC, currentCall.webrtcSessionId);

  yield (0, _effects.put)(_actions.callActions.endCallFinish(currentCall.id));
}

/**
 * Handle a remote SDP offer.
 * @method receivedOffer
 * @param  {Object} action A notification action for "offer received".
 */
function* receivedOffer(webRTC, action) {
  const { link, offer } = action.payload.wrtcsOfferNotification;
  const wrtcsSessionId = link[0].href.split('sessions/')[1];

  // TODO: Helper to go from wrtcsSessionId --> session.
  const targetCall = yield (0, _effects.select)(_selectors.getCallByWrtcsSessionId, wrtcsSessionId);

  if (!targetCall) {
    // Scenario: Received a notification for a call that we don't
    //  know about. Our state is not synced with backend state.
    // TODO: Do we ignore the offer or try to recover the call?
    log.debug(`Call for session ${wrtcsSessionId} not found.`);
    return;
  }

  const { answerSDP, error } = yield (0, _effects.call)(_midcall.handleOffer, webRTC, offer.sdp, targetCall.webrtcSessionId);

  if (error) {
    log.debug('Failed to recieve offer SDP', error);
    return;
  }
  // Collect the information needed to make the request.
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);
  const callInfo = {
    answer: answerSDP,
    sessionId: wrtcsSessionId
  };

  const response = yield (0, _effects.call)(_calls.answerSession, requestInfo, callInfo);

  // TODO: Need to determine what was updated, then update state and emit an event.
  if (response.error) {
    log.debug('Failed to answer session update.', response.error);
  } else {
    log.debug('Successfully answered session update.');
  }
}

/**
 * Handle a remote answer SDP.
 * @method handleAnswerNotification
 * @param  {Object} action A notification action for "answer received".
 */
function* handleAnswerNotification(webRTC, action) {
  const { link, answer } = action.payload.wrtcsAnswerNotification;
  const wrtcsSessionId = link[0].href.split('sessions/')[1];

  // TODO: Helper to go from wrtcsSessionId --> session.
  const targetCall = yield (0, _effects.select)(_selectors.getCallByWrtcsSessionId, wrtcsSessionId);

  if (!targetCall) {
    // Scenario: Received a notification for a call that we don't
    //  know about. Our state is not synced with backend state.
    // TODO: Do we ignore the offer or try to recover the call?
    log.debug(`Call for session ${wrtcsSessionId} not found.`);
    return;
  }

  // Information about the Session / answer that the callstack will need.
  const sessionInfo = {
    sessionId: targetCall.webrtcSessionId,
    answerSdp: answer.sdp
  };

  const { error } = yield (0, _effects.call)(_negotiation.receivedAnswer, webRTC, sessionInfo, targetCall);
  // TODO: Need to determine what was updated, then update state and emit an event.
  if (error) {
    log.debug('Failed to process remote answer.', error);
  } else {
    log.debug('Successfully negotiated session update.');
  }
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/subscriptions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.subscribe = subscribe;
exports.unsubscribe = unsubscribe;

var _subscriptions = __webpack_require__("./src/call/cpaas2/requests/subscriptions.js");

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var _selectors = __webpack_require__("./src/subscription/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _constants = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Subscription saga. Creates a new call subscription channel.
 * @method callSubscribe
 */


// Libraries.


// Other plugins.
function* subscribe(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const channels = yield (0, _effects.select)(_selectors.getNotificationChannels);
  const channelInfo = channels.notificationChannels[action.payload.type];

  _loglevel2.default.debug(`Subscribing to call service on ${action.payload.type} channel.`);
  const requestOptions = {};
  requestOptions.method = 'POST';
  requestOptions.url = `${requestInfo.baseURL}` + `/cpaas/webrtcsignaling/${requestInfo.version}/${requestInfo.username}` + `/subscriptions`;

  _loglevel2.default.debug(`Subscribing to call service on ${action.payload.type} channel.`);
  const response = yield (0, _effects.call)(_subscriptions.callSubscribe, requestInfo, channelInfo);

  yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'call',
    type: action.payload.type
  })));
}

/**
 * Unsubscription saga. Deletes an existing call subscription.
 * @method unsubscribe
 */


// Helpers.
// Call plugin.
function* unsubscribe(action) {
  const { subscriptions } = yield (0, _effects.select)(_selectors.getNotificationChannels);
  let callSubscription = subscriptions.filter(sub => {
    return sub.service === 'call' && sub.channelType === action.payload.type;
  });

  if (callSubscription.length === 0) {
    // "Error" scenario: Can't unsubscribe to a service
    //    that we don't have.
  } else if (callSubscription.length > 1) {
    // "Error" scenario: There shouldn't be able to have
    //    more than 1 of the same service.
  } else {
    callSubscription = callSubscription[0];
  }

  _loglevel2.default.info(`Unsubscribing from call service on ${action.payload.type} channel.`);
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);

  const response = yield (0, _effects.call)(_subscriptions.callUnsubscribe, requestInfo, callSubscription);

  yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'call',
    type: action.payload.type
  })));
}

/***/ }),

/***/ "./src/call/cpaas2/sagas/support.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendCallAudit = sendCallAudit;
exports.setTurnCredentials = setTurnCredentials;

var _calls = __webpack_require__("./src/call/cpaas2/requests/calls.js");

var _actions = __webpack_require__("./src/call/interfaceNew/actions/index.js");

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _constants = __webpack_require__("./src/call/constants.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _constants2 = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

// Helpers.


// Other plugins.
/**
 * "Support sagas" handle call behaviours that are not directly related to calls
 *    themselves, but are required for establishing/maintaining a call.
 *
 * Some sagas do assume that there is an established session (both webRTC and
 *    server; eg. call audits), while others do not (eg. turn credentials).
 */

// Call plugin.
const log = (0, _logs.getLogManager)().getLogger('CALL');

/**
 * Send a call audit request repeatedly by redispatching sendCallAudit.
 * If no status is provided in the payload, then it is assumed that status === 'Connected'
 * @method sendCallAudit
 * @param  {Object} action An action of type `CALL_AUDIT`.
 */


// Libraries.
function* sendCallAudit(webRTC, action) {
  const delayMs = action.payload.error ? 5000 : 25000;
  yield (0, _effects.delay)(delayMs);

  // If payload.status does not exist, then saga was triggered by actions ANSWER_CALL or CALL_ACCEPTED
  // which do not provide a 'status' in the payload and should proceed as normal.
  // Or there was an error in the request so status is unknown and we should try making a request again.
  if (action.payload.status && action.payload.status !== 'Connected') {
    log.debug(`Call status is "${action.payload.status}"; stopping call audits.`);
    return;
  }
  const callId = action.payload.id;
  const currentCall = yield (0, _effects.select)(_selectors.getCallById, callId);
  if (!currentCall) {
    log.error(`Error: Call ${callId} not found.`);
    return;
  }
  if (currentCall.state === _constants.CALL_STATES.ENDED) {
    log.debug(`Call ${callId} has ended; stopping call audits.`);
    return;
  }

  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);
  const callInfo = { wrtcsSessionId: currentCall.wrtcsSessionId };
  const updateStatusResponse = yield (0, _effects.call)(_calls.updateSessionStatus, requestInfo, callInfo, 'Connected');

  if (updateStatusResponse.error) {
    log.debug(`Error: Update session status error - ${updateStatusResponse.error.code}: ${updateStatusResponse.error.message}.`);
    yield (0, _effects.put)(_actions.callActions.sendCallAudit(callId, {
      error: updateStatusResponse.error
    }));
  } else {
    const status = updateStatusResponse.status === 'Closed' ? 'Closed' : 'Connected';
    log.debug(`Call audit for ${callId}: Call is ${status}.`);
    yield (0, _effects.put)(_actions.callActions.sendCallAudit(callId, { status }));
  }
}

/**
 * Handles setting/getting turn/stun information.
 * Fetches TURN credentials from the backend if configured.
 * @method setTurnCredentials
 */
function* setTurnCredentials() {
  const { iceServers, serverTurnCredentials } = yield (0, _effects.select)(_selectors.getOptions);

  // Must have ICE servers configured.
  if (!iceServers) {
    log.debug('No ICE servers provided during setup; not using TURN/STUN for calls.');
    return;
  }

  const turnInfo = {
    servers: iceServers
  };

  if (serverTurnCredentials) {
    log.debug('Retrieving turn credentials from server.');

    // Collect the information needed to make the request.
    const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants2.platforms.CPAAS2);

    const response = yield (0, _effects.call)(_calls.fetchCredentials, requestInfo);

    if (response.error) {
      // TODO: Better error handling; do more than just stop.
      log.debug('Failed to retrieve turn credentials.');
      return;
    } else {
      turnInfo.credentials = response;

      // Map the server-provided credentials to the ICE server list.
      turnInfo.servers = turnInfo.servers.map(server => {
        return {
          urls: server.urls || server.url,
          username: response.username,
          credential: response.password
        };
      });
    }
  } else {
    log.debug('Using application provided turn credentials.');
  }

  yield (0, _effects.put)(_actions.turnActions.turnChanged(turnInfo));
}

/***/ }),

/***/ "./src/call/cpaas2/utils/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSessionInfoByCallId = getSessionInfoByCallId;
exports.validateCallState = validateCallState;
exports.sanitizeSdesFromSdp = sanitizeSdesFromSdp;

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _constants = __webpack_require__("./src/call/constants.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper function for sagas that need to perform an operation
 *    on a webRTC session. Checks for common "error scenarios".
 * Retrieves information about a "session" associated with the
 *    provided call id. "Session info" includes the call state
 *    object and webRTC stack session object. Includes an error
 *    if the session is not "usable".
 * @method getSessionInfoByCallId
 * @param  {Object} webRTC The webRTC stack.
 * @param  {string} callId The ID of the call.
 * @return {Object} An object with session, targetCall, and/or error objects.
 * @example
 * const callId = action.payload.id
 * const { session, targetCall, error } = yield call(getSessionInfoByCallId, webRTC, callId)
 *
 * if (error) {
 *  // Handle session not being retrievable / common error scenarios.
 * } else if (...) {
 *   // Check for specific error scenarios.
 * } else {
 *   // Operate on session.
 * }
 */


// Libraries.
function* getSessionInfoByCallId(webRTC, callId) {
  const targetCall = yield (0, _effects.select)(_selectors.getCallById, callId);

  if (!targetCall) {
    return {
      error: new _errors2.default({
        message: 'Call state not found: invalid call ID.',
        code: _errors.callCodes.INVALID_PARAM
      })
    };
  } else if (targetCall.state === _constants.CALL_STATES.ENDED) {
    return {
      targetCall,
      error: new _errors2.default({
        message: 'Call is wrong state: call is already ended.',
        code: _errors.callCodes.INVALID_STATE
      })
    };
  } else if (!targetCall.webrtcSessionId) {
    return {
      targetCall,
      error: new _errors2.default({
        message: 'State issue: Call has no webrtcSessionId.',
        code: _errors.callCodes.STATE_DESYNC
      })
    };
  }

  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], targetCall.webrtcSessionId);

  if (!session) {
    return {
      targetCall,
      error: new _errors2.default({
        message: 'Session not found: no active webRTC session for call.',
        code: _errors.callCodes.STATE_DESYNC
      })
    };
  }

  return { targetCall, session };
}

/**
 * Helper function: Check that the call is in an expected state.
 * @method validateCallState
 * @param  {string} callId ID for the call to validate.
 * @param  {Object} expected  Properties that the call state is expected to have.
 * @return {BasicError}
 */


// Other plugins.
// Call plugin.
function* validateCallState(callId, expected) {
  /**
   * Checks whether set is contained within whole.
   * Tracks which properties of set are not the same as whole.
   * @method isSubsetOf
   * @param  {Object} set
   * @param  {Object} whole
   * @return {Array} List of set properties that are not the same as whole.
   */
  function isSubsetOf(set, whole) {
    const differences = [];
    // Ensure that each property in the set is also part of the whole.
    for (let prop in set) {
      if ((0, _fp.isArray)(set[prop])) {
        // Compare arrays.
        if ((0, _fp.difference)(set[prop], whole[prop]).length > 0) {
          differences.push(prop);
        }
      } else if ((0, _fp.isObject)(set[prop])) {
        // Compare objects (recursively).
        if (isSubsetOf(set[prop], whole[prop]).length > 0) {
          // Don't recursively add to differences.
          differences.push(prop);
        }
      } else {
        // Compare everything else.
        if (set[prop] !== whole[prop]) {
          differences.push(prop);
        }
      }
    }

    return differences;
  }

  const targetCall = yield (0, _effects.select)(_selectors.getCallById, callId);

  // Ensure the call state exists.
  if (!targetCall) {
    return new _errors2.default({
      code: _errors.callCodes.INVALID_PARAM,
      message: 'Call state not found; invalid call ID.'
    });
  }

  // Check whether the expected properties are a subset of the call properties.
  const differences = isSubsetOf(expected, targetCall);

  if (differences.length === 0) {
    return false;
  } else {
    return new _errors2.default({
      code: _errors.callCodes.INVALID_STATE,
      message: `Call is in an invalid state (${differences}).`
    });
  }
}

/**
 * SDP handler function that should be passed into session object's `processOffer` and `processAnswer` function.
 * This function disables old media encryption method SDES (Modifies sdp by removing crypto).
 * However, if only SDES is available, don't disable it.
 * @method sanitizeSdesFromSdp
 * @param {Object} newSdp The sdp so far (could have been modified by previous handlers).
 * @param {RTCSdpType} info Information about the session description.
 * @param {RTCSdpType} info.type The session description's type.
 * @param {string} info.endpoint Which end of the connection created the SDP.
 * @param {boolean} info.isInitiator Whether this session initiated the call or not.
 * @param {Object} originalSdp The sdp in its initial state.
 * @return {Object} The sanitized sdp with crypto removed (if fingerprint exists)
 */
function sanitizeSdesFromSdp(newSdp, info, originalSdp) {
  for (let mLine of newSdp.media) {
    if (mLine.crypto && mLine.fingerprint) {
      delete mLine.crypto;
    }
  }
  return newSdp;
}

/***/ }),

/***/ "./src/call/interfaceNew/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const callPrefix = '@@KANDY/CALL/';

/**
 * Basic call operation actions.
 */
const MAKE_CALL = exports.MAKE_CALL = callPrefix + 'MAKE';
const MAKE_CALL_FINISH = exports.MAKE_CALL_FINISH = callPrefix + 'MAKE_FINISH';

const CALL_INCOMING = exports.CALL_INCOMING = callPrefix + 'INCOMING';

const CALL_RINGING = exports.CALL_RINGING = callPrefix + 'RINGING';
const CALL_CANCELLED = exports.CALL_CANCELLED = callPrefix + 'CANCELLED';

const CALL_AUDIT = exports.CALL_AUDIT = callPrefix + 'AUDIT';

const ANSWER_CALL = exports.ANSWER_CALL = callPrefix + 'ANSWER';
const ANSWER_CALL_FINISH = exports.ANSWER_CALL_FINISH = callPrefix + 'ANSWER_FINISH';

const REJECT_CALL = exports.REJECT_CALL = callPrefix + 'REJECT';
const REJECT_CALL_FINISH = exports.REJECT_CALL_FINISH = callPrefix + 'REJECT_FINISH';

const IGNORE_CALL = exports.IGNORE_CALL = callPrefix + 'IGNORE';
const IGNORE_CALL_FINISH = exports.IGNORE_CALL_FINISH = callPrefix + 'IGNORE_FINISH';

const CALL_ACCEPTED = exports.CALL_ACCEPTED = callPrefix + 'ACCEPTED';

const END_CALL = exports.END_CALL = callPrefix + 'END';
const END_CALL_FINISH = exports.END_CALL_FINISH = callPrefix + 'END_FINISH';

/**
 * Mid-call operation actions.
 */

const UPDATE_CALL = exports.UPDATE_CALL = callPrefix + 'UPDATE_CALL';

const CALL_HOLD = exports.CALL_HOLD = callPrefix + 'HOLD';
const CALL_HOLD_FINISH = exports.CALL_HOLD_FINISH = callPrefix + 'HOLD_FINISH';

const CALL_UNHOLD = exports.CALL_UNHOLD = callPrefix + 'UNHOLD';
const CALL_UNHOLD_FINISH = exports.CALL_UNHOLD_FINISH = callPrefix + 'UNHOLD_FINISH';

const CALL_REMOTE_HOLD_FINISH = exports.CALL_REMOTE_HOLD_FINISH = callPrefix + 'CALL_REMOTE_HOLD_FINISH';

const CALL_REMOTE_UNHOLD_FINISH = exports.CALL_REMOTE_UNHOLD_FINISH = callPrefix + 'CALL_REMOTE_UNHOLD_FINISH';

const ADD_MEDIA = exports.ADD_MEDIA = callPrefix + 'ADD_MEDIA';
const ADD_MEDIA_FINISH = exports.ADD_MEDIA_FINISH = callPrefix + 'ADD_MEDIA_FINISH';

const REMOVE_MEDIA = exports.REMOVE_MEDIA = callPrefix + 'REMOVE_MEDIA';
const REMOVE_MEDIA_FINISH = exports.REMOVE_MEDIA_FINISH = callPrefix + 'REMOVE_MEDIA_FINISH';

const MUSIC_ON_HOLD = exports.MUSIC_ON_HOLD = callPrefix + 'MUSIC_ON_HOLD';

const SEND_DTMF = exports.SEND_DTMF = callPrefix + 'SEND_DTMF';
const SEND_DTMF_FINISH = exports.SEND_DTMF_FINISH = callPrefix + 'SEND_DTMF_FINISH';

const GET_STATS = exports.GET_STATS = callPrefix + 'GET_STATS';
const GET_STATS_FINISH = exports.GET_STATS_FINISH = callPrefix + 'GET_STATS_FINISH';

/**
 * Turn action types.
 */
const turnPrefix = callPrefix + 'TURN/';

const TURN_CHANGED = exports.TURN_CHANGED = turnPrefix + 'CHANGED';

/**
 * Track action types.
 */
const trackPrefix = callPrefix + 'TRACK/';

const TRACK_ADDED = exports.TRACK_ADDED = trackPrefix + 'ADDED';
const TRACK_REMOVED = exports.TRACK_REMOVED = trackPrefix + 'REMOVED';

/***/ }),

/***/ "./src/call/interfaceNew/actions/call.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.makeCall = makeCall;
exports.makeCallFinish = makeCallFinish;
exports.callIncoming = callIncoming;
exports.callRinging = callRinging;
exports.callCancelled = callCancelled;
exports.sendCallAudit = sendCallAudit;
exports.answerCall = answerCall;
exports.answerCallFinish = answerCallFinish;
exports.rejectCall = rejectCall;
exports.rejectCallFinish = rejectCallFinish;
exports.callAccepted = callAccepted;
exports.ignoreCall = ignoreCall;
exports.ignoreCallFinish = ignoreCallFinish;
exports.endCall = endCall;
exports.endCallFinish = endCallFinish;
exports.updateCall = updateCall;
exports.holdCall = holdCall;
exports.holdCallFinish = holdCallFinish;
exports.holdRemoteCallFinish = holdRemoteCallFinish;
exports.unholdCall = unholdCall;
exports.unholdCallFinish = unholdCallFinish;
exports.unholdRemoteCallFinish = unholdRemoteCallFinish;
exports.addMedia = addMedia;
exports.addMediaFinish = addMediaFinish;
exports.removeMedia = removeMedia;
exports.removeMediaFinish = removeMediaFinish;
exports.musicOnHold = musicOnHold;
exports.sendDTMF = sendDTMF;
exports.sendDTMFFinish = sendDTMFFinish;
exports.getStats = getStats;
exports.getStatsFinish = getStatsFinish;

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper function for formatting call actions.
 * @method callActionHelper
 * @param  {string} type Action type.
 * @param  {string} id Id of the call being acted on.
 * @param  {Object} [payload={}]
 * @param  {BasicError} [payload.error]
 * @param  {Object} [meta={}]
 * @return {Object} An action.
 */
// Call plugin.
function callActionHelper(type, id, payload = {}, meta = {}) {
  /**
   * Call action format.
   * Call actions are not FSA-compliant because there are cases where we need
   *    to provide useful info (for the SDK) and an error object (for the app).
   *    FSA would require the error object to be the entirety of the payload.
   * @type {Object}
   * {
   *   type,
   *   payload: {
   *    ...usefulInfo,
   *    errorObject
   *   },
   *   error,
   *   meta
   * }
   */
  const action = {
    type,
    payload: (0, _extends3.default)({}, payload, {
      id
    })
    // Only have meta and error properties on the action if they're needed.
  };if (!(0, _fp.isEmpty)(meta)) {
    action.meta = meta;
  }
  if (payload.error) {
    action.error = true;
  }
  return action;
}

// Libraries.
function makeCall(id, options) {
  return callActionHelper(actionTypes.MAKE_CALL, id, options);
}

function makeCallFinish(id, params) {
  return callActionHelper(actionTypes.MAKE_CALL_FINISH, id, params);
}

function callIncoming(id, params) {
  return callActionHelper(actionTypes.CALL_INCOMING, id, params);
}

function callRinging(id, params) {
  return callActionHelper(actionTypes.CALL_RINGING, id, params);
}

function callCancelled(id, params) {
  return callActionHelper(actionTypes.CALL_CANCELLED, id, params);
}

function sendCallAudit(id, params) {
  return callActionHelper(actionTypes.CALL_AUDIT, id, params);
}

function answerCall(id, options) {
  return callActionHelper(actionTypes.ANSWER_CALL, id, options);
}

function answerCallFinish(id, params, meta) {
  return callActionHelper(actionTypes.ANSWER_CALL_FINISH, id, params, meta);
}

function rejectCall(id, options) {
  return callActionHelper(actionTypes.REJECT_CALL, id, options);
}

function rejectCallFinish(id, params) {
  return callActionHelper(actionTypes.REJECT_CALL_FINISH, id, params);
}

function callAccepted(id, params) {
  return callActionHelper(actionTypes.CALL_ACCEPTED, id, params);
}

function ignoreCall(id, params) {
  return callActionHelper(actionTypes.IGNORE_CALL, id, params);
}

function ignoreCallFinish(id, params) {
  return callActionHelper(actionTypes.IGNORE_CALL_FINISH, id, params);
}

function endCall(id, params) {
  return callActionHelper(actionTypes.END_CALL, id, params);
}

function endCallFinish(id, params) {
  return callActionHelper(actionTypes.END_CALL_FINISH, id, params);
}

function updateCall(id, params) {
  return callActionHelper(actionTypes.UPDATE_CALL, id, params);
}

function holdCall(id, options) {
  return callActionHelper(actionTypes.CALL_HOLD, id, options);
}

function holdCallFinish(id, params) {
  return callActionHelper(actionTypes.CALL_HOLD_FINISH, id, params);
}

function holdRemoteCallFinish(id, params) {
  return callActionHelper(actionTypes.CALL_REMOTE_HOLD_FINISH, id, params);
}

function unholdCall(id, options) {
  return callActionHelper(actionTypes.CALL_UNHOLD, id, options);
}

function unholdCallFinish(id, params) {
  return callActionHelper(actionTypes.CALL_UNHOLD_FINISH, id, params);
}

function unholdRemoteCallFinish(id, params) {
  return callActionHelper(actionTypes.CALL_REMOTE_UNHOLD_FINISH, id, params);
}

function addMedia(id, params) {
  return callActionHelper(actionTypes.ADD_MEDIA, id, params);
}

function addMediaFinish(id, params) {
  return callActionHelper(actionTypes.ADD_MEDIA_FINISH, id, params);
}

function removeMedia(id, params) {
  return callActionHelper(actionTypes.REMOVE_MEDIA, id, params);
}

function removeMediaFinish(id, params) {
  return callActionHelper(actionTypes.REMOVE_MEDIA_FINISH, id, params);
}

function musicOnHold(id, params) {
  return callActionHelper(actionTypes.MUSIC_ON_HOLD, id, params);
}

function sendDTMF(id, params) {
  return callActionHelper(actionTypes.SEND_DTMF, id, params);
}

function sendDTMFFinish(id, params) {
  return callActionHelper(actionTypes.SEND_DTMF_FINISH, id, params);
}

function getStats(id, params) {
  return callActionHelper(actionTypes.GET_STATS, id, params);
}

function getStatsFinish(id, params) {
  return callActionHelper(actionTypes.GET_STATS_FINISH, id, params);
}

/***/ }),

/***/ "./src/call/interfaceNew/actions/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.turnActions = exports.callActions = undefined;

var _call = __webpack_require__("./src/call/interfaceNew/actions/call.js");

var callActionsImport = _interopRequireWildcard(_call);

var _turn = __webpack_require__("./src/call/interfaceNew/actions/turn.js");

var turnActionsImport = _interopRequireWildcard(_turn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Apparently the following doesn't work:
//      export * as newName from './place';
// So import everything from each file, then re-export.
const callActions = exports.callActions = callActionsImport;
const turnActions = exports.turnActions = turnActionsImport;

/***/ }),

/***/ "./src/call/interfaceNew/actions/turn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.turnChanged = turnChanged;

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Represents that TURN information has changed.
 * @method turnChanged
 * @return {Object}
 */
function turnChanged({ servers, credentials }) {
  return {
    type: actionTypes.TURN_CHANGED,
    payload: {
      servers,
      credentials
    }
  };
} // Call plugin.

/***/ }),

/***/ "./src/call/interfaceNew/api/call.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = callAPI;

var _actions = __webpack_require__("./src/call/interfaceNew/actions/index.js");

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _normalization = __webpack_require__("./src/call/utils/normalization.js");

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _constants = __webpack_require__("./src/call/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Call plugin.
function callAPI({ dispatch, getState }) {
  return {
    /**
     * Starts an outgoing call to a SIP user or a PSTN phone number.
     *
     * The call will be tracked by a unique ID that is returned by the API. The
     *    application will use this ID to identify and control the call after it
     *    has been initiated.
     *
     * The `getCallById` API can be used to retrieve the current state of the
     *    call.
     *
     * The SDK will emit a `call:start` event locally when the operation
     *    completes. When the remote participant receives the call, a
     *    `call:receive` event will be emitted remotely for them.
     *
     * The SDK requires access to the machine's media devices (eg. microphone)
     *    in order to make a call. If it does not already have permissions to
     *    use the devices, the user may be prompted by the browser to give
     *    permissions.
     * @public
     * @memberof Calls
     * @method make
     * @param {string} destination The address of the desired remote participant. The format is either
     * 'sip:sipuser@sip.domain.example.com' for SIP calls or 'tel:18881239876' for PSTN calls.
     * @param {Object} [media] The media options the call should be initialized with.
     * @param {Boolean} [media.audio=true] Whether the call should have audio on start. Currently, audio-less calls are not supported.
     * @param {Boolean} [media.video=false] Whether the call should have video on start.
     * @returns {string} The generated ID of the newly created call.
     * @example
     * // Listen for the event emitted after making a call.
     * client.on('call:start', function (params) {
     *   const { callId, error } = params
     *   if (error) {
     *     // Call failed to initialize.
     *   } else {
     *     // Call was initialized, and the recipient user will be notified.
     *   }
     * })
     * // Make an audio-only call.
     * const newCallId = client.call.make(callee, { audio: true })
     */
    make(destination, media = {}, options = {}) {
      const callId = (0, _v2.default)();

      const mediaConstraints = {
        audio: media.audio && !(0, _fp.isEmpty)(media.audioOptions) ? media.audioOptions : media.audio,
        video: media.video && !(0, _fp.isEmpty)(media.videoOptions) ? media.videoOptions : media.video
      };

      dispatch(_actions.callActions.makeCall(callId, (0, _extends3.default)({
        participantAddress: (0, _normalization.normalizeSipUri)(destination),
        mediaConstraints
      }, options)));
      return callId;
    },

    /**
     * Rejects an incoming call.
     *
     * The specified call to reject must be in a ringing state with an incoming
     *    direction. The call will be ended as a result of the operation.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. The remote participant will be notified, through their own
     *    `call:stateChange` event, that the call was rejected.
     * @public
     * @memberof Calls
     * @method reject
     * @param {string} callId The ID of the call to reject.
     */
    reject(callId) {
      dispatch(_actions.callActions.rejectCall(callId));
    },

    /**
     * Answers an incoming call.
     *
     * The specified call to answer must be in a ringing state with an incoming
     *    direction. The call will become connected as a result of the operation.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. This indicates that the call has connected with the remote
     *    participant. The `getCallById` API can be used to retrieve the latest
     *    call state after the change. Further events will be emitted to
     *    indicate that the call has received media from the remote participant.
     *     See the `call:newTrack` event for more information about this.
     *
     * The SDK requires access to the machine's media devices (eg. microphone)
     *    in order to answer a call. If it does not already have permissions to
     *    use the devices, the user may be prompted by the browser to give
     *    permissions.
     * @public
     * @memberof Calls
     * @method answer
     * @param {string} callId The ID of the call to answer.
     * @param {Object} [media] The media options the call should be initialized with.
     * @param {Boolean} [media.audio=true] Whether the call should have audio on start. Currently, audio-less calls are not supported.
     * @param {Boolean} [media.video=false] Whether the call should have video on start.
     */
    answer(callId, media = {}, options = {}) {
      const mediaConstraints = {
        audio: media.audio && !(0, _fp.isEmpty)(media.audioOptions) ? media.audioOptions : media.audio,
        video: media.video && !(0, _fp.isEmpty)(media.videoOptions) ? media.videoOptions : media.video
      };

      dispatch(_actions.callActions.answerCall(callId, (0, _extends3.default)({
        mediaConstraints
      }, options)));
    },

    /**
     * Ignores an incoming call.
     *
     * The specified call to ignore must be in a ringing state with an incoming
     *    direction. The call will be ended as a result of the operation.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. The remote participant will not be notified that the call
     *    was ignored.
     * @public
     * @memberof Calls
     * @method ignore
     * @param {string} callId The ID of the call to ignore.
     */
    ignore(callId) {
      dispatch(_actions.callActions.ignoreCall(callId));
    },

    /**
     * Puts a call on hold.
     *
     * The specified call to hold must not already be locally held. Any/all
     *    media received from the remote participant will stop being received,
     *    and any/all media being sent to the remote participant will stop
     *    being sent.
     *
     * Some call operations cannot be performed while the call is on hold. The
     *    call can be taken off hold with the `unhold` API.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. The remote participant will be notified of the operation
     *    through a `call:stateChange` as well.
     * @public
     * @memberof Calls
     * @method hold
     * @param {string} callId The ID of the call to hold.
     */
    hold(callId) {
      dispatch(_actions.callActions.holdCall(callId));
    },

    /**
     * Takes a call off hold.
     *
     * The specified call to unhold must be locally held. If the call is not
     *    also remotely held, call media will be reconnected as it was before
     *    the call was held.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. The remote participant will be notified of the operation
     *    through a `call:stateChange` as well.
     * @public
     * @memberof Calls
     * @method unhold
     * @param {string} callId The ID of the call to unhold.
     */
    unhold(callId) {
      dispatch(_actions.callActions.unholdCall(callId));
    },

    /**
     * Retrieves the state of calls made during the current session.
     * @public
     * @memberof Calls
     * @method getAll
     * @return {Array<CallObject>} Call objects.
     * @example
     * let calls = client.call.getAll();
     * let currentCalls = calls.filter(call => {
     *     return call.state === client.call.states.CONNECTED;
     * });
     */
    getAll() {
      return (0, _selectors.getCalls)(getState());
    },

    /**
     * Retrieves a single call from state with a specific call ID.
     * @public
     * @memberof Calls
     * @method getById
     * @param {string} callId The ID of the call to retrieve.
     * @return {CallObject} A call object.
     */
    getById(callId) {
      return (0, _selectors.getCallById)(getState(), callId);
    },

    /**
     * Ends an ongoing call.
     *
     * The SDK will stop any/all local media associated with the call. Events
     *    will be emitted to indicate which media tracks were stopped. See the
     *    `call:trackEnded` event for more information.
     *
     * The SDK will emit a `call:stateChange` event locally when the operation
     *    completes. The remote participant will be notified, through their own
     *    `call:stateChange` event, that the call was ended.
     * @public
     * @memberof Calls
     * @method end
     * @param {string} callId The ID of the call to end.
     */
    end(callId) {
      dispatch(_actions.callActions.endCall(callId));
    },

    /**
     * Add new media tracks to an ongoing call.
     * Will get new media tracks from the specific sources to add to the call.
     * Will trigger a `call:newMedia` event.
     * @public
     * @memberof Calls
     * @param {string} callId The ID of the call to add media to.
     * @param {Object} [media={}] The media options to add to the call.
     * @param {Boolean} [media.audio=false] Whether to add audio to the call.
     * @param {Boolean} [media.video=false] Whether to add video to the call.
     */
    addMedia(callId, media = {}) {
      const mediaConstraints = {
        audio: media.audio && !(0, _fp.isEmpty)(media.audioOptions) ? media.audioOptions : media.audio,
        video: media.video && !(0, _fp.isEmpty)(media.videoOptions) ? media.videoOptions : media.video
      };

      dispatch(_actions.callActions.addMedia(callId, { mediaConstraints }));
    },

    /**
     * Remove tracks from an ongoing call
     * @public
     * @memberof Calls
     * @param {string} callId The ID of the call to remove media from.
     * @param {Array} tracks A list of track IDs to remove.
     */
    removeMedia(callId, tracks) {
      dispatch(_actions.callActions.removeMedia(callId, { tracks }));
    },

    /**
     * Send DTMF tones on an ongoing call.
     *
     * @public
     * @memberof Calls
     * @method sendDTMF
     * @param {string} callId Id of the call being acted on.
     * @param {string} tone DTMF tone to send. Valid values are ['0','1','2','3','4','5','6','7','8','9','#','*' and ','].
     * @param {number} [duration=100] The amount of time, in milliseconds, that each DTMF tone should last.
     * @param {number} [intertoneGap=70] The length of time, in milliseconds, to wait between tones.
     *
     */
    sendDTMF(callId, tone, duration = 100, intertoneGap = 70) {
      dispatch(_actions.callActions.sendDTMF(callId, { tone, duration, intertoneGap }));
    },

    /**
     * Get a report about low-level call stats / information.
     * A track ID can optionally be provided to get a report for the specific track of the call.
     * @public
     * @memberof Calls
     * @param {string} callId The ID of the call to retrieve stats report.
     * @param {string} [trackId] TrackId. If trackId is not provided, RTCStatsReport is gererated from the peerConnection.
     */
    getStats(callId, trackId) {
      dispatch(_actions.callActions.getStats(callId, { trackId }));
    },

    /**
     * Possible states for a call.
     *
     * @public
     * @memberof Calls
     * @type {Object}
     * @property {string} INITIATING The (outgoing) call is being started.
     * @property {string} INITIATED The (outgoing) call has been sent over the network, but has not been received.
     * @property {string} RINGING The call has been received by both parties, and is waiting to be answered.
     * @property {string} CANCELLED The call was disconnected before it could be answered.
     * @property {string} CONNECTED Both parties are connected and media is flowing.
     * @property {string} ON_HOLD Both parties are connected but no media is flowing.
     * @property {string} ENDED The call has ended.
     * @example
     * // Use the call states to know how to handle a change in the call.
     * client.on('call:stateChange', function (params) {
     *    const call = client.call.getById(params.callId)
     *    // Check if the call now has media flowing.
     *    if (call.state === client.call.states.CONNECTED) {
     *      // Render call media ...
     *    }
     * })
     */
    states: _constants.CALL_STATES
  };
}

// Libraries.

/***/ }),

/***/ "./src/call/interfaceNew/api/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _call = __webpack_require__("./src/call/interfaceNew/api/call.js");

var _call2 = _interopRequireDefault(_call);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The call feature is used to make audio and video calls to and from
 * SIP users and PSTN phones.
 *
 * Call functions are all part of the 'call' namespace.
 *
 * @public
 * @module Calls
 */

// TODO: Does the following apply to the new call stack?
/**
 * The state representation of a Call.
 * Can be retrieved using the Call feature's `getAll` or `getById` APIs.
 * A Call can be manipulated by using the Call feature's APIs.
 *
 * @public
 * @module CallObject
 * @property {string} direction The direction in which the call was created (outgoing/incoming).
 * @property {string} id The ID of the call.
 * @property {boolean} localHold Indicates whether this call is currently being held locally.
 * @property {Array<string>} localTracks A list of Track IDs that the call is sending to the remote participant.
 * @property {Object} mediaConstraints This indicates the media types that the call was initialized with.
 * @property {boolean} mediaConstraints.audio Whether the call was initialized with audio.
 * @property {boolean} mediaConstraints.video Whether the call was initialized with video.
 * @property {boolean} remoteHold Indicates whether this call is currently being held remotely.
 * @property {Array<string>} remoteTracks A list of Track IDs that the call is receiving from the remote participant.
 * @property {Object} remoteParticipant Information about the other call participant.
 * @property {string} remoteParticipant.displayNumber The username with domain of the callee in the form "username@domain"
 * @property {string} remoteParticipant.displayName The display name of the callee
 * @property {number} startTime The start time of the call in milliseconds since the epoch.
 * @property {string} state The current state of the call. See `Call.states` for possible states.
 */

/**
 * The media features are used to interact with media that the SDK is
 * currently using.
 *
 * Media functions are all part of the 'media' namespace.
 *
 * @public
 * @module Media
 */

/**
 * The state representation of a Media object.
 * Media is a collection of Track objects.
 *
 * @public
 * @module MediaObject
 * @property {string} id The ID of the Media object.
 * @property {boolean} local Indicator on whether this media is local or remote.
 * @property {Array<TrackObject>} tracks A list of Track objects that are contained in this Media object.
 */

/**
 * A Track is a stream of audio or video media from a single source.
 * Tracks can be retrieved using the Media module's `getTrackById` API and manipulated with other functions of the Media module.
 *
 * @public
 * @module TrackObject
 * @property {Array<string>} containers The list of CSS selectors that were used to render this Track.
 * @property {boolean} disabled Indicator of whether this Track is disabled or not. If disabled, it cannot be re-enabled.
 * @property {string} id The ID of the Track.
 * @property {string} kind The kind of Track this is (audio, video).
 * @property {string} label The label of the device this Track uses.
 * @property {boolean} muted Indicator on whether this Track is muted or not.
 * @property {string} state The state of this Track. Can be 'live' or 'ended'.
 * @property {string} streamId The ID of the Media Stream that includes this Track.
 */

/**
 * A collection of devices and their information.
 *
 * @public
 * @module DevicesObject
 * @property {Array<DeviceInfo>} camera A list of camera device information.
 * @property {Array<DeviceInfo>} microphone A list of microphone device information.
 * @property {Array<DeviceInfo>} speaker A list of speaker device information.
 */

/**
 * Contains information about a device.
 *
 * @public
 * @module DeviceInfo
 * @property {string} deviceId The ID of the device.
 * @property {string} groupId The group ID of the device. Devices that share a `groupId` belong to the same physical device.
 * @property {string} kind The type of the device (audioinput, audiooutput, videoinput).
 * @property {string} label The name of the device.
 */

/**
 * Call API index.
 * APIs are organized by their namespacing.
 * @method api
 * @param {Object} context
 * @param {Function} context.dispatch The redux store's dispatch function.
 * @param {Function} context.getState The redux store's getState function.
 * @return {Object} The plugin's API object.
 */
function api(context) {
  return {
    call: (0, _call2.default)(context)
  };
}

/***/ }),

/***/ "./src/call/interfaceNew/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * An outgoing call has been started.
 * The call state can be retrieved using the `getById(callId)` API.
 *
 * @public
 * @memberof Calls
 * @event call:start
 * @param {Object} params
 * @param {string} params.callId The Id of the call.
 * @param {BasicError} [params.error] An error object, if the operation was not successful.
 */
const CALL_STARTED = exports.CALL_STARTED = 'call:start';

/**
 * A new incoming call has been received.
 * The call state can be retrieved using the `getById(callId)` API.
 *
 * @public
 * @memberof Calls
 * @event call:receive
 * @param {Object} params
 * @param {string} params.callId The Id of the call.
 * @param {BasicError} [params.error] An error object, if the operation was not successful.
 * @example
 * client.on('call:receive', function(params) {
 *     // We have received a call, prompt the user to respond.
 *     promptUser(client.call.getById(params.callId));
 * });
 */
const CALL_INCOMING = exports.CALL_INCOMING = 'call:receive';

/**
 * A call's state has changed.
 * See `Call.states` for possible call states.
 * @public
 * @memberof Calls
 * @event call:stateChange
 * @param {Object} params
 * @param {string} params.callId The ID of the Media object that was operated on.
 * @param {Object} params.previous The call's properties before the operation changed it.
 * @param {string} params.previous.state The previous state of the call.
 * @param {boolean} [params.previous.localHold] The previous local hold state. Present when the state change was a hold/unhold operation.
 * @param {boolean} [params.previous.remoteHold] The previous remote hold state. Present when the state change was a hold/unhold operation.
 * @param {BasicError} [params.error] An error object, if the operation was not successful.
 * @example
 * client.on('call:stateChange', function (params) {
 *     const call = client.call.getById(params.callId)
 *     const prevState = params.previous.state
 *     log(`Call changed from ${prevState} to ${call.state} state.`)
 *
 *     // Handle the event depending on the new call state.
 *     switch (call.state) {
 *         case client.call.states.CONNECTED:
 *             // Handle being on call with media.
 *             break
 *         case client.call.states.ENDED:
 *             // Handle call ending.
 *             break
 *         ...
 *     }
 * })
 */
const CALL_STATE_CHANGE = exports.CALL_STATE_CHANGE = 'call:stateChange';

/**
 * New media has been added to the call.
 * @public
 * @memberof Calls
 * @event call:newMedia
 * @param {Object} params
 * @param {string} params.callId The Id of the call.
 * @param {boolean} params.local Whether the new media is local or not.
 * @param {Array} params.tracks The list of new Tracks.
 * @param {string} params.mediaId The Id of the Media object the Tracks belong to.
 */
const CALL_ADDED_MEDIA = exports.CALL_ADDED_MEDIA = 'call:newMedia';

/**
 * Media has been removed from the call
 * @public
 * @memberof Calls
 * @event call:removedMedia
 * @param {Object} params
 * @param {string} params.callId The Id of the call.
 * @param {boolean} params.local Whether the new media is local or not.
 * @param {Array} params.tracks The list of new Tracks.
 */
const CALL_REMOVED_MEDIA = exports.CALL_REMOVED_MEDIA = 'call:removedMedia';

/**
 * The call has received a new Track.
 * @public
 * @memberof Calls
 * @event call:newTrack
 * @param {Object} params
 * @param {string} params.callId The ID of the call the track was added to.
 * @param {string} params.mediaId The ID of the media the track was added to.
 * @param {string} params.trackId The ID of the newly added track.
 * @param {boolean} params.local Whether the track is local or not (remote)
 */
const CALL_NEW_TRACK = exports.CALL_NEW_TRACK = 'call:newTrack';

/**
 * The call has received a new Track.
 * @public
 * @memberof Calls
 * @event call:trackEnded
 * @param {Object} params
 * @param {string} params.callId The ID of the call the track was added to.
 * @param {string} params.mediaId The ID of the media the track was added to.
 * @param {string} params.trackId The ID of the newly added track.
 * @param {boolean} params.local Whether the track is local or not (remote)
 */
const CALL_TRACK_ENDED = exports.CALL_TRACK_ENDED = 'call:trackEnded';

/**
 * Stats have been retrieved for a call or specific track.
 * @public
 * @memberof Calls
 * @event call:statsReceived
 * @param {Object} params
 * @param {string} params.callId The ID of the call to retrieve stats for.
 * @param {string} [params.trackId] The ID of the track to retrieve stats for.
 * @param {string} params.result The RTCStatsReport.
 * @param {BasicError} [params.error] An error object, if the operation was not successful.
 */
const STATS_RECEIVED = exports.STATS_RECEIVED = 'call:statsReceived';

/***/ }),

/***/ "./src/call/interfaceNew/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.callEvents = undefined;

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _eventTypes = __webpack_require__("./src/call/interfaceNew/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actionTypes2 = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var webrtcActionTypes = _interopRequireWildcard(_actionTypes2);

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper function to format call events.
 * @method callEventHandler
 * @param  {string} type        The type of event.
 * @param  {Object} action      The action that triggered the event.
 * @param  {Object} [params={}] Any non-consistent information to be included in the event.
 * @return {Object} An event object.
 */


// Webrtc plugin.
// Call plugin.
function callEventHandler(type, action, params = {}) {
  /**
   * Call event format.
   * Call events follow a consistent format, based on the consistent format of
   *    their actions.
   */
  return {
    type,
    args: (0, _extends3.default)({
      callId: action.payload.id,
      error: action.error
    }, params)
  };
}

/**
 * Helper function for converting an action to a "call state change" event.
 * Ensures that all such events have consistent parameters.
 * @method stateChangeHandler
 * @param  {Object} action
 * @param  {Object} params
 * @param  {Object} params.prevState Redux state from before the action was processed by reducers.
 * @param  {Object} params.state     Redux state from after the action was processed by reducers.
 * @return {Object} An event object.
 */


// Helpers
function stateChangeHandler(action, params) {
  // Get the call state before this action updated state.
  const prevCall = (0, _selectors.getCallById)(params.prevState, action.payload.id);

  return callEventHandler(eventTypes.CALL_STATE_CHANGE, action, {
    error: action.payload.error,
    previous: {
      state: prevCall.state,
      localHold: prevCall.localHold,
      remoteHold: prevCall.remoteHold
    }
  });
}

const callEvents = exports.callEvents = {};

callEvents[actionTypes.MAKE_CALL_FINISH] = action => {
  return callEventHandler(eventTypes.CALL_STARTED, action, {
    error: action.payload.error
  });
};

callEvents[actionTypes.CALL_INCOMING] = action => {
  return callEventHandler(eventTypes.CALL_INCOMING, action, {
    error: action.payload.error
  });
};

callEvents[actionTypes.CALL_RINGING] = stateChangeHandler;
callEvents[actionTypes.CALL_CANCELLED] = stateChangeHandler;

callEvents[actionTypes.ANSWER_CALL_FINISH] = (action, params) => {
  // Don't emit an event if it was a slow start answer. The call isn't actually
  //    answered yet, so state hasn't changed.
  if (action.meta.isSlowStart) {
    return;
  }

  return stateChangeHandler(action, params);
};

callEvents[actionTypes.CALL_ACCEPTED] = stateChangeHandler;
callEvents[actionTypes.IGNORE_CALL_FINISH] = stateChangeHandler;
callEvents[actionTypes.END_CALL_FINISH] = stateChangeHandler;
callEvents[actionTypes.CALL_HOLD_FINISH] = stateChangeHandler;
callEvents[actionTypes.CALL_UNHOLD_FINISH] = stateChangeHandler;
callEvents[actionTypes.CALL_REMOTE_HOLD_FINISH] = stateChangeHandler;
callEvents[actionTypes.CALL_REMOTE_UNHOLD_FINISH] = stateChangeHandler;

callEvents[actionTypes.ADD_MEDIA_FINISH] = action => {
  return callEventHandler(eventTypes.CALL_ADDED_MEDIA, action, {
    local: action.payload.local,
    tracks: action.payload.tracks,
    mediaId: action.payload.mediaId,
    error: action.payload.error
  });
};

callEvents[actionTypes.REMOVE_MEDIA_FINISH] = action => {
  return callEventHandler(eventTypes.CALL_REMOVED_MEDIA, action, {
    local: action.payload.local,
    tracks: action.payload.tracks,
    error: action.payload.error
  });
};

callEvents[actionTypes.GET_STATS_FINISH] = action => {
  return callEventHandler(eventTypes.STATS_RECEIVED, action, {
    result: action.payload.result,
    error: action.payload.error,
    trackId: action.payload.trackId
  });
};

callEvents[webrtcActionTypes.SESSION_NEW_TRACK] = (action, context) => {
  const state = context.state;
  const call = (0, _selectors.getCallByWebrtcSessionId)(state, action.payload.id);

  if (call) {
    // By passing callId in the params object it will overwrite
    // callId that is set in callEventHandler
    return callEventHandler(eventTypes.CALL_NEW_TRACK, action, (0, _extends3.default)({}, action.payload, {
      callId: call.id
    }));
  }
  return null;
};

callEvents[webrtcActionTypes.SESSION_TRACK_ENDED] = (action, context) => {
  const state = context.state;
  const call = (0, _selectors.getCallByWebrtcSessionId)(state, action.payload.id);

  if (call) {
    return callEventHandler(eventTypes.CALL_TRACK_ENDED, action, (0, _extends3.default)({}, action.payload, {
      callId: call.id
    }));
  }
};

exports.default = (0, _extends3.default)({}, callEvents);

/***/ }),

/***/ "./src/call/interfaceNew/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/call/interfaceNew/api/index.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/call/interfaceNew/reducers/index.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This interface is for a call plugin.
 * @type {string}
 */
// Import the components of the interface.
const name = 'call';

// Export the interface as a single object.
exports.default = {
  name,
  api: _api2.default,
  reducer: _reducers2.default
};

/***/ }),

/***/ "./src/call/interfaceNew/reducers/call.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _constants = __webpack_require__("./src/call/constants.js");

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Top-tier reducers: Handles the whole call state.


// Libraries.
// Call plugin.
const reducers = {};
// Call-tier reducers: Handles only a specific call's state.
const callReducers = {};

/*
 * Top-tier reducers.
 * Receives the entire call substate as state.
 */

// Add the new call to state.
reducers[actionTypes.MAKE_CALL] = {
  next(state, action) {
    // TODO: Call model? (with defaults for call state)
    const newCall = {
      id: action.payload.id,
      remoteParticipant: {
        displayNumber: action.payload.participantAddress,
        displayName: action.payload.participantName
      },
      mediaConstraints: action.payload.mediaConstraints,
      // TODO: Proper constants.
      state: _constants.CALL_STATES.INITIATING,
      direction: 'outgoing',
      // Hold status.
      localHold: false,
      remoteHold: false,
      isCaller: true
    };

    return (0, _fp.concat)(state, newCall);
  }
};

// Add the new call to state.
reducers[actionTypes.CALL_INCOMING] = {
  next(state, action) {
    return (0, _fp.concat)(state, (0, _extends3.default)({
      isCaller: false
    }, action.payload));
  }
};

/*
 * Call-tier reducers.
 * Receive a single call's state as state.
 */

callReducers[actionTypes.CALL_RINGING] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      state: _constants.CALL_STATES.RINGING
    });
  }
};

/*
 * Call-tier reducers.
 * Receive a single call's state as state.
 */

callReducers[actionTypes.CALL_CANCELLED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      state: _constants.CALL_STATES.CANCELLED
    });
  }
};

callReducers[actionTypes.IGNORE_CALL_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      state: _constants.CALL_STATES.ENDED
    });
  }
};

callReducers[actionTypes.REJECT_CALL_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      state: _constants.CALL_STATES.ENDED
    });
  }
};

// Update the new call state based on the outcome.
callReducers[actionTypes.MAKE_CALL_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      state: action.payload.state,
      wrtcsSessionId: action.payload.wrtcsSessionId,
      webrtcSessionId: action.payload.webrtcSessionId
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, action.payload);
  }
};

// Update the call state based on the outcome.
callReducers[actionTypes.ANSWER_CALL_FINISH] = {
  next(state, action) {
    // If the action has a Session ID, store it as the ID.
    // In some scenarios (slow start), the we only get an ID
    //    at the answer step.
    const webrtcId = action.payload.webrtcSessionId || state.webrtcSessionId;

    return (0, _extends3.default)({}, state, {
      state: action.payload.state,
      webrtcSessionId: webrtcId,
      localHold: false,
      remoteHold: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, action.payload);
  }
};

callReducers[actionTypes.CALL_ACCEPTED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, action.payload);
  }
};

// Handles both success and failure actions the same way.
// Instead of an object with `next` & `throw` properties, pass in a function.
// https://redux-actions.js.org/api/handleaction#handleactiontype-reducer-defaultstate
callReducers[actionTypes.END_CALL_FINISH] = (state, action) => {
  return (0, _extends3.default)({}, state, {
    state: _constants.CALL_STATES.ENDED
  });
};

callReducers[actionTypes.UPDATE_CALL] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, action.payload);
  }
};

callReducers[actionTypes.MUSIC_ON_HOLD] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, action.payload);
  }
};

callReducers[actionTypes.CALL_HOLD_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      localHold: true,
      state: _constants.CALL_STATES.ON_HOLD
    });
  }
};

callReducers[actionTypes.CALL_UNHOLD_FINISH] = {
  next(state, action) {
    const callState = state.remoteHold ? _constants.CALL_STATES.ON_HOLD : _constants.CALL_STATES.CONNECTED;
    return (0, _extends3.default)({}, state, {
      localHold: false,
      state: callState
    });
  }
};

callReducers[actionTypes.CALL_REMOTE_HOLD_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      remoteHold: true,
      pendingRemoteOp: false,
      state: _constants.CALL_STATES.ON_HOLD
    });
  }
};

callReducers[actionTypes.CALL_REMOTE_UNHOLD_FINISH] = {
  next(state, action) {
    const callState = state.localHold ? _constants.CALL_STATES.ON_HOLD : _constants.CALL_STATES.CONNECTED;
    return (0, _extends3.default)({}, state, {
      remoteHold: false,
      pendingRemoteOp: false,
      state: callState
    });
  }
};

/*
 * Combine all of the call-tier reducers into a single reducer,
 *      each with a default state of empty object.
 */
const callReducer = (0, _reduxActions.handleActions)(callReducers, {});

// Actions routed to call-tier reducers.
const specificCallActions = (0, _reduxActions.combineActions)(actionTypes.MAKE_CALL_FINISH, actionTypes.ANSWER_CALL_FINISH, actionTypes.REJECT_CALL_FINISH, actionTypes.CALL_ACCEPTED, actionTypes.CALL_RINGING, actionTypes.CALL_CANCELLED, actionTypes.IGNORE_CALL_FINISH, actionTypes.END_CALL_FINISH, actionTypes.CALL_HOLD_FINISH, actionTypes.CALL_UNHOLD_FINISH, actionTypes.CALL_REMOTE_HOLD_FINISH, actionTypes.CALL_REMOTE_UNHOLD_FINISH, actionTypes.ADD_MEDIA_FINISH, actionTypes.UPDATE_CALL, actionTypes.MUSIC_ON_HOLD);

/*
 * Reducer to handle specific call actions.
 * Routes the actions to the call-tier reducers.
 */
reducers[specificCallActions] = (state, action) => {
  return state.map(function (call) {
    // Only update the call related to the action.
    if (call.id === action.payload.id) {
      return callReducer(call, action);
    } else {
      return call;
    }
  });
};

/*
 * Combine all of top-tier reducers into a single reducer,
 *      each with a default state of an empty array.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, []);
exports.default = reducer;

/***/ }),

/***/ "./src/call/interfaceNew/reducers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (state = {}, action) {
  return {
    calls: (0, _call2.default)(state.calls, action),
    turn: (0, _turn2.default)(state.turn, action)
  };
};

var _call = __webpack_require__("./src/call/interfaceNew/reducers/call.js");

var _call2 = _interopRequireDefault(_call);

var _turn = __webpack_require__("./src/call/interfaceNew/reducers/turn.js");

var _turn2 = _interopRequireDefault(_turn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/call/interfaceNew/reducers/turn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/call/interfaceNew/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Call plugin.
const reducers = {};

// Replace any previous information with the new information.


// Libraries.
reducers[actionTypes.TURN_CHANGED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      servers: action.payload.servers || state.servers,
      credentials: (0, _extends3.default)({}, state.credentials, action.payload.credentials)
    });
  }
};

/*
 * Combine all of top-tier reducers into a single reducer.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, {});
exports.default = reducer;

/***/ }),

/***/ "./src/call/interfaceNew/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.getCalls = getCalls;
exports.getActiveCalls = getActiveCalls;
exports.getCallById = getCallById;
exports.getCallByWrtcsSessionId = getCallByWrtcsSessionId;
exports.getCallByWebrtcSessionId = getCallByWebrtcSessionId;
exports.getOptions = getOptions;
exports.getTurnInfo = getTurnInfo;

var _constants = __webpack_require__("./src/call/constants.js");

var _selectors = __webpack_require__("./src/webrtc/interface/selectors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Call selectors.
 * Handles retrieving data from the `state.call.calls` substate.
 */

/**
 * Helper function for adding track information to call state.
 * @method addTracksToCall
 * @param  {Object} state
 * @param  {Object} callState
 * @return {Object} Track augmented call state.
 */
// Call plugin.
function addTracksToCall(state, callState) {
  const session = (0, _selectors.getSessionById)(state, callState.webrtcSessionId);
  if (session) {
    return (0, _extends3.default)({}, callState, {
      localTracks: session.localTracks,
      remoteTracks: session.remoteTracks
    });
  } else {
    return (0, _extends3.default)({}, callState, {
      localTracks: [],
      remoteTracks: []
    });
  }
}

/**
 * Get the list of all calls this session.
 * @method getCalls
 * @param  {Object} state Redux state.
 * @return {Array} A list of all call objects.
 */


// Webrtc plugin.
function getCalls(state) {
  // TODO: cloneDeep?
  return state.call.calls.map(callState => addTracksToCall(state, callState));
}

/**
 * Retrieves the list of all on-going calls.
 * @method getActiveCalls
 * @param {Object} state Redux state.
 * @return {Array} A list of call objects.
 */
function getActiveCalls(state) {
  const endedStates = [_constants.CALL_STATES.ENDED, _constants.CALL_STATES.CANCELLED];

  return getCalls(state).filter(call => !endedStates.includes(call.state));
}

/**
 * Get the call object of a specific call.
 * @method getCallById
 * @param  {Object} state Redux state.
 * @param  {string} callId The call to retrieve.
 * @return {Object} A call object.
 */
function getCallById(state, callId) {
  return getCalls(state).find(call => call.id === callId);
}

/**
 * Get the call object with a specific wrtcsSessionId (backend ID).
 * @method getCallByWrtcsSessionId
 * @param  {Object} state Redux state.
 * @param  {string} wrtcsSessionId The call to retrieve.
 * @return {Object} A call object.
 */
function getCallByWrtcsSessionId(state, wrtcsSessionId) {
  return getCalls(state).find(call => call.wrtcsSessionId === wrtcsSessionId);
}

/**
 * Get the call object with a specific webrtcSessionId.
 * @method getCallByWebrtcSessionId
 * @param  {Object} state Redux state.
 * @param  {string} webrtcSessionId The call to retrieve.
 * @return {Object} A call object.
 */
function getCallByWebrtcSessionId(state, webrtcSessionId) {
  return getCalls(state).find(call => call.webrtcSessionId === webrtcSessionId);
}

/**
 * Retrieve the call plugin's options.
 * @method getOptions
 * @param  {Object} state Redux state.
 * @return {Object}
 */
function getOptions(state) {
  return state.config.call;
}

/**
 * Retrieve TURN server/credential information.
 */
function getTurnInfo(state) {
  return state.call.turn;
}

/***/ }),

/***/ "./src/call/utils/normalization.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeSipUri = normalizeSipUri;
/**
 * Extracts the domain from an address if an @ symbol exists and isn't at the start or end of the address.
 * @param {string} addressString The address string to extract the domain from (if it exists).
 * @returns {string} The extracted domain. Empty string of none found.
 */
function extractDomainFromAddress(addressString) {
  const indexOfAtSymbol = addressString.indexOf('@');
  if (indexOfAtSymbol !== 0 && indexOfAtSymbol !== addressString.length - 1) {
    // If '@' symbol found in middle of addressString, split it.
    if (indexOfAtSymbol !== -1) {
      return addressString.substr(indexOfAtSymbol + 1);
    }
  }
  return '';
}

/**
 * Determines which address and domain to use depending on whether the address string contains a domain or not.
 * @param {string} addressString The address string to examine and extract a domain from (if any).
 * @param {string} defaultDomainString The domain to use if the address string does not contain a domain in it.
 * @returns {Object} An object containing the correct address and domain to use.
 */
function separateAddressAndDomain(addressString, defaultDomainString) {
  const extractedDomain = extractDomainFromAddress(addressString);
  // If a domain was extracted from the address, use that as the domain and strip it from the address.
  if (extractedDomain) {
    return {
      address: addressString.substr(0, addressString.length - extractedDomain.length - 1),
      domain: extractedDomain
    };
  } else {
    return {
      address: addressString,
      domain: defaultDomainString
    };
  }
}

/**
 * Extracts any pre-pended data before a ":" (if it exists) from the beginning of a string.
 * @param {string} inputString The string to remove pre-pended data from.
 * @returns {string} The pre-pended data string.
 */
function extractPrependedData(inputString) {
  const prependedDataMatches = inputString.match(/^.*:/g);
  if (prependedDataMatches && prependedDataMatches[0]) {
    return prependedDataMatches[0];
  } else {
    return '';
  }
}

/**
 * Finds the leading special characters ("#", "+", "*") of an address if it is a phone number.
 * If the address contains letters or any non-visual-separator characters,
 *  it is not a phone number and no leading special characters will be found.
 * @param {string} addressString The address string to find the leading characters of (if any).
 *  The addressString must not contain any pre-pended data such as "sip:".
 *  The addressString must not contain a domain.
 * @returns {string} The leading special characters as one string. Empty string if none found.
 */
function extractLeadingSpecialCharacters(addressString) {
  // A single or group of contiguous characters are considered leading character/s if it is  the following:
  // - starts at the beginning of the string - ^
  // - is any of the following characters - [#+*]+
  // - is followed by a digit or "(" - [\d|(]
  // - is followed by any number of only digits and visual separators - [\d \-.()+]*$
  const potentialLeadingChars = addressString.match(/^[#+*]+[\d|(][\d \-.()+]*$/g);
  if (potentialLeadingChars && potentialLeadingChars[0]) {
    // Guaranteed to have a match for regex [#+*]+ since we have potentialLeadingChars
    // which was a match for a similar regex and we are simply extracting the leading characters part.
    const actualLeadingChars = potentialLeadingChars[0].match(/[#+*]+/g);
    return actualLeadingChars[0];
  }
  return '';
}

/**
 * Outputs a new string without its phone number visual separators ("-", ".", "(", ")", "+").
 * @param {string} inputString The string to remove visual separators from.
 * @returns {string} A new string without visual separators.
 */
function withoutVisualSeparators(inputString) {
  return inputString.replace(/[ \-.()+]/g, '');
}

/**
 * Determines whether a string should be considered a phone number or not.
 * @param {string} addressString The address string to check.
 *  The addressString must not contain any pre-pended data such as "sip:"
 *  The addressString must not contain any leading special characters.
 *  The addressString must not contain a domain.
 * @returns {boolean} True if the input string is a phone number. False if it is not.
 */
function isPhoneNumber(addressString) {
  const cleanNumber = withoutVisualSeparators(addressString);
  const phoneNumberMatch = cleanNumber.match(/^\d+$/g);
  return phoneNumberMatch && phoneNumberMatch.length === 1;
}

/**
 * Processes the address string and returns the correct output.
 * If the address is a phone number, visual separators are removed.
 * Otherwise, it will just return the address as-is.
 * @param {string} addressString The address string to process.
 *  The addressString must not contain any pre-pended data such as "sip:".
 *  The addressString must not contain any leading special characters (if it is a phone number).
 *  The addressString must not contain a domain.
 * @returns {string} A phone number without visual-separators or the addressString as-is.
 */
function processAddress(addressString) {
  return isPhoneNumber(addressString) ? withoutVisualSeparators(addressString) : addressString;
}

/**
 * Processes the domain string and returns the correct output.
 * Adds an "@" symbol if it isn't present at the beginning of the domain.
 * @param {string} domainString The domain string to process.
 * @returns {string} The domain with "@" symbol at the beginning if it doesn't exist.
 */
function processDomain(domainString) {
  return (domainString.indexOf('@') === 0 ? '' : '@') + domainString;
}

/**
 *The function takes in the input dial string and domain address of the user, performs a normalization process based on the phone number handling normalization rules
 * @function normalizeSipUri
 * @param {string} address   It contains the input dial string the user dials in or the callee address
 * @param {string} domain    It contains the user's domain address
 * @returns {string} output  The output which is the normalized callee address/phone number
 */
function normalizeSipUri(address, domain) {
  // Remove leading and trailing white spaces.
  address = address.trim();

  // Extract domain.
  const resultingAddressAndDomain = separateAddressAndDomain(address, domain);
  domain = resultingAddressAndDomain.domain;
  address = resultingAddressAndDomain.address;

  // Extract pre-pended "sip:".
  const prepend = extractPrependedData(address);
  address = address.substr(prepend.length);

  // Extract leading characters.
  const leadingChars = extractLeadingSpecialCharacters(address);
  address = address.substr(leadingChars.length);

  // Process and build parts into final output in the form of `<prepend>:<leadingChars><address>@<domain>`.
  return 'sip:' + leadingChars + processAddress(address) + processDomain(domain);
}

/***/ }),

/***/ "./src/callstack/sagas/establish.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupCall = setupCall;
exports.setupIncomingCall = setupIncomingCall;
exports.answerWebrtcSession = answerWebrtcSession;

var _logs = __webpack_require__("./src/logs/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

// Helpers
const log = (0, _logs.getLogManager)().getLogger('CALLSTACK');

/**
 * Performs the WebRTC portion necessary for establishing outgoing calls
 *
 * @method setupCall
 * @param  {Object} webRTC A WebRTC instance
 * @param  {Object} mediaConstraints Video and audio media constraints
 * @param  {boolean} mediaConstraints.audio Whether to enable audio or not
 * @param  {boolean} mediaConstraints.video Whether to enable video or not
 * @param  {Object} sessionOptions
 * @param  {Object} sessionOptions.sdpSemantics Semantics for Real Time Communication configurations
 * @param  {Object} sessionOptions.turnInfo Contains information required for setting up ICE servers
 * @param  {string} sessionOptions.trickleIceMode What mode to be used for trickle ICE
 * @return {Object} Object
 * @return {string} Object.offerSdp Session Description Protocol for a call offer
 * @return {string} Object.sessionId session identifier
 * @return {string} Object.mediaId call identifier
 */


// Libraries.
function* setupCall(webRTC, mediaConstraints, sessionOptions) {
  const { sdpSemantics, turnInfo, trickleIceMode } = sessionOptions;

  log.debug('Getting media with constraints: ', mediaConstraints);
  const media = yield (0, _effects.call)([webRTC.media, 'createLocal'], mediaConstraints);

  // Create a webRTC session to represent this call.
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'create'], {
    peer: {
      rtcConfig: {
        sdpSemantics,
        iceServers: turnInfo.servers
      },
      trickleIceMode
    }
  });

  // Add the tracks to the session.
  const tracks = yield (0, _effects.call)([media, 'getTracks']);
  yield (0, _effects.call)([session, 'addTracks'], tracks);

  const offer = yield (0, _effects.call)([session, 'generateOffer']);

  return {
    offerSdp: offer.sdp,
    sessionId: session.id,
    mediaId: media.id
  };
}

/**
 * Prepares the WebRTC portions of setting up an incoming call
 *
 * @method setupIncomingCall
 * @param  {Object} webRTC An instance of webRTC
 * @param  {Object} sessionOptions
 * @param  {Object} sessionOptions.sdpSemantics semantics for the SDP, contains video and audio constraints
 * @param  {Object} sessionOptions.turnInfo TURN information, contains server info
 * @param  {string} sessionOptions.trickleIceMode the mode to enable for Trickle ICE
 * @param  {Object} sessionOptions.offer an offer containing an SDP
 * @return {string} sessionId an identifier for the session
 */
function* setupIncomingCall(webRTC, sessionOptions) {
  const { offer, sdpSemantics, turnInfo, trickleIceMode } = sessionOptions;

  const session = yield (0, _effects.call)([webRTC.sessionManager, 'create'], {
    peer: {
      rtcConfig: {
        sdpSemantics,
        iceServers: turnInfo.servers
      },
      trickleIceMode
    }
  });
  yield (0, _effects.call)([session, 'processOffer'], {
    type: 'offer',
    sdp: offer.sdp
  });

  return session.id;
}

/**
 * Prepares the WebRTC portions of answering a call
 *
 * @method answerWebrtcSession
 * @param  {Object} webRTC An instance of webRTC
 * @param  {Object} mediaConstraints Video and audio media constraints
 * @param  {boolean} mediaConstraints.audio Whether to enable audio or not
 * @param  {boolean} mediaConstraints.video Whether to enable video or not
 * @param  {Object} sessionOptions
 * @param  {string} sessionOptions.sessionId the local webrtc session id
 * @return {Object} Object
 * @return {string} Object.answerSDP Session Description Protocol for answer
 * @return {string} Object.mediaId an identifier for media
 */
function* answerWebrtcSession(webRTC, mediaConstraints, sessionOptions) {
  // Get the webRTC session that represents this call.
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionOptions.sessionId);

  if (!session) {
    log.error(`Error: webRTC session ${sessionOptions.sessionId} not found.`);
    return;
  }

  log.debug('Getting media with constraints: ', mediaConstraints);
  const media = yield (0, _effects.call)([webRTC.media, 'createLocal'], mediaConstraints);

  // Add the tracks to the session.
  yield (0, _effects.call)([session, 'addTracks'], media.getTracks());

  const answer = yield (0, _effects.call)([session, 'generateAnswer']);

  return {
    answerSDP: answer.sdp,
    mediaId: media.id
  };
}

/***/ }),

/***/ "./src/callstack/sagas/midcall.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeCall = closeCall;
exports.handleOffer = handleOffer;
exports.handleAnswer = handleAnswer;
exports.generateOffer = generateOffer;
exports.webRtcAddMedia = webRtcAddMedia;
exports.webRtcRemoveMedia = webRtcRemoveMedia;

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries
// Other Plugins
const log = (0, _logs.getLogManager)().getLogger('CALLSTACK');

/**
 * Performs the webRTC session functions associated with closing a call
 *
 * @method closeCall
 * @param {Object} webRTC A WebRTC instance
 * @param {string} sessionId the local webRTC session id, used to lookup the session object
 */
function* closeCall(webRTC, sessionId) {
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionId);
  if (!session) {
    log.debug(`webRTC session ${sessionId} not found.`);
    return;
  }

  yield (0, _effects.all)(session.localTracks.map(track => (0, _effects.call)([track, 'cleanup'])));

  yield (0, _effects.call)([session, 'end']);
}

/**
 * Performs webRTC portions of receiving an "offer" Session Description Protocol
 *
 * @method handleOffer
 * @param {Object} webRTC A WebRTC instance
 * @param {string} sdp Session Description protocol offer
 * @param {string} webrtcSessionId local webrtc session id
 * @returns {Object}
 */
function* handleOffer(webRTC, sdp, webrtcSessionId) {
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], webrtcSessionId);

  if (!session) {
    log.debug(`webRTC session ${webrtcSessionId} not found.`);
    return;
  }

  // TODO: Make sure the session is in the correct signaling state to process an offer.
  const error = yield (0, _effects.call)([session, 'processOffer'], {
    type: 'offer',
    sdp
  });

  if (error) {
    return { error };
  }

  const answer = yield (0, _effects.call)([session, 'generateAnswer']);

  return {
    answerSDP: answer.sdp
  };
}

/**
 * Performs webRTC portions of receiving an "answer" Session Description Protocol
 *
 * @method handleAnswer
 * @param {Object} webRTC A WebRTC instance
 * @param {string} sdp Session Description protocol answer
 * @param {string} webrtcSessionId local webrtc session id
 * @return {Object} Object
 * @return {Object} Object.error
 */
function* handleAnswer(webRTC, sdp, webrtcSessionId) {
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], webrtcSessionId);

  if (!session) {
    log.debug(`webRTC session ${webrtcSessionId} not found.`);
    return;
  }

  // TODO: Make sure the session is in the correct signaling state to process an answer.
  const error = yield (0, _effects.call)([session, 'processAnswer'], {
    type: 'answer',
    sdp
  });

  return { error };
}

/**
 * Performs the webRTC session functions associated with creating an SDP offer
 *
 * @method generateOffer
 * @param {Object} webRTC A WebRTC instance
 * @param {string} sessionId the local webRTC session id, used to lookup the session object
 * @param {Object} mediaDirections
 * @param {string} mediaDirections.audio mode of audio add to the sdp offer
 * @param {string} mediaDirections.video mode of video add to the sdp offer
 * @return {Object} offer object containing a Session Description Protocol
 */
function* generateOffer(webRTC, sessionId, mediaDirections) {
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionId);

  if (!session) {
    log.debug(`webRTC session ${sessionId} not found.`);
    return;
  }

  // TODO: Make sure the session is in the correct signaling state to start a
  //    renegotiation operation.
  const offer = yield (0, _effects.call)([session, 'generateOffer'], {
    mediaDirections
  });

  return offer;
}

/**
 * Performs the webRTC responsibilities for adding media
 *
 * @param {Object} webRTC A WebRTC instance
 * @param  {Object} mediaConstraints Video and audio media constraints
 * @param  {boolean} mediaConstraints.audio Whether to enable audio or not
 * @param  {boolean} mediaConstraints.video Whether to enable video or not
 * @param  {Object} sessionOptions
 * @param  {string} sessionOptions.sessionId the local webrtc session id
 * @return {Object} Object
 * @return {string} Object.sdp An offer in the form of a Session Description Protocol
 * @return {Object} Object.media media object containing tracks
 */
function* webRtcAddMedia(webRTC, mediaConstraints, sessionOptions) {
  const media = yield (0, _effects.call)([webRTC.media, 'createLocal'], mediaConstraints);

  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionOptions.sessionId);
  yield (0, _effects.call)([session, 'addTracks'], media.getTracks());

  // TODO: Make sure the session is in the correct signaling state to start a
  //    renegotiation operation.
  const offer = yield (0, _effects.call)([session, 'generateOffer']);
  return { media: media.getState(), sdp: offer.sdp };
}

/**
 * Performs the webRTC responsibilities for removing media
 *
 * @param {Object} webRTC A WebRTC instance
 * @param {Object} sessionOptions
 * @return {Object} Object
 * @return {string} Object.sdp An offer in the form of a Session Description Protocol
 */
function* webRtcRemoveMedia(webRTC, sessionOptions) {
  // Get the tracks
  const localTracks = yield (0, _effects.call)([webRTC.track, 'getTracks'], sessionOptions.tracks);
  const invalidTrackIds = [];
  for (var i = 0; i < localTracks.length; i++) {
    if ((0, _fp.isUndefined)(localTracks[i])) {
      invalidTrackIds.push(sessionOptions.tracks[i]);
    }
  }

  if (!(0, _fp.isEmpty)(invalidTrackIds)) {
    const message = 'Invalid track id(s) provided';
    log.debug(message);
    return new _errors2.default({
      code: _errors.callCodes.INVALID_PARAM,
      message
    });
  }

  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionOptions.sessionId);

  // Removes tracks from peer (Will stop tracks from being sent to remote participant).
  // Does NOT end the tracks.
  yield (0, _effects.call)([session, 'removeTracks'], sessionOptions.tracks);

  // Ends the tracks.
  // Clean-up the local tracks.
  yield (0, _effects.all)(localTracks.map(track => (0, _effects.call)([track, 'cleanup'])));

  // TODO: Make sure the session is in the correct signaling state to start a
  //    renegotiation operation.
  const offer = yield (0, _effects.call)([session, 'generateOffer']);

  return {
    sdp: offer.sdp
  };
}

/***/ }),

/***/ "./src/callstack/sagas/negotiation.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receivedAnswer = receivedAnswer;

var _logs = __webpack_require__("./src/logs/index.js");

var _utils = __webpack_require__("./src/callstack/utils/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

// Helpers.
const log = (0, _logs.getLogManager)().getLogger('CALLSTACK');

/**
 * An answer SDP has been received and should be applied to the Session.
 *
 * This saga is intended to handle all webRTC scenarios where a remote answer
 *    SDP has been received and needs to be added to the Session. At this point
 *    in negotiation, a Session should have been created and a local offer SDP
 *    set. This can be for initial negotiation or for midcall renegotiation, so
 *    the Session may or may not have a "current remote SDP" already.
 * This saga will complete the negotiation process, as both ends will have both
 *    an offer and answer SDP set.
 * Responsibilities:
 *    1. Ensure this is a valid operation.
 *        - Session exists, Session is in correct signaling state.
 *    2. Check the answer SDP for abnormal scenarios.
 *        - DTLS role issue.
 *    3. Process the answer SDP via Session's APIs.
 * @method receivedAnswer
 * @param {Object} webRTC An instance of webRTC
 * @param {Object} sessionInfo Session related information for the operation.
 * @param {string} sessionInfo.sessionId ID for the local webRTC Session.
 * @param {string} sessionInfo.answerSdp The received answer SDP.
 * @param {Object} targetCall Information about the call that this Session is associated with.
 */


// Libraries.
// Other Plugins
function* receivedAnswer(webRTC, sessionInfo, targetCall) {
  log.debug(`Processing SDP answer for session ${sessionInfo.sessionId}.`);

  const { sessionId, answerSdp } = sessionInfo;
  const session = yield (0, _effects.call)([webRTC.sessionManager, 'get'], sessionId);

  if (!session) {
    log.debug(`webRTC session ${sessionId} not found.`);
    // TODO: Better error.
    return;
  }
  // TODO: Ensure Session is in the correct signaling state for an answer SDP.

  // SDP handlers to be used during SDP "processing".
  const sdpHandlers = [];

  /*
   * If the answer we received has DTLS role of 'actpass', then this is not a
   *    normal webRTC scenario. An answer SDP cannot have 'actpass' as the role.
   * It is assumed that the reason for this is a slow start call.
   */
  if (answerSdp.includes('a=setup:actpass')) {
    /*
     * Change the DTLS role depending on which side of the call the user is.
     * Change the caller to passive and the callee to active roles, because
     *    this is how it would be set for a regular call.
     */
    const newRole = targetCall.isCaller ? 'passive' : 'active';
    log.debug(`Received answer SDP has role of actpass. Changing to ${newRole}.`);
    sdpHandlers.push((0, _utils.changeDtlsRoleTo)(newRole));
  }

  /*
   * Provide the answer SDP to the Session for "processing".
   * If successful, the webRTC negotiation process is considered complete.
   */
  const error = yield (0, _effects.call)([session, 'processAnswer'], {
    type: 'answer',
    sdp: answerSdp
  }, { sdpHandlers });

  // TODO: Handle webRTC errors here.

  return error;
}

/***/ }),

/***/ "./src/callstack/utils/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizeSdesFromSdp = sanitizeSdesFromSdp;
exports.changeDtlsRoleTo = changeDtlsRoleTo;

var _logs = __webpack_require__("./src/logs/index.js");

const log = (0, _logs.getLogManager)().getLogger('SDPHANDLER');

/**
 * SDP handler function that should be passed into session object's `processOffer` and `processAnswer` function.
 * This function disables old media encryption method SDES (Modifies sdp by removing crypto).
 * However, if only SDES is available, don't disable it.
 *
 * @method sanitizeSdesFromSdp
 * @param {Object} newSdp The sdp so far (could have been modified by previous handlers).
 * @param {RTCSdpType} info Information about the session description.
 * @param {RTCSdpType} info.type The session description's type.
 * @param {string} info.endpoint Which end of the connection created the SDP.
 * @param {Object} originalSdp The sdp in its initial state.
 * @return {Object} The sanitized sdp with crypto removed (if fingerprint exists)
 */
// Other plugins.
function sanitizeSdesFromSdp(newSdp, info, originalSdp) {
  for (let mLine of newSdp.media) {
    if (mLine.crypto && mLine.fingerprint) {
      log.debug('Removing SDES line from SDP media section.');
      delete mLine.crypto;
    }
  }
  return newSdp;
}

/**
 * Function generator for an SDP handler function that changes the DTLS role of the SDP.
 * @method changeDtlsRoleTo
 * @param  {string} role
 * @return {Function} SDP handler.
 */
function changeDtlsRoleTo(role) {
  return function changeDtlsRole(newSdp, info, originalSdp) {
    // Grab the original DTLS role for logging purposes.
    //    Assumed that the DTLS role is the same in every media section.
    const original = newSdp.media[0].setup;
    log.debug(`Changing SDP DTLS role from ${original} to ${role}.`);

    // Change the DTLS role in every media section.
    newSdp.media.map(media => {
      media.setup = role;
      return media;
    });

    return newSdp;
  };
}

/***/ }),

/***/ "./src/common/effects/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _waitFor = __webpack_require__("./src/common/effects/waitFor.js");

Object.defineProperty(exports, 'waitFor', {
  enumerable: true,
  get: function () {
    return _waitFor.waitFor;
  }
});

/***/ }),

/***/ "./src/common/effects/waitFor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitFor = waitFor;

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _logs = __webpack_require__("./src/logs/index.js");

const log = (0, _logs.getLogManager)().getLogger('EFFECTS');
const WAIT_SAGA_CONTEXT = 'waitSagaContext';

/**
 * Simple saga that simply does a take, to allow a take effect to be forked.
 *
 * @param {(string|Function|Array)} pattern The action or action selector to wait for.
 */
function* processTake(pattern) {
  const result = yield (0, _effects.take)(pattern);

  const waitContext = yield (0, _effects.getContext)(WAIT_SAGA_CONTEXT);
  if (waitContext) {
    log.debug(`Finished wait (${++waitContext.numFinishedWaits} of ${waitContext.numTotalWaits})`);
    log.trace(`Wait processed action: : ${pattern}`);
  }

  return result;
}

/**
 * Saga that processes the wait effect.
 * @param {number} timeout The number of milliseconds to wait for the actions to be dispatched.
 * @param {Array.<(string|Function|Array)>} waitPatterns An array of actions or action selectors to wait for.
 */
function* waitSaga(timeout, waitPatterns) {
  const waitSagaContext = {
    numFinishedWaits: 0,
    numTotalWaits: waitPatterns.length

    // Use a context to add debugging information for the child saga processTake to use.
  };yield (0, _effects.setContext)({
    [WAIT_SAGA_CONTEXT]: waitSagaContext
  });

  // Fork all of the takes
  const waitTasks = yield (0, _effects.all)(waitPatterns.map(pattern => (0, _effects.fork)(processTake, pattern)));

  log.debug(`Waiting ${timeout} msecs for ${waitSagaContext.numTotalWaits} actions to happen.`);

  // Race between the wait tasks and a delay.
  let { results, timeoutResult } = yield (0, _effects.race)({
    results: (0, _effects.join)(...waitTasks),
    timeoutResult: (0, _effects.delay)(timeout)
  });

  // If we have a timeout, gather partial results.
  if (timeoutResult) {
    // Get partial results from tasks
    results = waitTasks.map(task => task.result());

    // Cancel remaining wait tasks
    yield (0, _effects.cancel)(...waitTasks);

    log.debug(`Waiting for actions timed out. ${waitSagaContext.numFinishedWaits} actions were processed out of ${waitSagaContext.numTotalWaits}.`);
  } else {
    log.debug(`Waiting for actions completed, all ${waitSagaContext.numTotalWaits} actions were processed`);
  }

  return {
    timeout: !!timeoutResult,
    results
  };
}

/**
 * Type defining the result of a yielded wait effect.
 *
 * @typedef {Object} WaitEffectResult
 * @property {Array.<Action>} results The array of results for all of the patterns. This can contain partial results.
 *                                    Action patterns that have timed out will be undefined.
 * @property {boolean} timeout The wait timed out.
 */

/**
 * A redux-saga wait effect. This effect will wait for a specified set of actions to occur an return the result
 * of each `take` effect performed on each action. If the wait times out, then the result will contain partial results
 * as well as mark the result as having timed out.
 *
 * @param {number} timeout
 * @param {Array.<ActionPattern>} waitPatterns The list of wait patterns.
 * @return A blocking redux-saga effect that will instruct the middleware to wait for the actions matching the wait
 *         patterns or until a timeout is reached. The result from the yielded will be of type {@link WaitEffectResult}.
 * @see {@link https://redux-saga.js.org/docs/api/#takepattern Redux-saga's take documentation} for supported patterns.
 */
function waitFor(timeout, waitPatterns) {
  return (0, _effects.call)(waitSaga, timeout, waitPatterns);
}

/***/ }),

/***/ "./src/common/helpers/handleRequestError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleRequestError = handleRequestError;

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function handleRequestError(response, operation) {
  let message, code;

  if (response && response.payload) {
    if (response.payload.body) {
      if ('serviceException' in response.payload.body) {
        // The response includes a body with an error message.
        const { serviceException } = response.payload.body.requestError;
        message = formatString(serviceException.text, serviceException.variables);
        // TODO: Do we want to wrap the backend's error codes?
        code = serviceException.messageId;
      } else {
        // As serviceException details not available, we will capture general error information
        message = response.payload.body.message;
        code = response.payload.result.code;
      }
    } else if (response.payload.result) {
      message = (operation ? `${operation} request` : 'Request') + ` failed: ${response.payload.result.message}`;
      code = response.payload.result.code;
    }
  } else {
    message = (operation ? `${operation} request` : 'Request') + ` failed: Unknown error.`;
    // TODO: Real code.
    code = 4;
  }

  return new _errors2.default({ message, code });
}

/**
 * Utility function for formatting a CPaaS 2.0 error response.
 * // TODO: Move this to a more common/utils location.
 */
function formatString(text, variables) {
  return text.replace(/%(\d+)/g, function (_, m) {
    return variables[--m];
  });
}

/***/ }),

/***/ "./src/common/helpers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _handleRequestError = __webpack_require__("./src/common/helpers/handleRequestError.js");

Object.defineProperty(exports, 'handleRequestError', {
  enumerable: true,
  get: function () {
    return _handleRequestError.handleRequestError;
  }
});

/***/ }),

/***/ "./src/common/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

exports.mergeValues = mergeValues;
exports.toQueryString = toQueryString;
exports.autoRestart = autoRestart;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _queryString = __webpack_require__("./node_modules/query-string/index.js");

var _queryString2 = _interopRequireDefault(_queryString);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Deeply merges the values of multiple objects. Objects on the left receive the values from objects on their right.
 * Unlike lodash's default merge behavior this doesn't merge arrays.
 *
 * @name mergeValues
 * @param {...Object} objects - Objects to merge
 * @return {Object} A new object containing the merged values.
 */
function mergeValues(...objects) {
  return (0, _fp.mergeAllWith)((leftValue, rightValue) => {
    // Overwrite the default behavior of lodash's merge for arrays and simply
    // clobber what's on the left so we don't end up with merged arrays.
    if ((0, _fp.isArray)(leftValue)) {
      return rightValue;
    }
  }, objects);
}

/**
 * Utility function to convert an object to a query string.
 *
 * @param {Object} params An object of query parameters to be parsed and converted for use in a URL string
 * @param {Object} [options] Options to be passed to the query-string library
 * * @param {String} [options.arrayFormat] Format in which to compose array values which were passed as query parameters
 */
// Libraries.
function toQueryString(params = {}, options = {}) {
  if ((0, _keys2.default)(params).length > 0) {
    const stringifiedParams = _queryString2.default.stringify(params, options);
    return '?' + stringifiedParams;
  }
  return '';
}

/**
 * Higher-order function to auto-restart sagas when they crash.
 * Based on: https://github.com/redux-saga/redux-saga/pull/644#issuecomment-266454875
 * @method autoRestart
 * @param  {Generator} saga The saga to wrap.
 * @return {Generator} Wrapped saga.
 */
function autoRestart(saga) {
  return function* autoRestarting(...args) {
    // Only restart the saga if it crashed; avoid restarting it if
    //      it returned normally.
    let shouldRestart = false;
    do {
      try {
        yield (0, _effects.call)(saga, ...args);
        shouldRestart = false;
      } catch (e) {
        // TODO: Re-add this log line.
        // Importing the LogManager in this file breaks tests for an unknown
        //    reason. Should find out why so that we can log in our utils.
        // log.error(`Unhandled error in saga ${saga.name}.`, e)
        console.log(`Unhandled error in saga ${saga.name}.`, e);
        shouldRestart = true;
      }
    } while (shouldRestart);
  };
}

/***/ }),

/***/ "./src/config/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = configImplementation;

var _interface = __webpack_require__("./src/config/interface/index.js");

var _interface2 = _interopRequireDefault(_interface);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Config Plugin
 *
 * @method configImplementation
 * @return {Object} An instance of the "Config" plugin.
 */

// yarn lint:docs complains if this isn't defined in a plugin.
/**
 * @module config
 */
function configImplementation() {
  return {
    // Interface Components:
    name: _interface2.default.name,
    capabilities: ['config'],
    api: _interface2.default.api,
    reducer: _interface2.default.reducer
  };
} /**
   * This file is a plugin for the "Config" plugin
   * Reference info: https://confluence.genband.com/display/KSDK/Plugins
   */

/***/ }),

/***/ "./src/config/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const PREFIX = '@@KANDY/';

const CONFIG_UPDATE = exports.CONFIG_UPDATE = PREFIX + 'CONFIG_UPDATE';

/***/ }),

/***/ "./src/config/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.update = update;

var _actionTypes = __webpack_require__("./src/config/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Add or update a specific key within the store.config.
 *
 * @param {Object} values The values that will be placed in the store.
 * @param {string} [pluginName] The plugin name of the config being set.
 * @return {Action} action A redux action.
 */
function update(values, pluginName = '') {
  var payload;
  // Use the plugin name as a substate key, if present.
  if (pluginName) {
    payload = {
      [pluginName]: values
    };
  } else {
    payload = values;
  }

  return {
    type: actionTypes.CONFIG_UPDATE,
    payload: payload
  };
}

/***/ }),

/***/ "./src/config/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/config/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/config/interface/selectors.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * An interface for getting and updating the configuration Object.
 *
 * @public
 * @module Config
 * @requires config
 */
function api(context) {
  const configApi = {
    /**
     * Gets the current configuration Object
     *
     * @public
     * @memberof Config
     * @requires config
     * @method getConfig
     * @returns {Object} A configuration Object
     */
    getConfig: function () {
      return (0, _selectors.getConfiguration)(context.getState());
    },

    /**
     * Update values in the global Config section of the store.
     *
     * @public
     * @memberof Config
     * @requires config
     * @method updateConfig
     * @param {Object} newConfigValues Key Value pairs that will be placed into the store.
     */
    updateConfig: function (newConfigValues) {
      context.dispatch(actions.update(newConfigValues));
    }
  };

  return configApi;
}

/***/ }),

/***/ "./src/config/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/config/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/config/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This interface is for a Config plugin.
 * @type {string}
 */
const name = 'config';

exports.default = {
  reducer: _reducers2.default,
  name,
  api: _api2.default
};

/***/ }),

/***/ "./src/config/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/config/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const reducers = {};

reducers[actionTypes.CONFIG_UPDATE] = {
  next(state, action) {
    return (0, _fp.merge)(state, action.payload);
  }
};

// Config default state is an empty Object
const reducer = (0, _reduxActions.handleActions)(reducers, {});
exports.default = reducer;

/***/ }),

/***/ "./src/config/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConfiguration = getConfiguration;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Retrieves configuration Object stored in state
 *
 * @method getConfiguration
 * @param  {Object} state Redux state.
 * @return {Object}
 */
function getConfiguration(state) {
  return (0, _fp.cloneDeep)(state.config);
}

/***/ }),

/***/ "./src/connectivity/defaults.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _constants = __webpack_require__("./src/constants.js");

/**
 * Connectivity plugin defaults.
 * @param {String} [method='keepAlive'] The method of connectivity checking to use. Either connCheckMethods.PING_PONG or connCheckMethods.KEEP_ALIVE
 * @param {Number} [pingInterval=30000] Time in between websocket ping attempts (milliseconds).
 * @param {Number} [reconnectLimit=5] Number of failed reconnect attempts before reporting an error. Can be set to 0 to not limit reconnection attempts.
 * @param {Number} [reconnectDelay=5000] Base time between websocket reconnect attempts (milliseconds).
 * @param {Number} [reconnectTimeMultiplier=1] Reconnect delay multiplier for subsequent attempts. The reconnect delay time will be multiplied by this factor after each failed reconnect attempt to increase the delay between attempts.
 * @param {Number} [reconnectTimeLimit=640000] Maximum time delay between reconnect attempts (milliseconds). Used in conjunction with the reconnect time multiplier to prevent overly long delays between reconnection attempts.
 * @param {Boolean} [autoReconnect=true] Flag to determine whether the SDK will attempt to automatically reconnect after connectivity disruptions.
 * @param {Number} [maxMissedPings=3] Maximum pings sent (without receiving a response) before reporting an error.
 * @param {Boolean} [checkConnectivity=false] Flag to determine whether the SDK should check connectivity.
 */
exports.default = {
  method: _constants.connCheckMethods.KEEP_ALIVE,
  pingInterval: 30000,
  reconnectLimit: 5,
  reconnectDelay: 5000,
  reconnectTimeMultiplier: 1,
  reconnectTimeLimit: 640000,
  autoReconnect: true,
  maxMissedPings: 3,
  checkConnectivity: true
};

/***/ }),

/***/ "./src/connectivity/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = connectivity;

var _interface = __webpack_require__("./src/connectivity/interface/index.js");

var _defaults = __webpack_require__("./src/connectivity/defaults.js");

var _defaults2 = _interopRequireDefault(_defaults);

var _events = __webpack_require__("./src/connectivity/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _sagas = __webpack_require__("./src/connectivity/sagas.js");

var _actions = __webpack_require__("./src/config/interface/actions.js");

var _actions2 = __webpack_require__("./src/events/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Configuration options for the Connectivity feature.
 * @public
 * @name config.connectivity
 * @memberof config
 * @instance
 * @param {Object} connectivity Connectivity configs.
 * @param {Object} connectivity.method Configuration for how connectivity checks should be made.
 * @param {String} [connectivity.method.type='keepAlive'] The method of connectivity checking to use: `keepAlive` or `pingPong`.
 * @param {String} [connectivity.method.responsibleParty='client'] Configures who is responsible for initiating the connectivity check: `client` or `server`.
 * @param {Number} [connectivity.pingInterval=30000] Time in between websocket ping attempts (milliseconds). Only used for when the client is responsible for ping/connCheck.
 * @param {Number} [connectivity.reconnectLimit=5] Number of failed reconnect attempts before reporting an error. Can be set to 0 to not limit reconnection attempts.
 * @param {Number} [connectivity.reconnectDelay=5000] Base time between websocket reconnect attempts (milliseconds).
 * @param {Number} [connectivity.reconnectTimeMultiplier=1] Reconnect delay multiplier for subsequent attempts. The reconnect delay time will be multiplied by this factor after each failed reconnect attempt to increase the delay between attempts.
 * @param {Number} [connectivity.reconnectTimeLimit=640000] Maximum time delay between reconnect attempts (milliseconds). Used in conjunction with `reconnectTimeMultiplier` to prevent overly long delays between reconnection attempts.
 * @param {Boolean} [connectivity.autoReconnect=true] Flag to determine whether reconnection will be attempted automatically after connectivity disruptions.
 * @param {Number} [connectivity.maxMissedPings=3] Maximum pings sent (without receiving a response) before reporting an error.
 * @param {Boolean} [connectivity.checkConnectivity=false] Flag to determine whether to enable connectivity checking or not.
 */

/**
 * Connectivity plugin factory.
 * Responsible for handling websockets.
 * @method connectivity
 * @param  {Object} [options={}] Connectivity configs. See above.
 * @return {Object} Plugin - A connectivity plugin.
 */
function connectivity(options = {}) {
  options = (0, _fp.defaults)(_defaults2.default, options);

  // For backwards compatibility, convert the old style to the new style.
  if (typeof options.method === 'string') {
    let method = options.method;
    options.method = {
      type: method,
      // In both old scenarios, the client is responsible.
      responsibleParty: _constants.connCheckResponsibility.CLIENT
    };
  }

  function* init() {
    yield (0, _effects.put)((0, _actions.update)(options, _interface.name));
    yield (0, _effects.put)((0, _actions2.mapEvents)(_events2.default));
  }

  return {
    sagas: [_sagas.wsConnectFlow],
    init,
    name: _interface.name,
    reducer: _interface.reducer,
    api: _interface.api
  };
}

// Libraries.


// Other plugins.
// Connectivity plugin.

/***/ }),

/***/ "./src/connectivity/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/CONN/';

// Actions to tell connectivity plugin what to do
const WS_ATTEMPT_CONNECT = exports.WS_ATTEMPT_CONNECT = prefix + 'WS_ATTEMPT_CONNECT';
const WS_CONNECT_FINISHED = exports.WS_CONNECT_FINISHED = prefix + 'WS_CONNECT_FINISHED';
const WS_DISCONNECT = exports.WS_DISCONNECT = prefix + 'WS_DISCONNECT';
const WS_DISCONNECT_FINISHED = exports.WS_DISCONNECT_FINISHED = prefix + 'WS_DISCONNECT_FINISHED';
const WS_RECONNECT_FAILED = exports.WS_RECONNECT_FAILED = prefix + 'WS_RECONNECT_FAILED';

// actions for hooking into connectivity plugin behaviour
const WS_CLOSED = exports.WS_CLOSED = prefix + 'WS_CLOSED';
const WS_ERROR = exports.WS_ERROR = prefix + 'WS_ERROR';

const LOST_CONNECTION = exports.LOST_CONNECTION = prefix + 'LOST_CONNECTION';

const RECEIVE_SERVER_PING = exports.RECEIVE_SERVER_PING = prefix + 'RECEIVE_SERVER_PING';
const RECEIVE_SERVER_PONG = exports.RECEIVE_SERVER_PONG = prefix + 'RECEIVE_SERVER_PONG';

const CHANGE_CONNECTIVITY_CHECKING = exports.CHANGE_CONNECTIVITY_CHECKING = prefix + 'CHANGE_CONNECTIVITY_CHECKING';
const CHANGE_PING_INTERVAL = exports.CHANGE_PING_INTERVAL = prefix + 'CHANGE_PING_INTERVAL';

/***/ }),

/***/ "./src/connectivity/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changePingInterval = exports.changeConnectivityChecking = exports.receiveServerPong = exports.receiveServerPing = exports.lostConnection = exports.wsError = exports.wsClosed = exports.wsReconnectFailed = exports.wsDisconnectFinished = exports.wsConnectFinished = exports.wsDisconnect = exports.wsAttemptConnect = undefined;

var _actionTypes = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @param {string} type
 */
function createWsAction(type) {
  /**
   * @param {any=} payload
   * @param {string=} platform
   * @param {boolean=} [isReconnect] flag to signify if we are reconnecting or not.
   */
  function action(payload, platform = _constants.platforms.LINK, isReconnect = false) {
    return {
      type,
      // TODO: This must check for basic error eventually instead.
      error: payload instanceof Error,
      payload,
      meta: { platform, isReconnect }
    };
  }
  return action;
}
// Constants
const wsAttemptConnect = exports.wsAttemptConnect = createWsAction(actionTypes.WS_ATTEMPT_CONNECT);
const wsDisconnect = exports.wsDisconnect = createWsAction(actionTypes.WS_DISCONNECT);
const wsConnectFinished = exports.wsConnectFinished = createWsAction(actionTypes.WS_CONNECT_FINISHED);
const wsDisconnectFinished = exports.wsDisconnectFinished = createWsAction(actionTypes.WS_DISCONNECT_FINISHED);
const wsReconnectFailed = exports.wsReconnectFailed = createWsAction(actionTypes.WS_RECONNECT_FAILED);

const wsClosed = exports.wsClosed = createWsAction(actionTypes.WS_CLOSED);
const wsError = exports.wsError = createWsAction(actionTypes.WS_ERROR);

const lostConnection = exports.lostConnection = createWsAction(actionTypes.LOST_CONNECTION);

const receiveServerPing = exports.receiveServerPing = createWsAction(actionTypes.RECEIVE_SERVER_PING);
const receiveServerPong = exports.receiveServerPong = createWsAction(actionTypes.RECEIVE_SERVER_PONG);

const changeConnectivityChecking = exports.changeConnectivityChecking = createWsAction(actionTypes.CHANGE_CONNECTIVITY_CHECKING);
const changePingInterval = exports.changePingInterval = createWsAction(actionTypes.CHANGE_PING_INTERVAL);

/***/ }),

/***/ "./src/connectivity/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _constants = __webpack_require__("./src/constants.js");

var _actions = __webpack_require__("./src/connectivity/interface/actions.js");

var _selectors = __webpack_require__("./src/connectivity/interface/selectors.js");

/**
 * The connection feature is used to connect and maintain connections between
 * the SDK and one or more backend servers.
 *
 * Connectivity functions are all part of the 'connection' namespace.
 *
 * @public
 * @module Connectivity
 */

function api({ dispatch, getState }) {
  const connectivityApi = {
    /**
     * Get the state of the websocket.
     * @public
     * @memberof Connectivity
     * @method getSocketState
     * @param  {string} [platform='link'] Backend platform for which websocket's state to request.
     */
    getSocketState(platform = _constants.platforms.LINK) {
      return (0, _selectors.getConnectionState)(getState(), platform);
    },

    /**
     * Enables or disables connectivity checking.
     * @public
     * @memberof Connectivity
     * @method enableConnectivityChecking
     * @param {boolean} enable Whether to enable or disable connectivity checking.
     */
    enableConnectivityChecking(enable) {
      dispatch((0, _actions.changeConnectivityChecking)(enable));
    }
  };

  return { connection: connectivityApi };
} // Constants

/***/ }),

/***/ "./src/connectivity/interface/effects.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectWebsocket = connectWebsocket;
exports.disconnectWebsocket = disconnectWebsocket;

var _actions = __webpack_require__("./src/connectivity/interface/actions.js");

var _actionTypes = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

/**
 * Custom redux-saga effect.
 * Wraps "communication" between the connectivity plugin and another plugin
 *     for connecting to a websocket.
 * @method connectWebsocket
 * @param {Object} websocketInfo Information needed to create the websocket.
 * @param {string} websocketInfo.protocol
 * @param {string} websocketInfo.server
 * @param {string} websocketInfo.port
 * @param {string} websocketInfo.url
 * @param {Object} [websocketInfo.params]
 * @param {string} platform The backend platform being connected to.
 * @return {Object} The response action of type `WS_CONNECT_FINISHED`.
 */
function* connectWebsocket(websocketInfo, platform) {
  // Dispatch the action that triggers a saga to connect to a websocket.
  yield (0, _effects.put)((0, _actions.wsAttemptConnect)(websocketInfo, platform));

  // Wait for the action that signifies the result of the above action.
  const responseAction = yield (0, _effects.take)(action => {
    return action.type === _actionTypes.WS_CONNECT_FINISHED && action.meta.platform === platform;
  });

  // Return the response.
  return responseAction;
}

/**
 * Effect for disconnecting a websocket to a platform.
 * @method disconnectWebsocket
 * @param  {Object} payload
 * @param  {string} platform The backend platform being disconnected from.
 * @return {Object} The response action of type `WS_DISCONNECT_FINISHED`.
 */
function* disconnectWebsocket(payload, platform) {
  // Dispatch the action that triggers a saga to disconnect the websocket.
  yield (0, _effects.put)((0, _actions.wsDisconnect)(payload, platform));

  // Wait for the action that signifies the result of the above action.
  const responseAction = yield (0, _effects.take)(action => {
    return (action.type === _actionTypes.WS_DISCONNECT_FINISHED || action.type === _actionTypes.WS_ERROR) && action.meta.platform === platform;
  });

  // Return the response.
  return responseAction;
}

/***/ }),

/***/ "./src/connectivity/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The websocket to the server has changed state.
 *
 * @public
 * @memberof Connectivity
 * @event ws:change
 * @param {Object} params
 * @param {string} params.platform The platform
 */
const WS_CHANGE = exports.WS_CHANGE = 'ws:change';

/***/ }),

/***/ "./src/connectivity/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/connectivity/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var events = {};

events[actionTypes.WS_CONNECT_FINISHED] = function (action) {
  if (action.error) {
    // TODO: Handle the error case?
  } else {
    return {
      type: eventTypes.WS_CHANGE,
      args: { platform: action.meta.platform }
    };
  }
};

events[actionTypes.LOST_CONNECTION] = function (action) {
  return {
    type: eventTypes.WS_CHANGE,
    args: { platform: action.meta.platform }
  };
};
// TODO: Differentiate between types of disconnects?
events[actionTypes.WS_DISCONNECT_FINISHED] = events[actionTypes.LOST_CONNECTION];

// TODO: Does an app care that we're trying to connect/reconnect?
events[actionTypes.WS_ATTEMPT_CONNECT] = function (action) {
  return {
    type: eventTypes.WS_CHANGE,
    args: { platform: action.meta.platform }
  };
};

exports.default = events;

/***/ }),

/***/ "./src/connectivity/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.api = exports.name = undefined;

var _name = __webpack_require__("./src/connectivity/interface/name.js");

var _name2 = _interopRequireDefault(_name);

var _api = __webpack_require__("./src/connectivity/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/connectivity/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.name = _name2.default;
exports.api = _api2.default;
exports.reducer = _reducers2.default;

/***/ }),

/***/ "./src/connectivity/interface/name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const name = 'connectivity';
exports.default = name;

/***/ }),

/***/ "./src/connectivity/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

reducers[actionTypes.WS_ATTEMPT_CONNECT] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      [action.meta.platform]: (0, _extends3.default)({}, state[action.meta.platform], {
        connected: false,
        pinging: false
      })
    });
  }
};

reducers[actionTypes.WS_RECONNECT_FAILED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      [action.meta.platform]: (0, _extends3.default)({}, state[action.meta.platform], {
        connected: false,
        pinging: false
      })
    });
  }
};

reducers[actionTypes.WS_CONNECT_FINISHED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      [action.meta.platform]: (0, _extends3.default)({}, state[action.meta.platform], {
        connected: true,
        method: action.payload.kandy.method,
        platform: action.meta.platform
      }, (0, _fp.omit)('checkConnectivity', action.payload.kandy))
    });
  },
  throw(state, action) {
    return {
      [action.meta.platform]: {
        connected: false,
        pinging: false
      }
    };
  }
};

reducers[actionTypes.LOST_CONNECTION] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      [action.meta.platform]: (0, _extends3.default)({}, state[action.meta.platform], {
        connected: false,
        pinging: false
      })
    });
  }
};

reducers[actionTypes.WS_DISCONNECT_FINISHED] = {
  next(state, action) {
    return {
      [action.meta.platform]: {
        connected: false,
        pinging: false
      }
    };
  },
  throw(state, action) {
    return {
      [action.meta.platform]: {
        connected: false,
        pinging: false
      }
    };
  }
};

reducers[actionTypes.WS_ERROR] = {
  next(state, action) {
    return {
      [action.meta.platform]: {
        connected: false,
        pinging: false
      }
    };
  },
  throw(state, action) {
    return {
      [action.meta.platform]: {
        connected: false,
        pinging: false
      }
    };
  }
};

/*
  Accepts a boolean payload for checkConnectivity
 */
reducers[actionTypes.CHANGE_CONNECTIVITY_CHECKING] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      checkConnectivity: action.payload
    });
  }
};

/*
  Accepts a payload for pingInterval in MILLISECONDS
 */
reducers[actionTypes.CHANGE_PING_INTERVAL] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      pingInterval: action.payload
    });
  }
};

/**
 * Connectivity Interface reducer
 * @method reducer
 * @param  {Object}  state - The current redux state.
 * @param  {Object}  action - A flux standard action.
 * @return {Object}  - The new redux state.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, {});
exports.default = reducer;

/***/ }),

/***/ "./src/connectivity/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConnectionState = getConnectionState;
exports.getConnectivityConfig = getConnectivityConfig;
exports.getPingInterval = getPingInterval;
exports.getCheckConnectivity = getCheckConnectivity;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _name = __webpack_require__("./src/connectivity/interface/name.js");

var _name2 = _interopRequireDefault(_name);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getConnectionState(state, platform) {
  if (state[_name2.default][platform]) {
    return (0, _fp.cloneDeep)(state[_name2.default][platform]);
  } else {
    return new Error('No sockets are up. Have you attempted to connect?');
  }
}

/**
 * Retrieves the config options provided by the connectivity plugin.
 * @method getConnectivityConfig
 * @return {Object}
 */
function getConnectivityConfig(state) {
  return state.config[_name2.default];
}

/**
 * Retrieves the pingInterval property from state
 * @method getPingInterval
 * @param {Object} state Redux state.
 * @return {Object}
 */
function getPingInterval(state) {
  return state[_name2.default].pingInterval;
}

/**
 * Retrieves the checkConnectivity property from state
 * @method getCheckConnectivity
 * @param {Object} state Redux state.
 * @return {Object}
 */
function getCheckConnectivity(state) {
  return state[_name2.default].checkConnectivity;
}

/***/ }),

/***/ "./src/connectivity/sagas.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.wsConnectFlow = wsConnectFlow;
exports.websocketLifecycle = websocketLifecycle;
exports.serverPingFlow = serverPingFlow;
exports.clientPingFlow = clientPingFlow;
exports.connectWebsocket = connectWebsocket;

var _websocket = __webpack_require__("./src/connectivity/websocket.js");

var _selectors = __webpack_require__("./src/connectivity/interface/selectors.js");

var _actionTypes = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actions = __webpack_require__("./src/connectivity/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Get the logger


// Other plugins.
// Connectivity plugin.
const log = (0, _logs.getLogManager)().getLogger('CONNECTIVITY');

// Constants


// Libraries.
function* wsConnectFlow() {
  const chan = yield (0, _effects.actionChannel)(actionTypes.WS_ATTEMPT_CONNECT);
  yield (0, _effects.takeEvery)(chan, websocketLifecycle);
}

/**
 * Saga that handles a websocket over its lifecycle.
 * @method websocketLifecycle
 * @param  {Object} wsConnectAction
 */
function* websocketLifecycle(wsConnectAction) {
  const wsInfo = wsConnectAction.payload;
  const { platform, isReconnect } = wsConnectAction.meta;

  // Try to open the websocket.
  let websocket = yield (0, _effects.call)(connectWebsocket, wsInfo, platform);

  // Append information to the websocket, so that its accessible elsewhere.
  // TODO: Remove this and replace with proper redux state storage.
  websocket.kandy = yield (0, _effects.select)(_selectors.getConnectivityConfig);

  websocket.kandy.wsInfo = wsInfo;
  websocket.kandy.platform = platform;

  // If the websocket didn't open, dispatch the error and stop here.
  if (websocket.error) {
    if (isReconnect) {
      yield (0, _effects.put)(actions.wsReconnectFailed(undefined, platform));
      return;
    } else {
      yield (0, _effects.put)(actions.wsConnectFinished(new Error(websocket.message), platform));
      return;
    }
  }

  // set last contact in both cases to be now
  websocket.kandy.lastContact = Date.now();

  let emitTask = yield (0, _effects.fork)(_websocket.wsEmitter, websocket, platform);

  // determine which pingFlow is appropriate
  let pingFlow;
  if (websocket.kandy.method.responsibleParty === _constants.connCheckResponsibility.SERVER) {
    pingFlow = yield (0, _effects.fork)(serverPingFlow, websocket, platform);
  } else {
    pingFlow = yield (0, _effects.fork)(clientPingFlow, websocket, platform);
  }

  // Dispatch the finish action, to notify that the websocket is connected.
  yield (0, _effects.put)(actions.wsConnectFinished(websocket, platform));

  // Redux-saga take() pattern.
  // Take end of lifecycle WS actions for this platform.
  function closeWebsocketPattern(action) {
    return (action.type === actionTypes.WS_DISCONNECT || action.type === actionTypes.LOST_CONNECTION) && action.meta.platform === platform;
  }

  // Wait for a disconnect or lost connection action.
  const action = yield (0, _effects.take)(closeWebsocketPattern);

  // Whether we're disconnecting or have lost connection,
  //      we want to cancel these tasks either way.
  yield (0, _effects.cancel)(emitTask, pingFlow);

  if (action.type === actionTypes.WS_DISCONNECT) {
    // If we're disconnecting, close the websocket to end it's lifecycle.
    yield (0, _effects.call)(_websocket.closeWebsocket, websocket);
    yield (0, _effects.put)(actions.wsDisconnectFinished(undefined, platform));
  } else {
    // If this is a Link websocket, we need to ensure the URL is using the
    //     "latest" access token from state.
    if (wsConnectAction.meta.platform === _constants.platforms.CPAAS) {
      let { notificationChannel } = yield (0, _effects.select)(_selectors2.getSubscriptionInfo);
      let { accessToken, oauthToken } = yield (0, _effects.select)(_selectors2.getConnectionInfo);
      wsInfo.url = notificationChannel;
      if (oauthToken && !accessToken) {
        wsInfo.params = {
          access_token: oauthToken
        };
      } else {
        wsInfo.params = {
          token: accessToken
        };
      }
    }

    // If we've lost connection, re-dispatch the initial action, so that we can
    //      start the lifecycle over.
    yield (0, _effects.put)(actions.wsAttemptConnect(wsInfo, wsConnectAction.meta.platform, true));
  }
}

/**
 * if we receieve a server ping we want to respond with a pong,
 * if there is none we want to check to see if its been too long since the server last pinged us and if it has been then reconnect,
 * otherwise we just want to increment the time since the last ping
 * @param {Object} ws a websocket connected to the backend
 * @return {Object} yields a Flux standard action
 */
function* serverPingFlow(ws) {
  const { lastContact, platform, maxMissedPings, autoReconnect } = ws.kandy;
  let timeOfLastPing = Date.now();

  while (true) {
    let pingInterval = yield (0, _effects.select)(_selectors.getPingInterval);
    pingInterval = typeof pingInterval !== 'undefined' ? pingInterval : 120000;
    const maxIdleDuration = pingInterval * maxMissedPings;

    // wait for incoming server pings or disconnect actions on an interval
    const { serverPing, disconnect } = yield (0, _effects.race)({
      expiry: (0, _effects.delay)(pingInterval),
      serverPing: (0, _effects.take)(actionTypes.RECEIVE_SERVER_PING),
      disconnect: (0, _effects.take)(actionTypes.WS_DISCONNECT_FINISHED)
    });

    // is disconnect action receieved then exit
    if (disconnect) {
      break;
    }

    if (serverPing) {
      // server sent us a ping so reset the timeSinceLastPing
      timeOfLastPing = Date.now();

      // pingInterval is stored in milliseconds but comes in as seconds so convert
      const pingIntervalMillis = serverPing.payload.connCheck.interval * 1000;
      // Prevent firing actions if pingInterval hasnt changed
      if (pingIntervalMillis !== pingInterval) {
        yield (0, _effects.put)(actions.changePingInterval(pingIntervalMillis, platform));
      }

      const message = { connAck: {} };
      const error = _sendWSMessage(ws, (0, _stringify2.default)(message));

      // if the pong websocket message has an error then try to reconnect
      if (error) {
        if (autoReconnect) {
          yield (0, _effects.put)(actions.lostConnection(undefined, platform));
        }
        break;
      }
    } else {
      if (Date.now() - timeOfLastPing >= maxIdleDuration) {
        log.warn('closing websocket due to inactivity. (have not received pong from server)', platform);

        // try to reconnect or exit
        if (autoReconnect) {
          yield (0, _effects.put)(actions.lostConnection(undefined, platform));
        }
        break;
      } else {
        log.debug(`${platform} websocket last contact: ${lastContact}. Reconnect after ${maxIdleDuration}.`);
      }
    }
  }
}

/**
 * This flow is rewponsible for handling keepAlive and pingPong methods for client,
 * if keepAlive is used the client simply sends the keepAlive message to the websocket after waiting the pingInterval
 * if pingPong is used the client is responsible for pinging the server and listening for server "pong" responses via the websocket
 * the client will then determine if too much time has passed and attempt to reconnect if its not receiving server pongs or if an error occurs
 * @param {Object} ws a websoocket connected to the backend
 * @return {Object} yields a Flux standard action
 */
function* clientPingFlow(ws) {
  const { lastContact, platform, maxMissedPings, autoReconnect } = ws.kandy;
  const { checkConnectivity, method } = yield (0, _effects.select)(_selectors.getConnectivityConfig);

  let timeOfLastPong = Date.now();
  let message = '';
  let shouldCheck;

  while (true) {
    // If the flag was explicitly set in state, prefer that over the config.
    shouldCheck = yield (0, _effects.select)(_selectors.getCheckConnectivity);
    shouldCheck = typeof shouldCheck !== 'undefined' ? shouldCheck : checkConnectivity;

    const { pingInterval } = yield (0, _effects.select)(_selectors.getConnectivityConfig);
    const maxIdleDuration = pingInterval * maxMissedPings;
    const intervalInSeconds = pingInterval / 1000;

    if (shouldCheck) {
      if (method.type === _constants.connCheckMethods.PING_PONG) {
        message = { connCheck: { interval: intervalInSeconds } };
      } else if (method.type === _constants.connCheckMethods.KEEP_ALIVE) {
        message = { message_type: 'ping' };
      } else {
        log.error(`invalid connectivity method ${method}`);
        break;
      }

      log.debug(`${platform} sending a ${method.type}.`);

      const error = _sendWSMessage(ws, (0, _stringify2.default)(message));
      if (error) {
        log.error('Exception in pingFlow: ' + error.message);
        if (autoReconnect) {
          yield (0, _effects.put)(actions.lostConnection(undefined, platform));
        }
        break;
      }
    } else {
      log.debug('Set to not check websocket connectivity. Waiting for connectivity status change');

      // If we shouldn't ping, wait until we receive a trigger to (maybe) ping.
      const shouldCheckConnectivity = yield (0, _effects.take)(action => action.type === 'CHANGE_CONNECTIVITY_CHECKING' && action.payload);
      log.debug(`Connectivity check setting changed. Check connectivity?: ${shouldCheckConnectivity}`);
      continue;
    }

    const delayStartTime = Date.now();
    // Wait for either the ping interval, a disconnect or a pong from the server
    let { disconnect, serverPong } = yield (0, _effects.race)({
      expiry: (0, _effects.delay)(pingInterval),
      serverPong: (0, _effects.take)(actionTypes.RECEIVE_SERVER_PONG),
      disconnect: (0, _effects.take)(actionTypes.WS_DISCONNECT_FINISHED)
    });

    // If we receive a serverPong, we will not have waited the full pingInterval duration.
    //    Determine how long we were waiting for, so that we know how long to wait (again)
    //    to fulfill the full pingInterval duration (before restarting the ping loop).
    const timeElapsed = Date.now() - delayStartTime;

    // If we received a disconnect action, stop the pings and exit.
    if (disconnect) {
      break;
    }

    if (method.type === _constants.connCheckMethods.PING_PONG) {
      if (serverPong) {
        // we receieved a pong, wait pingInterval to send another ping
        timeOfLastPong = Date.now();

        const timeUntilNextPing = pingInterval - timeElapsed;
        let { disconnect } = yield (0, _effects.race)({
          expiry: (0, _effects.delay)(timeUntilNextPing),
          disconnect: (0, _effects.take)(actionTypes.WS_DISCONNECT_FINISHED)
        });
        // If we received a disconnect action, stop the pings and exit.
        if (disconnect) {
          break;
        }
      } else {
        if (Date.now() - timeOfLastPong >= maxIdleDuration) {
          log.warn('closing websocket due to inactivity. (have not received pong from server)', platform);

          // its been too long since the last pong, attempt to reconnect or exit
          if (autoReconnect) {
            yield (0, _effects.put)(actions.lostConnection(undefined, platform));
          }

          break;
        } else {
          log.debug(`${platform} websocket last contact: ${lastContact}. Reconnect after ${maxIdleDuration}.`);
        }
      }
    }
  }
}

/**
 * Generic Websocket message that takes a websocket and a message and sends it
 * @param  {Object} ws  websocket
 * @return {Object}     Error object
 */
function _sendWSMessage(ws, message) {
  try {
    if (ws && ws.readyState === 1) {
      ws.send(message);
    } else {
      throw new Error('websocket was not in readyState');
    }
  } catch (e) {
    return e;
  }
}

/**
 * Helper function for connecting to a websocket.
 * Attempts to connect a specified number of times before returning an error.
 * Includes a delay in between attempts, determined by configs.
 * @method connectWebsocket
 * @param  {Object} wsInfo
 * @return {Websocket|Object}  Either a connected websocket or an error object.
 */
function* connectWebsocket(wsInfo, platform) {
  let configs = yield (0, _effects.select)(_selectors.getConnectivityConfig);
  let connectionAttempt = 0;
  let delayTime = 0;
  let websocket;

  // Redux-saga take() pattern.
  // Take disconnect websocket action for this platform.
  function disconnectWebsocketPattern(action) {
    return action.type === actionTypes.WS_DISCONNECT && action.meta.platform === platform;
  }

  // If no limit is set, we will continually attempt to reconnect.
  if (!configs.reconnectLimit) {
    log.debug('No connectivity reconnect limit set.');
  }

  while (connectionAttempt < configs.reconnectLimit || !configs.reconnectLimit) {
    try {
      // Try to open the websocket. Blocking call.
      websocket = yield (0, _effects.call)(_websocket.openWebsocket, wsInfo);
      log.debug('Successfully connected to websocket.', platform);
      break;
    } catch (err) {
      connectionAttempt++;
      websocket = err;
      log.debug(`Failed websocket connection (#${connectionAttempt}): ${websocket.message}.`, platform);

      // If we want to try to reconnect, delay a certain about of time before trying.
      if (connectionAttempt < configs.reconnectLimit || !configs.reconnectLimit) {
        // Increase the delay time if we're not at the limit.
        if (delayTime !== configs.reconnectTimeLimit) {
          delayTime = configs.reconnectDelay * Math.pow(configs.reconnectTimeMultiplier, connectionAttempt - 1);
          delayTime = delayTime < configs.reconnectTimeLimit ? delayTime : configs.reconnectTimeLimit;
        }
        log.debug(`Websocket reconnect attempt after ${delayTime}ms.`, platform);

        // Wait for either the delay period or a trigger to stop connection attempts.
        let { disconnect } = yield (0, _effects.race)({
          delay: (0, _effects.delay)(delayTime),
          disconnect: (0, _effects.take)(disconnectWebsocketPattern)
        });

        if (disconnect) {
          break;
        }
      } else {
        log.debug('Stopping websocket connection attempts.', platform);
      }
    }
  }

  // Return either the websocket or the latest error.
  return websocket;
}

/***/ }),

/***/ "./src/connectivity/websocket.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.openWebsocket = openWebsocket;
exports.closeWebsocket = closeWebsocket;
exports.wsEmitter = wsEmitter;

var _actions = __webpack_require__("./src/connectivity/interface/actions.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _utils = __webpack_require__("./src/common/utils.js");

var _actions2 = __webpack_require__("./src/notifications/interface/actions.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_BUFFER_SIZE = 50;

/**
 * Create a new websocket.
 * @method openWebsocket
 * @param  {Object} options Websocket configuration options.
 * @param {string} options.protocol Websocket protocol to use.
 * @param {string} options.server Websocket hostname.
 * @param {string} options.port Websocket port to use.
 * @param {string} options.url Websocket notification channel.
 * @param {Object} options.params A list of URL params to attach to the websocket.
 * @return {WebSocket} ws Newly connected websocket.
 */
function openWebsocket(options) {
  // Create the websocket.
  let ws = new WebSocket(`${options.protocol}://${options.server}:${options.port}${options.url}` + (0, _utils.toQueryString)(options.params));

  // Use a promise to wait for the first message from the websocket.
  // This indicates whether the WS opened successfully or not.
  let validateWS = new _promise2.default((resolve, reject) => {
    const onOpen = function () {
      ws.onopen = null;
      ws.onerror = null;
      resolve(ws);
    };
    const onError = function () {
      ws.onopen = null;
      ws.onerror = null;

      // TODO: Fix this?
      /* eslint-disable-next-line prefer-promise-reject-errors */
      reject({
        error: true,
        message: 'Could not connect to websocket. Received error on open.'
      });
    };
    ws.onopen = onOpen;
    ws.onerror = onError;
  });
  return validateWS;
}

/**
 * Clean-up a provided websocket.
 * @method closeWebsocket
 * @param  {Websocket} ws Websocket to be cleaned-up.
 * @return {Websocket} ws The websocket after being cleaned.
 */
function closeWebsocket(ws) {
  if (ws.close) {
    ws.close();
  } else {
    ws.onclose = null;
  }

  ws.onmessage = null;
  ws.onopen = null;
  ws.onerror = null;
}

/**
 * Create an event channel for a given websocket
 * @param  {WebSocket} ws       The websocket to make an event channel for.
 * @param {string} [platform=link]    The backend platform associated with the websocket.
 * @return {EventChannel}              The event channel corresponding to the WebSocket
 */
function createWsChannel(ws, platform) {
  // this function handles server messages
  return (0, _reduxSaga.eventChannel)(emit => {
    // Define handlers
    ws.onmessage = message => {
      // Mark this websocket are being connected as of now.
      ws.kandy.lastContact = Date.now();

      var data = JSON.parse(message.data);
      if (data.connCheck) {
        // Handle CPaaS 2.0 server pings
        emit((0, _actions.receiveServerPing)(data, platform));
      } else if (data.connAck) {
        // Handle CPaaS 2.0 server pongs
        emit((0, _actions.receiveServerPong)(data, platform));
      } else {
        emit((0, _actions2.websocketNotification)(data, platform));
      }
    };
    ws.onclose = data => {
      emit((0, _actions.wsClosed)(data, platform));
      emit(_reduxSaga.END);
    };
    ws.onerror = err => {
      emit((0, _actions.wsError)(new Error(err), platform));
      emit(_reduxSaga.END);
    };

    return () => closeWebsocket(ws);
  }, _reduxSaga.buffers.expanding(INITIAL_BUFFER_SIZE));
}

/**
 * Saga worker for creating a websocket and emitting its events
 * @param {Object} ws configuration options.
 * @param {string} [platform=link]    The backend platform associated with the websocket.
 * @return {Generator}
 */
function* wsEmitter(ws, platform) {
  var wsChannel = yield (0, _effects.call)(createWsChannel, ws, platform);
  while (true) {
    const action = yield (0, _effects.take)(wsChannel);
    yield (0, _effects.put)(action);
  }
}

/***/ }),

/***/ "./src/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const platforms = exports.platforms = {
  LINK: 'link',
  CPAAS: 'cpaas',
  CPAAS2: 'cpaas2'
};

const notificationTypes = exports.notificationTypes = {
  WEBSOCKET: 'websocket',
  PUSH: 'push'
};

const connCheckResponsibility = exports.connCheckResponsibility = {
  CLIENT: 'client',
  SERVER: 'server'
};

const connCheckMethods = exports.connCheckMethods = {
  KEEP_ALIVE: 'keepAlive',
  PING_PONG: 'pingPong'
};

/***/ }),

/***/ "./src/errors/codes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Error codes for the Auth plugin.
 * @name authCodes
 */
const authCodes = exports.authCodes = {
  INVALID_CREDENTIALS: 'authentication:1',
  CONNECT_FAIL_WS_ERROR: 'authentication:2',
  LINK_UNSUBSCRIBE_FAIL: 'authentication:3',
  LINK_SUBSCRIBE_FAIL: 'authentication:4',
  LINK_EXTEND_SUBSCRIPTION_FAIL: 'authentication:5',
  LINK_UPDATE_SUBSCRIPTION_FAIL: 'authentication:6',
  CPAAS_SUBSCRIBE_FAIL: 'authentication:7',
  CPAAS_REFRESH_TOKEN_FAIL: 'authentication:8',
  CPAAS_CREATE_TOKEN_FAIL: 'authentication:9',
  CPAAS_EXTEND_SUBSCRIPTION_FAIL: 'authentication:10',
  CPAAS_DISCONNECT_FAIL: 'authentication:11',
  MISSING_SERVICE: 'authentication:12'

  /**
   * Error codes for the Call plugin.
   * @name callCodes
   */
};const callCodes = exports.callCodes = {
  UNKNOWN_ERROR: 'call:1',
  GENERIC_ERROR: 'call:2',
  INIT_MEDIA_FAILED: 'call:3',
  USER_MEDIA_ERROR: 'call:4',
  NOT_SUPPORTED: 'call:5',
  // The call is in the wrong state.
  INVALID_STATE: 'call:6',
  // A provided parameter is not valid.
  INVALID_PARAM: 'call:7',
  // There is a desync between components' state.
  STATE_DESYNC: 'call:8',
  // Offer could not be generated
  INVALID_OFFER: 'call:9'

  /**
   * Error codes for the Call History plugin.
   * @name callHistoryCodes
   */
};const callHistoryCodes = exports.callHistoryCodes = {
  UNKNOWN_ERROR: 'callHistory:1',
  BAD_REQUEST: 'callHistory:2',
  NOT_FOUND: 'callHistory:3'
  /**
   * @name clickToCallCodes
   */
};const clickToCallCodes = exports.clickToCallCodes = {
  MISSING_ARGS: 'clickToCall:1',
  RESPONSE_ERROR: 'clickToCall:2'

  /**
   * Error codes for the Message plugin.
   * @name messagingCodes
   */
};const messagingCodes = exports.messagingCodes = {
  CREATE_GROUP_FAIL: 'messaging:1',
  MARK_READ_FAIL: 'messaging:2',
  REMOVE_MEMBERS_FAIL: 'messaging:3',
  ADD_MEMBERS_FAIL: 'messaging:4',
  SEND_MESSAGE_FAIL: 'messaging:5',
  FETCH_MESSAGES_FAIL: 'messaging:6',
  FILE_UPLOAD_FAIL: 'messaging:7',
  FETCH_CONVERSATIONS_FAIL: 'messaging:8',
  INVALID_DESTINATION: 'messaging:9',
  INVALID_FILE_PARTS: 'messaging:10',
  SET_IS_TYPING_FAIL: 'messaging:11'

  /**
   * Error codes for the Message Waiting Indicator plugin.
   * @name mwiCodes
   */
};const mwiCodes = exports.mwiCodes = {
  FETCH_MWI_FAIL: 'mwi:1'

  /**
   * Error codes from the Sip Events plugin.
   * @name sipEventCodes
   */
};const sipEventCodes = exports.sipEventCodes = {
  UNKNOWN_ERROR: 'sipEvents:1',
  // The user did not subscribe/connect for the specified sip event service.
  NOT_PROVISIONED: 'sipEvents:2',
  // The user is not subscribed for the specified sip event.
  NOT_SUBSCRIBED: 'sipEvents:3'

  /**
   * Error codes for the audio bridge portion of the call plugin.
   * @name bridgeCodes
   */
};const bridgeCodes = exports.bridgeCodes = {
  UNKNOWN_ERROR: 'audioBridge:1',
  // TODO: Make "invalid input" (and others) a generic code.
  INVALID_INPUT: 'audioBridge:2',
  ALREADY_EXISTS: 'audioBridge:3',
  NOT_FOUND: 'audioBridge:4',
  NOT_SUPPORTED: 'audioBridge:5',
  MEDIA_NOT_FOUND: 'audioBridge:6',
  INVALID_STATE: 'audioBridge:7'

  /**
   * Error codes for the subscription plugin.
   * @name subscriptionCodes
   */
};const subscriptionCodes = exports.subscriptionCodes = {
  WS_CONNECTION_ERROR: 'subscription:1',
  CPAAS2_WSREQUEST_FAIL: 'subscription:2',
  CPAAS2_WSREVOKE_FAIL: 'subscription:3',
  CPAAS2_WSREFRESH_FAIL: 'subscription:4',
  CPAAS2_SERVICE_SUB_FAIL: 'subscription:5',
  CPAAS2_SERVICE_UNSUB_FAIL: 'subscription:6',
  CPAAS2_UNSUBSCRIBE_FAIL: 'subscription:7'
  /**
   * Error codes for the Presence plugin.
   * @name presenceCodes
   */
};const presenceCodes = exports.presenceCodes = {
  INVALID_STATUS: 'presence:1',
  INVALID_ACTIVITY: 'presence:2'

  /**
   * Error codes for the Users plugin
   * @name usersCodes
   */
};const usersCodes = exports.usersCodes = {
  UNKNOWN: 'users:1',
  REFRESH_CONTACTS_FAIL: 'users:2',
  DIRECTORY_REQUEST_FAIL: 'users:3'
};

/***/ }),

/***/ "./src/errors/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _codes = __webpack_require__("./src/errors/codes.js");

Object.defineProperty(exports, 'authCodes', {
  enumerable: true,
  get: function () {
    return _codes.authCodes;
  }
});
Object.defineProperty(exports, 'callCodes', {
  enumerable: true,
  get: function () {
    return _codes.callCodes;
  }
});
Object.defineProperty(exports, 'callHistoryCodes', {
  enumerable: true,
  get: function () {
    return _codes.callHistoryCodes;
  }
});
Object.defineProperty(exports, 'messagingCodes', {
  enumerable: true,
  get: function () {
    return _codes.messagingCodes;
  }
});
Object.defineProperty(exports, 'mwiCodes', {
  enumerable: true,
  get: function () {
    return _codes.mwiCodes;
  }
});
Object.defineProperty(exports, 'sipEventCodes', {
  enumerable: true,
  get: function () {
    return _codes.sipEventCodes;
  }
});
Object.defineProperty(exports, 'clickToCallCodes', {
  enumerable: true,
  get: function () {
    return _codes.clickToCallCodes;
  }
});
Object.defineProperty(exports, 'bridgeCodes', {
  enumerable: true,
  get: function () {
    return _codes.bridgeCodes;
  }
});
Object.defineProperty(exports, 'subscriptionCodes', {
  enumerable: true,
  get: function () {
    return _codes.subscriptionCodes;
  }
});
Object.defineProperty(exports, 'presenceCodes', {
  enumerable: true,
  get: function () {
    return _codes.presenceCodes;
  }
});
Object.defineProperty(exports, 'usersCodes', {
  enumerable: true,
  get: function () {
    return _codes.usersCodes;
  }
});
class BasicError {
  constructor({ message, code }) {
    this.name = 'BasicError';
    this.code = code || 'NO_CODE';
    this.message = message ? `${message}` : 'An error occurred.';
  }
}
exports.default = BasicError;

/***/ }),

/***/ "./src/events/eventEmitter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__("../../node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

exports.default = eventEmitter;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Event emitter module. Can be used as a standalone factory or as a mixin.
 *
 * @private
 * @class emitter
 * @example
 * ``` javascript
 * var eventEmitter = emitter(); // Create a new emitter.
 * emitter(myEmittingObject.prototype); // Mixin to an existing object.
 * ```
 */
function eventEmitter(prototype = {}) {
  var eventMap = [];
  var subscribeMap = [];
  var strictMode = false;

  /*
     * Check if the event is a valid event type.
     */
  function checkEvent(type) {
    if (strictMode && !eventMap[type]) {
      throw new Error('Invalid event type: ' + type);
    }
  }

  return (0, _assign2.default)(prototype, {
    /*
         * Define an event type with the event emitter.
         *
         * @method define
         * @param {String} type The name for the event type.
         */
    define: function (type) {
      eventMap[type] = eventMap[type] || [];
    },

    /*
         * Define an alias for an event type.
         *
         * @method alias
         * @param {String} type The event type for which to add an alias.
         * @param {String} alias The alias name for the event type.
         * @throws {Error} Invalid event type
         */
    alias: function (type, alias) {
      checkEvent(type);

      eventMap[alias] = eventMap[type] = eventMap[type] || [];
    },

    /*
         * Add an event listener for the specified event type.
         *
         * @method on
         * @param {String} type The event type for which to add the listener.
         * @param {Function} listener The listener for the event type. The parameters
         *                            of the listener depend on the event type.
         * @throws {Error} Invalid event type
         */
    on: function (type, listener) {
      checkEvent(type);(eventMap[type] = eventMap[type] || []).push(listener);
    },

    /*
         * Removes an event listener for the specified event type.
         *
         * @method off
         * @param {String} type The event type for which to remote the listener.
         * @param {Function} listener The listener to remove.
         * @throws {Error} Invalid event type
         */
    off: function (type, listener) {
      checkEvent(type);

      var list = eventMap[type] || [];
      var i = list.length;
      while (i--) {
        if (listener === list[i]) {
          list.splice(i, 1);
        }
      }
    },

    /*
         * Emits an event of the specified type.
         *
         * @method emit
         * @param {String} type The event type to emit.
         * @param {any} [...args] The arguments to pass to the listeners of the event.
         * @throws {Error} Invalid event type
         */
    emit: function (type) {
      checkEvent(type);

      var args = Array.prototype.slice.call(arguments, 1);
      var list = eventMap[type] || [];
      var i = 0;

      for (; i < list.length; i++) {
        list[i].apply(undefined, args);
      }
      for (var j = 0; j < subscribeMap.length; j++) {
        subscribeMap[j].call(undefined, type, args);
      }
    },

    /*
         * Add a subscription for all event types.
         *
         * @method subscribe
         * @param {Function} listener The listener for all event types.
         * @throws {Error} Listener not a function
         */
    subscribe: function (listener) {
      if (typeof listener === 'function') {
        subscribeMap.push(listener);
      } else {
        throw new Error('Listener not a function');
      }
    },

    /*
         * Remove a subscription for all event types.
         *
         * @method unsubscribe
         * @param {Function} listener The listener for all event types.
         * @throws {Error} Listener not a function
         */
    unsubscribe: function (listener) {
      if (typeof listener === 'function') {
        var i = subscribeMap.length;
        while (i--) {
          if (listener === subscribeMap[i]) {
            subscribeMap.splice(i, 1);
          }
        }
      } else {
        throw new Error('Listener not a function');
      }
    },

    /*
         * Sets the emitter in strict mode where it only allows events that have been defined or aliases.
         *
         * @method setStrictMode
         * @param {Boolean} strict Whether to set strict mode for the emitter.
         */
    setStrictMode: function (strict) {
      strictMode = strict;
    }
  });
}

/***/ }),

/***/ "./src/events/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = eventsImplementation;

var _interface = __webpack_require__("./src/events/interface/index.js");

var _interface2 = _interopRequireDefault(_interface);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _actionTypes = __webpack_require__("./src/events/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventEmitter = __webpack_require__("./src/events/eventEmitter.js");

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Event Emitter Implementation.
 * Factory function to create the Event Emitter Implementation.
 * Defines the functionality exposed by an Event Emitter Interface.
 */
// Events plugin.
function eventsImplementation() {
  return {
    name: _interface2.default.name,
    middleware: middleware,
    api: _interface2.default.api,
    reducer: _interface2.default.reducer
  };
}

/**
 * Implementation of Event Emitter Interface.
 * @return {Middleware} middleware Middleware to be applied to the redux store.
 */
function middleware(context) {
  var emitter = (0, _eventEmitter2.default)();
  var eventMap = {};

  /**
   * Middleware to handle Event Emitter Interface actions.
   * Redirects Interface actions to the Plugin functionality, and dispatches
   *      actions to update the store if needed.
   * @type {Function}
   */
  return next => action => {
    switch (action.type) {
      case actionTypes.EVENTS_ON:
        emitter.on(action.payload.eventType, action.payload.listener);
        break;
      case actionTypes.EVENTS_OFF:
        emitter.off(action.payload.eventType, action.payload.listener);
        break;
      case actionTypes.EVENTS_SUBSCRIBE:
        emitter.subscribe(action.payload);
        break;
      case actionTypes.EVENTS_UNSUBSCRIBE:
        emitter.unsubscribe(action.payload);
        break;
      case actionTypes.EVENTS_ALIAS:
        emitter.alias(action.payload.eventType, action.payload.alias);
        break;
      case actionTypes.EVENTS_EMIT:
        emitter.emit(action.payload.eventType, ...action.payload.args);
        break;
      case actionTypes.MAP_EVENTS:
        for (let actionType in action.payload) {
          if (action.payload.hasOwnProperty(actionType)) {
            let mapper = action.payload[actionType];
            if (eventMap.hasOwnProperty(actionType)) {
              eventMap[actionType].push(mapper);
            } else {
              eventMap[actionType] = [mapper];
            }
          }
        }
        break;
      default:
        if (eventMap.hasOwnProperty(action.type)) {
          // Get state both before and after allowing the action to go through
          //    the reducers. This lets events have compare state changes.
          const prevState = context.getState();
          let result = next(action);
          const state = context.getState();

          // make this compatible with promise middleware by ensuring we
          // wait for the promise to resolve. It's easier to just always
          // use a promise, as opposed to handling cases.
          if (!result || !result.then) {
            result = _promise2.default.resolve(result);
          }
          result.then(function () {
            for (let mapper of eventMap[action.type]) {
              // Use the mapper(s) for this specific event to create the event object(s).
              // Event mappings have access to the action and states pre+post reducer.
              let events = mapper(action, { prevState, state });
              if (!events) {
                events = [];
              } else if (!Array.isArray(events)) {
                events = [events];
              }
              for (let event of events) {
                if (!event.args) {
                  event.args = {};
                }
                context.dispatch((0, _actions.emitEvent)(event.type, event.args));
              }
            }
          });
          return result;
        }
        break;
    }

    return next(action);
  };
}

/***/ }),

/***/ "./src/events/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const PREFIX = '@@KANDY/';

const EVENTS_ON = exports.EVENTS_ON = PREFIX + 'EVENTS_ON';
const EVENTS_OFF = exports.EVENTS_OFF = PREFIX + 'EVENTS_OFF';
const EVENTS_SUBSCRIBE = exports.EVENTS_SUBSCRIBE = PREFIX + 'EVENTS_SUBSCRIBE';
const EVENTS_UNSUBSCRIBE = exports.EVENTS_UNSUBSCRIBE = PREFIX + 'EVENTS_UNSUBSCRIBE';
const EVENTS_ALIAS = exports.EVENTS_ALIAS = PREFIX + 'EVENTS_ALIAS';
const EVENTS_EMIT = exports.EVENTS_EMIT = PREFIX + 'EVENTS_EMIT';
const MAP_EVENTS = exports.MAP_EVENTS = PREFIX + 'MAP_EVENTS';

/***/ }),

/***/ "./src/events/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapEvents = mapEvents;
exports.on = on;
exports.off = off;
exports.subscribe = subscribe;
exports.unsubscribe = unsubscribe;
exports.emitEvent = emitEvent;
exports.aliasEvent = aliasEvent;

var _actionTypes = __webpack_require__("./src/events/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Add an action-to-event mapping
 * @param  {Object} mapping A mapping object
 * @return {action}          A redux action.
 */
function mapEvents(mapping) {
  return {
    type: actionTypes.MAP_EVENTS,
    payload: mapping
  };
}

/* Interface actions */

/**
 * Add a listener for a specified event type.
 *
 * @param {string} type The event type to add the listener on.
 * @param {Function} listener The event listener to be added.
 * @return {Action} action A redux action.
 */
function on(type, listener) {
  return {
    type: actionTypes.EVENTS_ON,
    payload: {
      eventType: type,
      listener: listener
    }
  };
}

/**
 * Remove a listener from a specified event type.
 *
 * @param {string} type The event type to remove the listener from.
 * @param {Function} listener The event listener to be removed.
 * @return {Action} action A redux action.
 */
function off(type, listener) {
  return {
    type: actionTypes.EVENTS_OFF,
    payload: {
      eventType: type,
      listener: listener
    }
  };
}

/**
 * Add a global event listener.
 *
 * @param {Function} listener The event listener to be added.
 * @return {Action} action A redux action.
 */
function subscribe(listener) {
  return {
    type: actionTypes.EVENTS_SUBSCRIBE,
    payload: listener
  };
}

/**
 * Remove a global event listener.
 *
 * @param {Function} listener The event listener to be removed.
 * @return {Action} action A redux action.
 */
function unsubscribe(listener) {
  return {
    type: actionTypes.EVENTS_UNSUBSCRIBE,
    payload: listener
  };
}

/* Internal actions */

/*
 * Emits an event of the specified type.
 *
 * @method emitEvent
 * @param {Object} payload Information of the event to emit.
 * @throws {Error} Invalid event type
 * @return action An EVENTS_EMIT action.
 */
function emitEvent(type, ...args) {
  if (type === undefined) {
    throw Error('Attempted to emit an event without a type.');
  }

  return {
    type: actionTypes.EVENTS_EMIT,
    payload: { eventType: type, args }
  };
}

/*
 * Define an alias for an event type.
 *
 * @method alias
 * @param {String} type The event type for which to add an alias.
 * @param {String} alias The alias name for the event type.
 */
function aliasEvent(type, alias) {
  if (type === undefined || alias === undefined) {
    throw Error('Invalid attempt to alias an event.');
  }

  return {
    type: actionTypes.EVENTS_ALIAS,
    payload: { eventType: type, alias }
  };
}

/***/ }),

/***/ "./src/events/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/events/interface/actions.js");

/**
 * API for Event Emitter plugin.
 * Defines the public end-points exposed by event plugins.
 * @param  {Object} context The sdk instance context.
 * @returns {Object} api     The interface object.
 */
function api({ dispatch }) {
  var api = {};

  /**
   * Add an event listener for the specified event type.
   *
   * @public
   * @memberof Events
   * @method on
   * @param {string} type The event type for which to add the listener.
   * @param {Function} listener The listener for the event type. The parameters of the listener depend on the event type.
   * @throws {Error} Invalid event type
   * @example
   * // Listen for events of a specific type emitted by the SDK.
   * client.on('dummy:event', function (params) {
   *    // Handle the event.
   * })
   */
  api.on = function (type, listener) {
    dispatch((0, _actions.on)(type, listener));
  };

  /**
   * Removes an event listener for the specified event type.
   *
   * @public
   * @memberof Events
   * @method off
   * @param {string} type The event type for which to remote the listener.
   * @param {Function} listener The listener to remove.
   * @throws {Error} Invalid event type
   */
  api.off = function (type, listener) {
    dispatch((0, _actions.off)(type, listener));
  };

  /**
   * Adds a global event listener
   *
   * @public
   * @memberof Events
   * @method subscribe
   * @param {Function} listener The event listener to add. The parameters are (type, ...args), where args depend on the event type.
   * @throws {Error} Listener not a function
   */
  api.subscribe = function (listener) {
    dispatch((0, _actions.subscribe)(listener));
  };

  /**
   * Removes a global event listener
   *
   * @public
   * @memberof Events
   * @method unsubscribe
   * @param {Function} listener The event listener to remove.
   * @throws {Error} Listener not a function
   */
  api.unsubscribe = function (listener) {
    dispatch((0, _actions.unsubscribe)(listener));
  };

  return api;
} /**
   * The Events feature allows an application to listen for events that the SDK emits.
   * Each other feature has a set of event types that can be subscribed to using
   * the Event APIs.
   * @public
   * @module Events
   */
// Actions the interface uses.

/***/ }),

/***/ "./src/events/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/events/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/events/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This interface is for an events plugin.
 * @type {string}
 */
// Import the components of the interface.
const name = 'events';

exports.default = {
  name,
  api: _api2.default,
  reducer: _reducers2.default
};

/***/ }),

/***/ "./src/events/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = reducer;

var _actionTypes = __webpack_require__("./src/events/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Events plugin.
function eventReducer(state = { aliases: [], count: 0 }, action) {
  switch (action.type) {
    case actionTypes.EVENTS_ON:
      return (0, _fp.update)('count', (0, _fp.add)(1), state);
    case actionTypes.EVENTS_OFF:
      return (0, _fp.update)('count', (0, _fp.add)(-1), state);
    case actionTypes.EVENTS_ALIAS:
      return (0, _fp.update)('aliases', (0, _fp.concat)(action.payload.alias), state);
    default:
      return state;
  }
}

/**
 * Reducer for Event Emitter plugin.
 * Defines the events an Event plugin should dispatch to modify state.
 * @param  {Object} [state={}] The events substate.
 * @param  {Object} action     A Flux Standard action.
 * @returns {Object} state      The new event substate.
 */


// Libraries.
function reducer(state = {}, action) {
  // Only handle event types.
  if (!(0, _fp.contains)(action.type, actionTypes)) {
    return state;
  }

  return (0, _extends3.default)({}, state, {
    [action.payload.eventType]: eventReducer(state[action.payload.eventType], action)
  });
}

/***/ }),

/***/ "./src/factory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty = __webpack_require__("../../node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

exports.factory = factory;

var _redux = __webpack_require__("../../node_modules/redux/es/index.js");

var _reduxDevtoolsExtension = __webpack_require__("../../node_modules/redux-devtools-extension/index.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _compose = __webpack_require__("../../node_modules/stampit/compose.js");

var _compose2 = _interopRequireDefault(_compose);

var _utils = __webpack_require__("./src/common/utils.js");

var _logs = __webpack_require__("./src/logs/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Helpers.
// Libraries.
const log = (0, _logs.getLogManager)().getLogger('FACTORY');

/**
 * Returns whether the passed in property descriptor represents a normal ES3 property defined like so:
 *
 * ```
 * var bar = {
 *    name: 'value'
 * };
 *
 * isNormalProperty(bar.getOwnPropertyDescriptor('name'));
 * // => true
 * ```
 *
 * @param {PropertyDescriptor} propertyDescriptor The property descriptor to check for normalcy.
 * @return {boolean} True if the property is a normal property, false otherwise.
 */


// Plugins.
function isNormalProperty({ enumerable, configurable, writable, get, set }) {
  return configurable && enumerable && writable && !get && !set;
}

const factoryDefaults = {
  enableReduxDevTools: false,
  allowProxy: false

  /**
   * Creates an instance of the SDK with the specified plugins and configuration.
   *
   * @param {Plugin[]} plugins - The list of plugins to load into this instance of the SDK.
   * @param {Object} [options] - Factory options
   * @param {boolean} [options.enableReduxDevTools] - A flag to indicate whether or not to include Redux Dev Tools
   * @param {boolean} [options.allowProxy] Whether the factory should allow the Proxy Plugin to be included.
   */
};function factory(plugins, options = factoryDefaults) {
  // Log the SDK's version (templated by webpack) on initialization.
  let version = '3.3.0';
  log.info(`CPaaS SDK version: ${version}`);

  var sagas = [];
  var store;
  var selectors = {};
  var middlewares = [];
  var reducers = {};
  var initSagas = [];
  const shared = {};
  var context = {
    capabilities: [],
    api: {},
    primitives: {},
    getState() {
      if (!store) {
        throw Error('Store is not available during factory creation');
      }
      return store.getState();
    },
    dispatch(...args) {
      if (!store) {
        throw Error('Store is not available during factory creation');
      }
      return store.dispatch(...args);
    },
    subscribe(fn) {
      if (!store) {
        throw Error('Store is not available during factory creation');
      }
      return store.subscribe(fn);
    }
  };

  // Special case middleware for logging.
  var loggerMiddleware;

  // Run all the plugins to build the context.
  // Set up each plugin component individually.
  plugins.forEach(function (plugin) {
    // Ignore the Proxy Plugin if not configured to allow it.
    if (plugin.name === 'proxy' && !options.allowProxy) {
      plugin = {};
    }

    if (plugin.capabilities) {
      context.capabilities = context.capabilities.concat(plugin.capabilities);
    }
    if (plugin.reducer) {
      reducers[plugin.name] = plugin.reducer;
    }
    if (plugin.selector) {
      selectors[plugin.name] = (0, _fp.memoize)(plugin.selector);
    }
    if (plugin.middleware) {
      if (plugin.name === 'logs') {
        loggerMiddleware = plugin.middleware;
      } else {
        middlewares.push(() => plugin.middleware(context)); // pass context to middleware instead of store
      }
    }
    if (plugin.api) {
      // The following mergeWith uses a customizer that functions like Object.assign
      // except it copies property descriptors so that accessor type properties
      // are copied fully instead of just copying their current values.
      // The first two parameters are not being used.
      context.api = (0, _fp.mergeWith)((objValue, srcValue, property, destination, source) => {
        const descriptor = (0, _getOwnPropertyDescriptor2.default)(source, property);
        if (descriptor && !isNormalProperty(descriptor)) {
          (0, _defineProperty2.default)(destination, property, descriptor);
        } else {
          if (destination === undefined) {
            destination = {};
          }
          destination[property] = source[property];
        }
      }, context.api, plugin.api(context));
    }
    if (plugin.init) {
      initSagas.push(plugin.init);
    }
    if (plugin.sagas) {
      sagas = sagas.concat(plugin.sagas);
    }
    // TODO: Revisit this. Looks a little extreme for a couple stamps...
    if (plugin.mixins) {
      // Define a base stamp that all stamps will be composed with.
      //      This gives stamps access to the factory's context.
      let baseStamp = {
        propertyDescriptors: {
          context: {
            get() {
              return context;
            }
          }
        }
      };
      for (let objName in plugin.mixins) {
        if (plugin.mixins.hasOwnProperty(objName)) {
          // Ensure that every stamp starts with the base stamp.
          if (!context.primitives.hasOwnProperty(objName)) {
            context.primitives[objName] = baseStamp;
          }
          context.primitives[objName] = (0, _compose2.default)(context.primitives[objName], plugin.mixins[objName]);
        }
      }
    }

    /**
     * Plugins are allowed to share data between them by providing it to the
     *    factory. All shared data will be collected as a single object, and
     *    that object will be provided to plugins during their `init` saga.
     * It is intended that a plugin can "override" another plugin's shared data.
     * The order that plugins are given to the factory matters because of this.
     * `plugin.shared` is expected to be an object.
     */
    if (plugin.shared) {
      for (let key in plugin.shared) {
        if (shared[key]) {
          log.debug(`Replacing shared ${key} with ${key} from ${plugin.name}.`);
          shared[key] = plugin.shared[key];
        } else {
          shared[key] = plugin.shared[key];
        }
      }
    }
  });

  if (loggerMiddleware) {
    // The redux logger middleware should be the last middleware.
    middlewares.push(() => loggerMiddleware(context));
  }

  // Compose the root saga
  function* rootSaga() {
    // Give all plugins an opportunity to initialize themselves.
    // Note: Sagas have not been forked yet, so init cannot use them
    //      by dispatching actions. See PR #698.
    // Note: If anything asynchronous is done in an init, it MUST be
    //      non-blocking (ie. use fork, not call). See PR #699.
    for (let init of initSagas) {
      // Note: Yield directly to init. If redux-saga's `call()` is used, then the
      //      factory returns before the instance is done all inits. See PR #699.
      // Provide the factory's shared data (from plugins) to the `init` saga.
      yield* init(shared);
    }
    // Run all of the sagas provided by implementation plugins.
    for (let saga of sagas) {
      yield (0, _effects.fork)((0, _utils.autoRestart)(saga));
    }
  }

  // Alias our composeMiddleware to conditionally include devTools as per the provided configuration flag
  const composeMiddleware = options.enableReduxDevTools ? _reduxDevtoolsExtension.composeWithDevTools : _redux.compose;

  // don't include saga stuff if there are no sagas.
  if (initSagas.length + sagas.length > 0) {
    var sagaMiddleware = (0, _reduxSaga2.default)();

    // Create the store with the plugins (incl. sagas) and with the configuration as the initial state.
    store = (0, _redux.createStore)((0, _redux.combineReducers)(reducers), composeMiddleware((0, _redux.applyMiddleware)(sagaMiddleware, ...middlewares)));

    sagaMiddleware.run(rootSaga);
  } else {
    // Create the store with the plugins (excl. sagas) and with the configuration as the initial state.
    store = (0, _redux.createStore)((0, _redux.combineReducers)(reducers), composeMiddleware((0, _redux.applyMiddleware)(...middlewares)));
  }

  // setup the API
  var selectState = function (state) {
    var exposedState = {};

    // Determine what state should be exposed to an application.
    plugins.forEach(function (plugin) {
      let name = plugin.name;
      // If the plugin designates a selector to filter publuc state, use it.
      if (selectors[name]) {
        exposedState[name] = selectors[name](state[name]);
      } else if (state[name]) {
        // Otherwise, just expose the state directly, but
        //      only expose state if there actually is state.
        exposedState[name] = state[name];
      }
    });
    return exposedState;
  };
  selectState = (0, _fp.memoize)(selectState);

  const publicAPI = (0, _extends3.default)({}, context.api, {
    state: {
      get: function () {
        return selectState(store.getState());
      },
      subscribe: function (...args) {
        return store.subscribe(...args);
      }
    },
    getCapabilities() {
      return context.capabilities;
    },
    getVersion() {
      return version;
    }
  });

  // Return the public API.
  return publicAPI;
}

/***/ }),

/***/ "./src/index.common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = commonIndex;

var _factory = __webpack_require__("./src/factory.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

// This is a hack to fix an issue where Lodash will add itself to
// the window scope even if it's loaded via ES6. You can remove this when
// we have an answer to https://github.com/lodash/lodash/issues/1798 .
// eslint-disable-next-line
// Disabling eslint for the next comment as we want to be able to use a disallowed word
// eslint-disable-next-line no-warning-comments
/**
 * The SDK creation factory. Create an instance of the SDK by calling this factory with the desired configurations.
 * @public
 * @method create
 * @param {config} config The configuration object.
 * @example
 * // Instantiate the SDK.
 * import { create } from 'kandy'
 * const client = create({
 *     authentication: { ... },
 *     logs: { ... },
 *     ...
 * });
 * // Use the SDK's API.
 * client.on( ... );
 */

/**
 * The configuration object. This object defines what different configuration
 * values you can use when instantiating the SDK.
 * @public
 * @module config
 */

/**
 * A set of handlers for manipulating SDP information.
 * These handlers are used to customize low-level call behaviour for very specific
 * environments and/or scenarios. They can be provided during SDK instantiation
 * to be used for all calls.
 * @public
 * @module sdpHandlers
 */

// Disabling eslint for the next comment as we want to be able to use a disallowed word
// eslint-disable-next-line no-warning-comments
/**
 * In some scenarios it's necessary to remove certain codecs being offered by the SDK to the remote party. While creating an SDP handler would allow a user to perform this type of manipulation, it is a non-trivial task that requires in-depth knowledge of WebRTC SDP.
 *
 * To facilitate this common task, the SDK provides a codec removal handler that can be used for this purpose.
 *
 * The SDP handlers are exposed on the entry point of the SDK. They need to be added to the list of SDP handlers via configuration on creation of an instance of the SDK.
 *
 * @public
 * @memberof sdpHandlers
 * @method createCodecRemover
 * @example
 * import { create, sdpHandlers } from 'kandy';
 * const codecRemover = sdpHandlers.createCodecRemover(['VP8', 'VP9'])
 * const client = create({
 *   call: {
 *     sdpHandlers: [codecRemover]
 *   }
 * })
 *
 */

/*
 * Index template file that is used to create pre-defined version of the SDK.
 */
if (_fp._) _fp._.noConflict();

function commonIndex(options = {}, plugins = []) {
  const pluginInstances = (0, _fp.map)(function (plugin) {
    return plugin.fn(options[plugin.name]);
  }, plugins);

  return (0, _factory.factory)(pluginInstances, options.common);
}

/***/ }),

/***/ "./src/index.cpaas2.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _index = __webpack_require__("./src/index.common.js");

var _index2 = _interopRequireDefault(_index);

var _basePlugins = __webpack_require__("./src/basePlugins.js");

var _basePlugins2 = _interopRequireDefault(_basePlugins);

var _cpaas = __webpack_require__("./src/auth/cpaas2/index.js");

var _cpaas2 = _interopRequireDefault(_cpaas);

var _webrtc = __webpack_require__("./src/webrtc/index.js");

var _webrtc2 = _interopRequireDefault(_webrtc);

var _webrtcProxy = __webpack_require__("./src/webrtcProxy/index.js");

var _webrtcProxy2 = _interopRequireDefault(_webrtcProxy);

var _cpaas3 = __webpack_require__("./src/call/cpaas2/index.js");

var _cpaas4 = _interopRequireDefault(_cpaas3);

var _connectivity = __webpack_require__("./src/connectivity/index.js");

var _connectivity2 = _interopRequireDefault(_connectivity);

var _cpaas5 = __webpack_require__("./src/messaging/cpaas2/index.js");

var _cpaas6 = _interopRequireDefault(_cpaas5);

var _cpaas7 = __webpack_require__("./src/notifications/cpaas2/index.js");

var _cpaas8 = _interopRequireDefault(_cpaas7);

var _cpaas9 = __webpack_require__("./src/presence/cpaas2/index.js");

var _cpaas10 = _interopRequireDefault(_cpaas9);

var _cpaas11 = __webpack_require__("./src/subscription/cpaas2/index.js");

var _cpaas12 = _interopRequireDefault(_cpaas11);

var _codecRemover = __webpack_require__("../fcs/src/js/sdp/codecRemover.js");

var _codecRemover2 = _interopRequireDefault(_codecRemover);

var _cpaas13 = __webpack_require__("./src/users/cpaas2/index.js");

var _cpaas14 = _interopRequireDefault(_cpaas13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultPlugins = [..._basePlugins2.default, { name: 'authentication', fn: _cpaas2.default }, { name: 'webrtc', fn: _webrtc2.default },
// TODO: Don't _always_ include the Proxy Plugin.
{ name: 'proxy', fn: _webrtcProxy2.default }, { name: 'call', fn: _cpaas4.default }, { name: 'connectivity', fn: _connectivity2.default }, { name: 'messaging', fn: _cpaas6.default }, { name: 'notifications', fn: _cpaas8.default }, { name: 'presence', fn: _cpaas10.default }, { name: 'subscription', fn: _cpaas12.default }, { name: 'users', fn: _cpaas14.default }];

function root(options = {}, plugins = []) {
  return (0, _index2.default)(options, [...defaultPlugins, ...plugins]);
}

// Alias 'create' to be equal to the root function
root.create = root;

root.sdpHandlers = {
  createCodecRemover: _codecRemover2.default

  // Export this way as a work-around, so it can be used as `<export>();`.
  // See: https://github.com/webpack/webpack/issues/706
};module.exports = root;

/***/ }),

/***/ "./src/logs/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = logger;
exports.getLogManager = getLogManager;

var _transformers = __webpack_require__("./src/logs/transformers.js");

var _transformers2 = _interopRequireDefault(_transformers);

var _api = __webpack_require__("./src/logs/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _actions = __webpack_require__("./src/config/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _utils = __webpack_require__("./src/common/utils.js");

var _logManager = __webpack_require__("./src/logs/logManager.js");

var _logManager2 = _interopRequireDefault(_logManager);

var _utils2 = __webpack_require__("./src/logs/utils.js");

var _reduxLogger = __webpack_require__("../../node_modules/redux-logger/dist/redux-logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default logging options


// Other plugins.
// Logs plugin.
const defaultOptions = {
  // Possible levels: trace, debug, info, warn, error, silent.
  logLevel: 'debug',
  // Flatten the log entries into a string, rather than logging more complex data types.
  flatten: false,
  // Whether a stack trace should be included with the log.
  stackTraces: false,
  // Configuration options relevant to the logging of actions
  logActions: {
    // Only show action out of prevState, action, newState.
    actionOnly: true,
    // Collapse prevState, action, nextState objects by default.
    collapsed: false,
    // Log the diff for each action.
    diff: false,
    // set redux-logger's level to debug
    level: 'debug',
    // Allow action payloads to be exposed in the logs, potentially displaying sensitive information
    exposePayloads: false
  },
  enableFcsLogs: true

  // Instantiate the log manager
};

// Redux Logger middleware


// Log manager, log levels and redux-logger options


// Libraries.
const logMgr = getLogManager(defaultOptions);

/**
 * Configuration options for the Logs feature.
 * @public
 * @name config.logs
 * @memberof config
 * @requires logs
 * @instance
 * @param {Object} logs Logs configs.
 * @param  {string} [logs.logLevel=debug] Log level to be set. See `logger.levels`.
 * @param  {boolean} [logs.flatten=false] Whether all logs should be output in a string-only format.
 * @param  {Object} [logs.logActions] Options specifically for action logs when logLevel is at DEBUG+ levels. Set this to false to not output action logs.
 * @param  {boolean} [logs.logActions.actionOnly=true] Only output information about the action itself. Omits the SDK context for when it occurred.
 * @param  {boolean} [logs.logActions.collapsed=false] Whether logs should be minimized when initially output. The full log is still output and can be inspected on the console.
 * @param  {boolean} [logs.logActions.diff=false] Include a diff of what SDK context was changed by the action.
 * @param {boolean} [logs.logActions.exposePayloads=false] Allow action payloads to be exposed in the logs, potentially displaying sensitive information
 * @param  {boolean} [logs.enableFcsLogs=true] Enable the detailed call logger.
 * @param  {boolean} [logs.enableGrouping=true] Whether to group information about an action log together in the console.
 */

/**
 * Logger Plugin.
 * @method logger
 * @param  {Object} [options] Plugin configurations. See above.
 * @return {Object} plugin A plugin object.
 */
function logger(options = {}) {
  const name = 'logs';
  // Backwards compatibility: flatten replaced logActions.flattenActions
  // TODO: Remove this after awhile.
  if (options.logActions && options.logActions.flattenActions && options.flatten === undefined) {
    logMgr.getLogger('LOGS').warn('The Logs plugin config "logActions.flattenActions" has been ' + 'deprecated in favour of "flatten", and will be removed in a future build.');
    options.flatten = options.logActions.flattenActions;
  }
  options = (0, _utils.mergeValues)(defaultOptions, options);
  // Now that plugins are being called, we can update the log manager with our desired configuration options
  logMgr.updateManager(options);

  function* init() {
    // Send the provided options to the store.
    // This will be `state.config[name]`.
    yield (0, _effects.put)((0, _actions.update)(options, name));
  }

  var components = {
    name,
    capabilities: ['logs'],
    init,
    api: _api2.default
    // Consider actions to be at the INFO log level.
    // Only export a middleware (for actions) at the appropriate levels.
  };if (logMgr.getLevel() <= _logManager.logLevels.INFO && options.logActions !== false) {
    let actionOptions = {};
    // Use different options for redux-logger depending on log level.
    if (logMgr.getLevel() === _logManager.logLevels.INFO) {
      // At the INFO level, hide everything except the action name.
      actionOptions.level = false;
      actionOptions.diff = false;
    } else {
      // At the DEBUG+ levels, use the configs.
      actionOptions = (0, _extends3.default)({}, options.logActions);
    }

    if (options.logActions.actionOnly) {
      // Hide prevState and nextState.
      // Log action and error at info level, so the browser won't hide it by default.
      actionOptions.level = {
        prevState: false,
        action: 'info',
        error: 'info',
        nextState: false
      };
    }

    if (options.logActions.excludeActions) {
      actionOptions.predicate = excludeActions(options.logActions.excludeActions);
    }

    // ALWAYS use our own logger
    actionOptions.logger = logMgr.getLogger('ACTION');
    // ALWAYS remove theming/styling from the action log messages
    actionOptions.titleFormatter = _utils2.titleFormatter;
    actionOptions.colors = false;
    // Setup the transformers based on the options.
    let transformers = (0, _transformers2.default)(options.logActions);
    // Create the logger middleware.
    components.middleware = (0, _reduxLogger.createLogger)((0, _extends3.default)({}, actionOptions, transformers));
  }
  return components;
}

/**
 * Getter checks to see if an instance of logManager exists, instantiates it if it does not, and returns
 * the instance of LogManager
 * @param {Object} [options]
 * @param {string} [options.logLevel] The logging level, as per options found in logManager.levels
 * @param {boolean} [options.flatten] Stringifies the output
 * @param {boolean} [options.stackTraces] Include stack traces in the logger's output
 * @param {boolean} [options.enableGrouping] Group log messages together
 * @returns {LogManager} an instance of our LogManager
 *
 * TODO:Fix this ugly singleton.
 */
function getLogManager(options) {
  if (!getLogManager.instance) {
    getLogManager.instance = new _logManager2.default(options);
  }
  return getLogManager.instance;
}

/**
 * Logger predicate function that will take an array of action types
 * and exclude them from logs
 * @param {Array} actions An array of action types to exclude from logs
 * @returns {function} A predicate function
 */
function excludeActions(actions) {
  return (getState, action) => !actions.includes(action.type);
}

/***/ }),

/***/ "./src/logs/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;
/**
 * The internal logger used to provide information about the SDK's behaviour.
 * The logger can provide two types of logs: basic logs and action logs. Basic
 * logs are simple lines of information about what the SDK is doing during operations.
 * Action logs are complete information about a specific action that occurred
 * within the SDK, prodiving debug information describing it.
 * The amount of information logged can be configured as part of the SDK
 * (see `configs.logs`) configuration.
 *
 * @public
 * @module Logger
 * @requires logs
 */

function api() {
  let api = {
    /**
     * Possible levels for the SDK logger.
     * @public
     * @memberof Logger
     * @property {string} SILENT Logs nothing.
     * @property {string} ERROR Only log unhandled errors.
     * @property {string} WARN Log issues that may cause problems or unexpected behaviour.
     * @property {string} INFO Log useful information and messages to indicate the SDK's internal operations.
     * @property {string} DEBUG Log information to help diagnose problematic behaviour.
     */
    levels: {
      SILENT: 'silent',
      ERROR: 'error',
      WARN: 'warn',
      INFO: 'info',
      DEBUG: 'debug'
    }
  };

  return {
    logger: api
  };
}

/***/ }),

/***/ "./src/logs/logManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logLevels = undefined;

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.default = LogManager;

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _utils = __webpack_require__("./src/logs/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposed logLevels object describes the level hierarchy
 *
 * @type {{TRACE: number, DEBUG: number, INFO: number, WARN: number, ERROR: number, SILENT: number}}
 */
const logLevels = exports.logLevels = {
  TRACE: 0,
  DEBUG: 1,
  INFO: 2,
  WARN: 3,
  ERROR: 4,
  SILENT: 5

  /**
   * Creates a log manager to provision loggers and coordinate processing of log entries
   * @method LogManager
   * @param {Object} [options]
   * @param {string} [options.logLevel='INFO']
   * @param {boolean} [options.flatten=false]
   * @param {boolean} [options.stackTraces=false]
   * @param {boolean} [options.enableGrouping=true]
   */
};function LogManager({ logLevel = 'INFO', flatten = false, stackTraces = false, enableGrouping = true }) {
  // Create a property to reference the master logger
  this._log = _loglevel2.default;
  // Always convert the logLevel string to upper case for consistency
  this.level = logLevels[logLevel.toUpperCase()];
  this._log.setLevel(this.level, false);
  // Setting flatten to true will result in stringified output
  this.flatten = flatten;
  this.stackTracesEnabled = stackTraces;

  const loggers = {};
  const _logMgr = this;

  _logMgr._log.info('Creating Log Manager');

  /**
   * Logger getter function to be used to retrieve all loggers in the SDK
   * @method getLogger
   * @param {string} name, The name of the logger to be created/retrieved
   * @returns {Logger}
   */
  this.getLogger = function getLogger(name) {
    var logger;

    if (loggers[name]) {
      logger = loggers[name];
    } else {
      logger = new Logger(name);
      loggers[logger.getName()] = logger;
    }

    return logger;
  };

  /**
   * Log handler to compose a log message and determine the appropriate console logging function to
   * print log entry
   * @method logHandler
   * @param {string} name Name of the logger.
   * @param {LogItem} logItem
   */
  this.logHandler = function logHandler(name, logItem) {
    const msg = parseLogMessage(name, logItem);

    if (logLevels[logItem.level] >= _logMgr.level) {
      switch (logLevels[logItem.level]) {
        case logLevels.TRACE:
          _logMgr._log.trace(msg, ...logItem.args);
          break;
        case logLevels.DEBUG:
          _logMgr._log.debug(msg, ...logItem.args);
          break;
        case logLevels.INFO:
          _logMgr._log.info(msg, ...logItem.args);
          break;
        case logLevels.WARN:
          _logMgr._log.warn(msg, ...logItem.args);
          break;
        case logLevels.ERROR:
          _logMgr._log.error(msg, ...logItem.args);
          break;
        case logLevels.SILENT:
          /* TODO we should implement a secondary logging mechanism, which would save the logs on a private server this secondary mechanism would also include messages that were created while logging level was set to SILENT */
          break;
        default:
          _logMgr._log.info(msg, ...logItem.args);
          break;
      }
    } else {
      /* Log level is not sufficiently Low to allow message to be visible */
    }
  };

  /**
   * Creates a new logger which can be identified by name for subsequent retrieval
   * @param name
   * @constructor
   */
  function Logger(name) {
    this.name = name;
    /**
     * Logger name getter function
     * @returns {string} name - The name of the logger
     */
    this.getName = () => {
      return this.name;
    };

    /**
     * Log function to instantiate a log item and send to handler
     * for processing
     * @param {string} level - The log function level which was used to create the log message
     * @param {string} message - The unparsed log message
     * @param {*} args - The arguments provided along the message
     */
    function log(level, message, args) {
      const logItem = new LogItem(level, message, args, isTraceEnabled());
      if (_logMgr) {
        _logMgr.logHandler(name, logItem);
      }
    }

    this.error = (msg, ...args) => {
      return log('ERROR', msg, args);
    };

    this.warn = (msg, ...args) => {
      return log('WARN', msg, args);
    };

    this.info = (msg, ...args) => {
      return log('INFO', msg, args);
    };

    this.debug = (msg, ...args) => {
      return log('DEBUG', msg, args);
    };

    this.trace = (msg, ...args) => {
      return log('TRACE', msg, args);
    };

    // Treat `logger.log` as a special case for now. Pass it straight through
    //   to the logger (without parsing/formatting). Prevents logs that aren't
    //   setup to work with the logger from being double-formatted (eg. FCS).
    // TODO: Remove `logger.log` when FCS logs work well with this log manager.
    this.log = (msg, ...args) => {
      _logMgr._log.log(msg, ...args);
    };

    /**
     * Handle group-related console functions
     * @param data
     */
    this.group = data => {
      if (_logMgr.enableGrouping === false) {
        return;
      }
      window.console.group(data);
    };

    this.groupCollapsed = data => {
      if (_logMgr.enableGrouping === false) {
        return;
      }
      window.console.groupCollapsed(data);
    };

    this.groupEnd = () => {
      if (_logMgr.enableGrouping === false) {
        return;
      }
      window.console.groupEnd();
    };
  }

  /**
   * Update the configuration of the log manager after it has been instantiated
   *
   * This is necessary as the log manager needs to be created prior to initializing each
   * of the plugins in the SDK.
   * @method updateManager
   * @param {Object} [options]
   * @param {string} [options.logLevel] the logging level, as per options found in logManager.levels
   * @param {Boolean} [options.flatten]
   * @param {Boolean} [options.stackTraces]
   */
  this.updateManager = ({ logLevel, flatten, stackTraces, enableGrouping }) => {
    // Update the manager's options _if_ they were provided.
    _logMgr.level = logLevel ? logLevels[logLevel.toUpperCase()] : _logMgr.level;
    _logMgr._log.setLevel(this.level, false);
    _logMgr.flatten = flatten || _logMgr.flatten;
    _logMgr.stackTracesEnabled = stackTraces || _logMgr.stackTracesEnabled;
    _logMgr.enableGrouping = enableGrouping;
  };

  /**
   * Getter to return the current level set in the log manager
   * @method getLevel
   * @returns {string}
   */
  this.getLevel = () => {
    return _logMgr.level;
  };

  /**
   * Helper function to check if stack traces are enabled
   * @returns {boolean}
   */
  function isTraceEnabled() {
    return _logMgr.stackTracesEnabled;
  }

  /**
   * Helper function to check if verbose mode is enabled
   * @returns {boolean}
   */
  function isVerboseEnabled() {
    return _logMgr.flatten;
  }

  /**
   * Determines type of log entry being recorded and composes an appropriate message
   * @param {string} name - The name of the logger for which this message is being parsed
   * @param {Object} logItem - The log entry
   * @returns {string} logMessage - The fully composed log message
   */
  function parseLogMessage(name, logItem) {
    let logMessage;
    switch (name) {
      case 'ACTION':
        logMessage = parseActionMessage(name, logItem);
        break;

      case 'GENERAL':
        logMessage = parseMessage(name, logItem);
        break;

      default:
        logMessage = parseMessage(name, logItem);
        break;
    }
    return logMessage;
  }

  /**
   * Determines the specific type of action if the log entry is of messageTypes.ACTION
   * @param actionArgs
   * @param message
   * @returns {*}
   */
  function getActionType(actionArgs, message) {
    if (actionArgs.length > 0 && 'type' in actionArgs[0]) {
      return actionArgs[0].type;
    }
    return message.indexOf('prev') !== -1 ? 'PREV STATE' : 'NEXT STATE';
  }

  /**
   * Parses a general purpose log message
   * @param {string} name
   * @param {Object} logItem
   * @returns {string}
   */
  function parseMessage(name, logItem) {
    if (typeof logItem !== 'undefined' && logItem.hasOwnProperty('message')) {
      if (isVerboseEnabled()) {
        // TODO: Improve the stringification process to mitigate circular JSON errors
        return `${logItem.timestamp} - ${name} - ${logItem.level} - MESSAGE - ${(0, _stringify2.default)(logItem.message)} - ARGS - ${(0, _stringify2.default)(logItem.args)}`;
      }
      return `${logItem.timestamp} - ${name} - ${logItem.level} - ${logItem.message}`;
    }
  }

  /**
   * Parses log items containing actions and composes an informative log message
   * @param name
   * @param logItem
   * @returns {string}
   */
  function parseActionMessage(name, logItem) {
    var actionType = getActionType(logItem.args, logItem.message);

    if (isVerboseEnabled()) {
      return `${logItem.timestamp} - ${name} - ${logItem.level} - MESSAGE - ${(0, _stringify2.default)(logItem.message)} - ARGS - ${(0, _stringify2.default)(logItem.args)}`;
    }

    return `${logItem.timestamp} - ${name} - ${logItem.level} - ${actionType}`;
  }
}

/**
 * Base structure for a log entry
 *
 * @constructor
 *
 * @property {string} message - The visible message being displayed by the log entry, undefined at instantiation
 * @property {string} level - The logging level
 * @property {*} args - The arguments supplied with the log entry, if supplied
 * @property {string} timestamp - The time of the log entry
 *
 * @param level
 * @param msg
 * @param [args]
 * @param [stackTraces]

 * @returns {LogItem}
 */
function LogItem(level, msg, args, stackTraces = false) {
  this.level = level;
  this.timestamp = Date.now();
  this.message = msg;

  if (typeof args !== 'undefined' || stackTraces) {
    // Always return args as an array, as this produces a consistent behaviour wherein we maintain the option to add a stack trace to the log message
    this.args = typeof args !== 'undefined' ? args : [];
    if (stackTraces) {
      // TODO: Figure out the best location to make this call, as it needs to faithfully represent the origin of the
      // logging call
      this.args.push((0, _utils.stackTrace)());
    }
  } else {
    delete this.args;
  }
  return this;
}

/***/ }),

/***/ "./src/logs/transformers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupTransformers;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Determines which redux-logger transformers we need based on options.
 * @method setupTransformers
 * @param  {Object} options
 * @return {Object} An object of transformers to be provided to redux-logger.
 */
function setupTransformers(options) {
  // A "pipeline" of all redux-logger action transformers.
  function actionPipeline(transformers) {
    return function (action) {
      transformers.forEach(function (transformer) {
        action = transformer(action);
      });
      return action;
    };
  }

  const transformers = {};
  const actionTransformers = [];
  if (!options.exposePayloads) {
    // If exposePayloads is disabled, include the removePayloads transformer
    actionTransformers.push(removePayloads);
  } else {
    // Otherwise, we should still hide passwords
    actionTransformers.push(passwordHider);
  }
  // Create the actionTransformer pipeline with the included transformers.
  transformers.actionTransformer = actionPipeline(actionTransformers);

  return transformers;
}

// Redux-logger actionTransformer to prevent passwords from being logged.
// Libraries
function passwordHider(action) {
  if (action.meta && action.meta.isSensitive) {
    // Only log the action name for actions that have sensitive data in them.
    return (0, _fp.omit)('payload', action);
  }
  return action;
}

/**
 * Helper function removes secure data if secure mode is enabled
 * @param {Object} action
 */
function removePayloads(action) {
  if (!(action.meta && action.meta.isSafe)) {
    return (0, _fp.omit)('payload', action);
  }
  return action;
}

/***/ }),

/***/ "./src/logs/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stackTrace = stackTrace;
exports.titleFormatter = titleFormatter;

var _errorStackParser = __webpack_require__("../../node_modules/error-stack-parser/error-stack-parser.js");

var ErrorStackParser = _interopRequireWildcard(_errorStackParser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Utility function to perform a stack trace at any given point in the application
 * Removing the first 4 elements to make the first element of array represent
 * the point of origin where log function was called
 *
 * @returns {*}
 */
function stackTrace() {
  return ErrorStackParser.parse(new Error());
}

/**
 * Standard title formatter function is almost identical to the defaultTitleFormatter found in redux-logger
 * but removes placeholder characters previously used for styling, which is not being used in the logging
 * configuration
 *
 * @param action
 * @param time
 * @param took
 * @returns {string}
 */
function titleFormatter(action, time, took) {
  var parts = ['action'];
  parts.push(action.type);
  parts.push('@ ' + time);
  parts.push('(in ' + took.toFixed(2) + ' ms)');

  return parts.join(' ');
}

/***/ }),

/***/ "./src/messaging/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cpaas2Messaging;

var _interface = __webpack_require__("./src/messaging/cpaas2/interface/index.js");

var _interface2 = _interopRequireDefault(_interface);

var _sagas = __webpack_require__("./src/messaging/cpaas2/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _events = __webpack_require__("./src/messaging/cpaas2/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _actions2 = __webpack_require__("./src/config/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Factory function for the CPaaS 2 messaging plugin.
 * @method cpaas2Messaging
 * @param  {Object} [options={}]
 * @return {Object} A plugin object.
 */


// Libraries.


// Other plugins.
function cpaas2Messaging(options = {}) {
  const defaultOptions = {
    features: ['base', 'history', 'rich', 'parts', 'isTyping']
  };
  options = (0, _fp.defaults)(defaultOptions, options);

  function* init() {
    yield (0, _effects.put)((0, _actions2.update)(options, _interface2.default.name));
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));
  }

  const capabilities = ['sms', 'chat', 'parts', 'history', 'internalAndSmsMessaging', 'isTyping'];

  return {
    capabilities,
    api: _interface2.default.api,
    name: _interface2.default.name,
    reducer: _interface2.default.reducer,
    mixins: _interface2.default.mixins,
    sagas: (0, _fp.values)(sagas),
    init
  };
} // Messaging plugin.

/***/ }),

/***/ "./src/messaging/cpaas2/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const PREFIX = '@@KANDY/';

const CREATE_CONVERSATION = exports.CREATE_CONVERSATION = PREFIX + 'CREATE_CONVERSATION';
const SEND_MESSAGE = exports.SEND_MESSAGE = PREFIX + 'SEND_MESSAGE';
const SEND_MESSAGE_FINISH = exports.SEND_MESSAGE_FINISH = PREFIX + 'SEND_MESSAGE_FINISH';
const MESSAGE_RECEIVED = exports.MESSAGE_RECEIVED = PREFIX + 'MESSAGE_RECEIVED';
const INCOMING_MESSAGE_READ = exports.INCOMING_MESSAGE_READ = PREFIX + 'INCOMING_MESSAGE_READ';
const SEND_MESSAGE_READ = exports.SEND_MESSAGE_READ = PREFIX + 'SEND_MESSAGE_READ';
const SEND_MESSAGE_READ_FINISH = exports.SEND_MESSAGE_READ_FINISH = PREFIX + 'SEND_MESSAGE_READ_FINISH';

const CLEAR_MESSAGES = exports.CLEAR_MESSAGES = PREFIX + 'CLEAR_MESSAGES';
const CLEAR_MESSAGES_FINISH = exports.CLEAR_MESSAGES_FINISH = PREFIX + 'CLEAR_MESSAGES_FINISH';

const DELETE_CONVERSATION = exports.DELETE_CONVERSATION = PREFIX + 'DELETE_CONVERSATION';
const DELETE_CONVERSATION_FINISH = exports.DELETE_CONVERSATION_FINISH = PREFIX + 'DELETE_CONVERSATION_FINISH';

const DELETE_MESSAGE = exports.DELETE_MESSAGE = PREFIX + 'DELETE_MESSAGES';
const DELETE_MESSAGE_FINISH = exports.DELETE_MESSAGE_FINISH = PREFIX + 'DELETE_MESSAGES_FINISH';

const FETCH_CONVERSATIONS = exports.FETCH_CONVERSATIONS = PREFIX + 'FETCH_CONVERSATIONS';
const FETCH_CONVERSATIONS_FINISHED = exports.FETCH_CONVERSATIONS_FINISHED = PREFIX + 'FETCH_CONVERSATIONS_FINISHED';

const UPDATE_CONVERSATION = exports.UPDATE_CONVERSATION = PREFIX + 'UPDATE_CONVERSATION';

const FETCH_MESSAGES = exports.FETCH_MESSAGES = PREFIX + 'FETCH_MESSAGES';
const FETCH_MESSAGES_FINISHED = exports.FETCH_MESSAGES_FINISHED = PREFIX + 'FETCH_MESSAGES_FINISHED';

const RECEIVE_DELIVERY_RECEIPT = exports.RECEIVE_DELIVERY_RECEIPT = PREFIX + 'RECEIVE_DELIVERY_RECEIPT';

const FILE_UPLOAD_FAIL = exports.FILE_UPLOAD_FAIL = PREFIX + 'FILE_UPLOAD_FAIL';

const SET_IS_TYPING = exports.SET_IS_TYPING = PREFIX + 'SET_IS_TYPING';
const SET_IS_TYPING_FINISHED = exports.SET_IS_TYPING_FINISHED = PREFIX + 'SET_IS_TYPING_FINISHED';

const GET_IMAGE_LINKS = exports.GET_IMAGE_LINKS = PREFIX + 'GET_IMAGE_LINKS';
const GET_IMAGE_LINKS_FINISH = exports.GET_IMAGE_LINKS_FINISH = PREFIX + 'GET_IMAGE_LINKS_FINISH';

/***/ }),

/***/ "./src/messaging/cpaas2/interface/actions/conversations.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.createConversation = createConversation;
exports.fetchConversations = fetchConversations;
exports.fetchConversationsFinished = fetchConversationsFinished;
exports.updateConversation = updateConversation;
exports.deleteConversation = deleteConversation;
exports.deleteConversationFinish = deleteConversationFinish;
exports.setIsTyping = setIsTyping;
exports.setIsTypingFinished = setIsTypingFinished;

var _actionTypes = __webpack_require__("./src/messaging/cpaas2/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Conversation actions.
 * Actions relating to the creation/management of conversation objects.
 */

/**
 * Creates a create conversation action. Triggered when the user creates a new conversation object.
 *
 * @method createConversation
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {Object} options The options object can contain any keys an app may want passed along into the conversation object in the store.
 * @returns {Object} A flux standard action representing the create conversation action.
 */
function createConversation(destination, options) {
  return {
    type: actionTypes.CREATE_CONVERSATION,
    payload: (0, _extends3.default)({
      destination: destination,
      messages: [],
      isTypingList: []
    }, options)
  };
}

/**
 * Creates a fetch conversations action. This is dispatched by the API directly.
 * @param {Object} [options] An optional configuration object to query for more specific results. If no object is passed, all threads will be retrieved
 * @method fetchConversations
 * @returns {Object} A flux standard action representing the fetch conversations action.
 */
function fetchConversations(options) {
  return {
    type: actionTypes.FETCH_CONVERSATIONS,
    payload: (0, _extends3.default)({}, options)
  };
}

/**
 * Creates a fetch conversations finished action.
 * @method fetchConversationsFinished
 * @param {Object} $0
 * @param {Array} [$0.conversations] An array of conversation objects, if fetch was successful
 * @param {Object} [$0.error] An error object, only included if fetchConversations implementation had an error.
 * @returns {Object} A flux standard action representing the fetch conversations finished action.
 */
function fetchConversationsFinished({ conversations, error }) {
  return {
    type: actionTypes.FETCH_CONVERSATIONS_FINISHED,
    payload: error || { conversations },
    error: Boolean(error)
  };
}

/**
 * Creates an update conversation action.
 *
 * @method updateConversation
 * @param {Object} conversation The conversation object
 * @param {Array} conversation.destination An array of strings representing the destinations for messages that are sent from this conversation object. This property is always required, as it is the primary property by which conversations are organized in messaging plugin
 * @param {number} [conversation.id] The conversation object's corresponding thread ID
 * @param {string} [conversation.type] The conversation type, which is expected to be one of: "im", "sms", "group".
 * @returns {Object} A flux standard action representing the create conversation action.
 */
function updateConversation(conversation) {
  return {
    type: actionTypes.UPDATE_CONVERSATION,
    payload: conversation
  };
}

/**
 * Request to delete all the messages from a conversation.
 * @method deleteConversation
 * @param  {string} destination The destination for messages created in this conversation.
 * @param {string} type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @returns {Object} A flux standard action.
 */
function deleteConversation(destination, type) {
  return {
    type: actionTypes.DELETE_CONVERSATION,
    payload: {
      destination: destination,
      type: type
    }
  };
}

/**
 * Creates a fetch messages finished action.
 * @method deleteConversationFinish
 * @param {Object} $0
 * @param {Array} $0.destination An array of destinations for messages created in this conversation.
 * @param {string} $0.type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @param {Object} [$0.error] An error object, only present if an error occurred.
 * @returns {Object} A flux standard action representing the fetch messages finished action.
 */
function deleteConversationFinish({ destination, type, error }) {
  return {
    type: actionTypes.DELETE_CONVERSATION_FINISH,
    payload: error || { destination, type },
    error: !!error
  };
}

/**
 *
 * @param {Object} $0
 * @param {string} $0.state (active/idle) state of the typing user
 * @param {string} $0.destination the target user to send the notification to
 * @returns {Object}
 */
function setIsTyping({ state, destination }) {
  return {
    type: actionTypes.SET_IS_TYPING,
    payload: { state, destination }
  };
}

/**
 *
 * @param {Object} $0
 * @param {string} $0.state (active/idle) state of the typing user
 * @param {string} $0.senderAddress the username of the user who sent the notification
 * @param {string} $0.destination the target user to send the notification to
 * @param {string} $0.type a standard error object
 * @param {BasicError} $0.error a standard error object
 * @returns {Object}
 */
function setIsTypingFinished({ state, senderAddress, destination, type, error }) {
  return {
    type: actionTypes.SET_IS_TYPING_FINISHED,
    payload: error || { state, senderAddress, destination, type },
    error: !!error
  };
}

/***/ }),

/***/ "./src/messaging/cpaas2/interface/actions/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convoActions = exports.messageActions = undefined;

var _messages = __webpack_require__("./src/messaging/cpaas2/interface/actions/messages.js");

var messageActionsImport = _interopRequireWildcard(_messages);

var _conversations = __webpack_require__("./src/messaging/cpaas2/interface/actions/conversations.js");

var convoActionsImport = _interopRequireWildcard(_conversations);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Apparently the following doesn't work:
//      export * as newName from './place';
// So import everything from each file, then re-export.

/**
 * The messaging plugin's actions are organized into three types:
 *  - message actions: those which act on message object,
 *  - convo actions: those which act on conversation objects,
 *  - group actions: those which manage groups.
 */
const messageActions = exports.messageActions = messageActionsImport;
const convoActions = exports.convoActions = convoActionsImport;

/***/ }),

/***/ "./src/messaging/cpaas2/interface/actions/messages.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendMessageRead = exports.incomingMessageRead = exports.sendMessageFinish = exports.sendMessage = exports.deliveryReceiptReceived = undefined;
exports.messageReceived = messageReceived;
exports.sendMessageReadFinish = sendMessageReadFinish;
exports.fetchMessages = fetchMessages;
exports.fetchMessagesFinished = fetchMessagesFinished;
exports.clearMessages = clearMessages;
exports.deleteMessage = deleteMessage;
exports.deleteMessageFinish = deleteMessageFinish;
exports.getImageLinks = getImageLinks;
exports.getImageLinksFinish = getImageLinksFinish;

var _actionTypes = __webpack_require__("./src/messaging/cpaas2/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Action helper functions.
 */

function sendMessageHelper(actionType, destination, parts, timestamp, type, id) {
  return {
    type: actionType,
    payload: {
      destination,
      id: id,
      message: {
        timestamp,
        isPending: true,
        read: false,
        parts,
        type
      }
    }
  };
}

function messageReadHelper(actionType, messageId, participant) {
  return {
    type: actionType,
    payload: { messageId, participant }
  };
}

/**
 * Message actions.
 * Actions about the CRUD of message objects.
 */

/**
 * An action fired when a delivery receipt is received
 *
 * @method deliveryReceiptReceived
 * @param {string} messageId the id of the sent message
 * @param {string} deliveryStatus the status of sent message
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {string} type Type of message. 'im', 'group' or 'sms'.
 * @returns {Object} A flux standard action representing the send message action.
 */
const deliveryReceiptReceived = exports.deliveryReceiptReceived = (messageId, deliveryStatus, destination, type) => {
  return {
    type: actionTypes.RECEIVE_DELIVERY_RECEIPT,
    payload: { messageId, deliveryStatus, destination, type }
  };
};

/**
 * Creates a send message action. Triggered when the user initiates the send message process.
 *
 * @method sendMessage
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {Array} parts The message parts, as a formatted object.
 * @param {number} timestamp A timestamp for the sent message.
 * @param {number} id The ID of the conversation as it exists in the back end.
 * @param {string} type Type of message. 'im', 'group' or 'sms'.
 * @returns {Object} A flux standard action representing the send message action.
 */
const sendMessage = exports.sendMessage = (destination, parts, timestamp, type, id) => sendMessageHelper(actionTypes.SEND_MESSAGE, destination, parts, timestamp, type, id);

/**
 * Creates a send message finished action. Trigged when a message send function has received a success response.
 *
 * @method sendMessageFinish
 * @param {Object} $0
 * @param {Array} $0.destination An array of destinations for messages created in this conversation.
 * @param {string} $0.sender The sender of the outgoing message.
 * @param {string} $0.type The type of conversation: can be one of 'im', 'sms' or 'group'
 * @param {Array} $0.parts The message parts.
 * @param {number} $0.timestamp A timestamp for the sent message.
 * @param {string} [$0.messageId] The returned messageId of the message if sent successfully.
 * @param {string} [$0.deliveryStatus] The status of sent message
 * @param {Object} [$0.error] A basic error object
 * @returns {Object} A flux standard action representing the send message finished action.
 */
const sendMessageFinish = exports.sendMessageFinish = ({
  destination,
  sender,
  type,
  parts,
  timestamp,
  messageId,
  deliveryStatus,
  error
}) => {
  return {
    type: actionTypes.SEND_MESSAGE_FINISH,
    payload: { destination, sender, type, parts, timestamp, messageId, deliveryStatus, error },
    error: Boolean(error)
  };
};

/**
 * Creates a message received action. Triggered when the websocket receives a chat message.
 *
 * @method messageReceived
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {Array} parts The message parts.
 * @param {string} messageId The messageId of the message that has been received.
 * @param {string} sender The user who sent the message. This is the user who the conversation is with.
 * @param {number} timestamp A timestamp for the sent message.
 * @param {Object} meta - A meta object.
 * @param {string} meta.type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @param {boolean} meta.newConversation - A boolean value indicating whether the message corresponds to a conversation not yet in the store.
 * @returns {Object} A flux standard action representing the message received action.
 */
function messageReceived(destination, parts, messageId, sender, timestamp, meta = { type: 'im', newConversation: false }) {
  return {
    type: actionTypes.MESSAGE_RECEIVED,
    meta: meta,
    payload: {
      destination: destination,
      message: {
        timestamp: timestamp,
        isPending: false,
        read: false,
        parts: parts,
        sender: sender,
        messageId: messageId
      }
    }
  };
}

/**
 * Creates an incoming message read action. This triggers when we receive a "Message Read" notification over the websocket.
 *
 * @method incomingMessageRead
 * @param {string} messageId The unique id of the message being marked as read.
 * @param {string} participant The other pariticipant of the conversation.
 * @returns {Object} A flux standard action representing the incoming message read action.
 */
const incomingMessageRead = exports.incomingMessageRead = (messageId, participant) => messageReadHelper(actionTypes.INCOMING_MESSAGE_READ, messageId, participant);

/**
 * Creates a send message read action. This should send a "mark message as read" request to the server.
 *
 * @method sendMessageRead
 * @param {string} messageId The unique id of the message being marked as read.
 * @param {string} participant The other pariticipant of the conversation.
 * @returns {Object} A flux standard action representing the send message read action.
 */
const sendMessageRead = exports.sendMessageRead = (messageId, participant) => messageReadHelper(actionTypes.SEND_MESSAGE_READ, messageId, participant);

/**
 * Creates a send message read finish action. This triggers on server response when attempting to mark a message read.
 *
 * @method sendMessageReadFinish
 * @param {Object} $0
 * @param {string} $0.messageId The unique id of the message being marked as read.
 * @param {string} $0.participant The other participant of the conversation.
 * @param {Object} $0.error A Basic error object.
 * @returns {Object} A flux standard action representing the send message read finish action.
 */
function sendMessageReadFinish({ messageId, participant, error }) {
  return {
    type: actionTypes.SEND_MESSAGE_READ_FINISH,
    payload: error || { messageId, participant },
    error: Boolean(error)
  };
}

/**
 * Creates a fetch messages action. This is dispatched by the API directly.
 * @method fetchMessages
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {number} amount A number representing the amount of messages to fetch.
 * @returns {Object} A flux standard action representing the fetch messages action.
 */
function fetchMessages(destination, amount, type) {
  return {
    type: actionTypes.FETCH_MESSAGES,
    payload: { destination, amount, type }
  };
}

/**
 * Creates a fetch messages finished action.
 * @method fetchMessagesFinished
 * @param {Array} destination An array of destinations for messages created in this conversation.
 * @param {string} type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @param {Array} messages An array of formatted messages to put into the store.
 * @param {Object} [error] An error object, only present if an error occurred.
 * @returns {Object} A flux standard action representing the fetch messages finished action.
 */
function fetchMessagesFinished(destination, type, messages, error) {
  return {
    type: actionTypes.FETCH_MESSAGES_FINISHED,
    payload: error || { destination, type, messages },
    error: !!error
  };
}

/**
 * Request to clear messages from a conversation's state.
 * @method clearMessages
 * @param  {string} destination The destination for messages created in this conversation.
 * @param {string} type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @returns {Object} A flux standard action.
 */
function clearMessages(destination, type) {
  return {
    type: actionTypes.CLEAR_MESSAGES,
    payload: {
      destination: destination,
      type: type
    }
  };
}

/**
 * Request to delete all the messages from a conversation.
 * @method deleteMessage
 * @param  {string} destination The destination for messages created in this conversation.
 * @param {string} type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @param {string} messageId The ID of the message targeted for deletion
 * @returns {Object} A flux standard action.
 */
function deleteMessage(destination, type, messageId) {
  return {
    type: actionTypes.DELETE_MESSAGE,
    payload: {
      destination: destination,
      type: type,
      messageId: messageId
    }
  };
}

/**
 * Creates a fetch messages finished action.
 * @method deleteMessagesFinish
 * @param {Object} $0
 * @param {Array} $0.destination An array of destinations for messages created in this conversation.
 * @param {string} $0.type The type of conversation: can be one of "im", "sms", "group" or "other"
 * @param {string} $0.messageId The ID of the message that was targeted for deletion
 * @param {Object} [$0.error] An error object, only present if an error occurred.
 * @returns {Object} A flux standard action representing the fetch messages finished action.
 */
function deleteMessageFinish({ destination, type, messageId, error }) {
  return {
    type: actionTypes.DELETE_MESSAGE_FINISH,
    payload: error || { destination, type, messageId },
    error: !!error
  };
}

/**
 * Returns a get image links action
 * @method getImageLinks
 * @param {Object} $0
 * @param {Array} $0.parts the different parts of the message
 * @param {string} $0.destination the destination address(es)
 * @param {string} $0.type the type of message (chat, group, SMS
 * @param {string} $0.messageId id for looking up the message
 * @returns {Object}
 */
function getImageLinks({ parts, destination, type, messageId }) {
  return {
    type: actionTypes.GET_IMAGE_LINKS,
    payload: { parts, destination, type, messageId }
  };
}

/**
 * Returns a get image links finish action
 * @method getImageLinksFinish
 * @param {Object} $0
 * @param {string} $0.url the url that returns an attachment
 * @param {string} $0.rawURL the url returned when we upload an image
 * @param {Array} $0.destination the destination address(es)
 * @param {string} $0.typethe type of message (chat, group, SMS
 * @param {string} $0.messageId id for looking up the message
 * @param {Object} [$0.error] a standard error object
 * @returns {Object}
 */
function getImageLinksFinish({ url, rawURL, destination, type, messageId, error }) {
  return {
    type: actionTypes.GET_IMAGE_LINKS_FINISH,
    payload: error || { url, rawURL, destination, type, messageId },
    error: !!error
  };
}

/***/ }),

/***/ "./src/messaging/cpaas2/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/messaging/cpaas2/interface/actions/index.js");

var _selectors = __webpack_require__("./src/messaging/cpaas2/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

// Retrieve logger
const log = (0, _logs.getLogManager)().getLogger('Messaging'); /**
                                                                * The messaging feature revolves around a "conversation" structure. It is responsible to store the conversations
                                                                * and its messages, and return conversation objects when requested.
                                                                *
                                                                * See the "Conversation" and "Message" sections of the documentation for more details.
                                                                *
                                                                *
                                                                * Messaging functions are all part of the 'conversation' namespace. Ex: client.conversation.get('id').
                                                                *
                                                                * @public
                                                                * @module Messaging
                                                                */

function api(context) {
  const messagingApi = {
    // TODO: Revise this API's argument, since it is using names that are defined by CIM  they are not very descriptive.
    /**
     * Attempts to retrieve a list of conversations that the current user is a part of.
     * These conversations can then be retrieved from the store using get().
     *
     * @public
     * @param {Object} [options] An optional configuration object to query for more specific results.
     * If no object is passed, all threads will be retrieved.
     * @param {string} [options.touched] The unix timestamp in seconds representing the date from which
     *  to return any threads that have changed. Can also pass the string literal "lastcheck", resulting in
     *  the back-end making use of the most recent date value provided in a previous request
     * @param {string} [options.type] Limit results to one of: "internal", "sms", "group" or "unknown".
     * @param {string|number} [options.thread] Limit results to one thread specified by its thread handle.
     * @memberof Messaging
     * @requires fetchConversations
     * @method fetch
     */
    fetch: function (options = {}) {
      context.dispatch(_actions.convoActions.fetchConversations(options));
    },
    /**
     * Get a conversation object matching the user ID provided
     * If successful, the event 'conversations:change' will be emitted.
     * If a conversation with the given user ID already exists in the store, it will be returned; otherwise, a new conversation will be created.
     *
     * @public
     * @memberof Messaging
     * @requires onlyInternalMessaging
     * @method get
     * @param {string} destination The destination for messages created in this conversation. This will
     * be a user's sip address.
     * @returns {Conversation} A Conversation object.
     */
    /**
     * Get a conversation object matching the user IDs provided.
     * If successful, the event 'conversations:change' will be emitted.
     * Multi-user conversations have a destination comprised of multiple user IDs.
     *
     * @public
     * @memberof Messaging
     * @requires multiUserConversation
     * @method get
     * @param {Array} destination An array of destinations for messages created in this conversation.
     * These will be a user's sip address.
     * @returns {Conversation} A Conversation object.
     */
    /**
     * Get a conversation object matching the user ID provided.
     *
     * If a conversation with the given user ID already exists in the store, it will be returned; otherwise, a new conversation will be created
     *
     * @public
     * @memberof Messaging
     * @requires internalAndSmsMessaging
     * @method get
     * @param {string} recipient The destination for messages created in this conversation. This
     * will be a user's sip address.
     * @param {string} type The type of conversation to create. Can be one of "im", "sms" or "other"
     * @returns {Object} A Conversation object.
     */
    get: function (recipient, options = { type: 'im' }) {
      let destination = Array.isArray(recipient) ? [...recipient] : [recipient];
      let description = 'Conversation';
      let messages;
      let id;

      const conversation = (0, _selectors.findConversation)(context.getState(), destination, options.type);
      if (conversation) {
        if (options.type === conversation.type) {
          description = conversation.description;
          messages = conversation.messages;
          id = conversation.id;

          return context.primitives.Conversation({
            destination,
            type: options.type,
            id: id,
            description,
            messages: messages,
            isTypingList: conversation.isTypingList,
            lastReceived: conversation ? conversation.lastReceived : undefined,
            lastPull: conversation ? conversation.lastPull : undefined
          });
        } else {
          log.info('Conversation found with matching destination, but conversation type does not match the type requested. Please specify the appropriate type, or call client.conversation.create() for a new type of conversation');
        }
      } else {
        log.info('Requested conversation not in state. Please use the create function if you would like a new conversation object');
      }
      return undefined;
    },
    /**
     * Create and return a new conversation object. Any messages being sent through this conversation
     * object will be sent to the destination provided
     *
     * @public
     * @memberof Messaging
     * @requires internalAndSmsMessaging
     * @method create
     * @param {string} recipient
     * @param options
     * @returns {Object} a Conversation object
     */
    /**
     * Create and return a new conversation object. Any messages being sent through this conversation
     * object will be sent to the destinations provided
     *
     * @public
     * @memberof Messaging
     * @requires multiUserConversation
     * @method create
     * @param {Array} recipient An array of destinations for messages created in this conversation. These will be a user's sip address.
     * @param {string} type The type of conversation to create. Can be one of "im", "sms", "group" or "other"
     * @param options
     * @returns {Object} a Conversation object
     */
    create: function (recipient, options = { type: 'im' }) {
      const destination = Array.isArray(recipient) ? recipient : [recipient];
      const prevConv = (0, _selectors.findConversation)(context.getState(), destination, options.type);

      if (!prevConv) {
        context.dispatch(_actions.convoActions.createConversation(destination, options));
      }

      return context.primitives.Conversation({
        destination,
        type: options.type
      });
    },
    /**
     * Returns all conversations currently tracked by the SDK
     *
     * @public
     * @memberof Messaging
     * @requires internalAndSmsMessaging
     * @method getAll
     * @returns {Array} An array of conversation objects.
     */
    getAll: function () {
      return (0, _selectors.getConversations)(context.getState());
    }
  };
  return { conversation: messagingApi };
}

/***/ }),

/***/ "./src/messaging/cpaas2/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A new conversation has been created and added to the state.
 *
 * @public
 * @memberof Messaging
 * @event conversations:new
 */
const CONVERSATIONS_NEW = exports.CONVERSATIONS_NEW = 'conversations:new';

/**
 * A change has occured in the conversation list.
 *
 * @public
 * @memberof Messaging
 * @event conversations:change
 * @param {Array} params An array of objects containing information about the conversations that have changed
 * @param {Array} params.destination The destination for messages created in this conversation.
 * @param {string} params.type The type of conversation to create. Can be one of "chat", "im", "sms" or "group"
 */
const CONVERSATIONS_CHANGE = exports.CONVERSATIONS_CHANGE = 'conversations:change';

/**
 * A change has occured in a specific conversations message list.
 * If a single message was affected/created, `messageId` will be present
 * as part of the event argument.
 *
 * @public
 * @memberof Messaging
 * @event messages:change
 * @param {Object} params
 * @param {string} params.destination The destination for messages created in this conversation.
 * @param {string} params.type The type of conversation to create. Can be one of "chat", "im", "sms" or "group"
 * @param {string} [params.messageId] The ID of the message affected.
 * @param {string} [params.sender] The username of the sender of the message which caused the `messages:change` event to be triggered.
 */
const MESSAGES_CHANGE = exports.MESSAGES_CHANGE = 'messages:change';

/**
 * An error occured with messaging.
 *
 * @public
 * @memberof Messaging
 * @event messages:error
 * @param {Object} params
 * @param {BasicError} params.error The Basic error object.
 */
const MESSAGES_ERROR = exports.MESSAGES_ERROR = 'messages:error';

/**
 * The List of users that are currently typing has changed.
 *
 * @public
 * @requires isTyping
 * @memberof Messaging
 * @event isTypingList:change
 * @param {Object} params
 * @param {string} params.destination The destination for messages created in this conversation.
 * @param {string} params.type The type of conversation to create. Can be one of "chat", "im", "sms" or "group"
 * @param {string} [params.sender] The username of the sender that caused the event to trigger
 */
const IS_TYPING_LIST_CHANGE = exports.IS_TYPING_LIST_CHANGE = 'isTypingList:change';

/***/ }),

/***/ "./src/messaging/cpaas2/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/messaging/cpaas2/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventTypes = __webpack_require__("./src/messaging/cpaas2/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const eventsMap = {};

eventsMap[actionTypes.CREATE_CONVERSATION] = function (action) {
  return {
    type: eventTypes.CONVERSATIONS_NEW
  };
};

eventsMap[actionTypes.SEND_MESSAGE_FINISH] = function (action) {
  return {
    type: eventTypes.MESSAGES_CHANGE,
    args: {
      destination: action.payload.destination,
      type: action.payload.type,
      messageId: action.payload.messageId,
      sender: action.payload.sender
    }
  };
};

eventsMap[actionTypes.MESSAGE_RECEIVED] = function (action) {
  let { meta, payload } = action;
  if (meta.newConversation) {
    return {
      type: eventTypes.CONVERSATIONS_CHANGE,
      args: [{
        destination: payload.destination,
        type: action.meta.type
      }]
    };
  }
  return {
    type: eventTypes.MESSAGES_CHANGE,
    args: {
      destination: payload.destination,
      messageId: payload.message.messageId,
      type: action.meta.type
    }
  };
};

eventsMap[actionTypes.FETCH_CONVERSATIONS_FINISHED] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.MESSAGING_ERROR,
      args: { error: action.payload }
    };
  } else {
    return {
      type: eventTypes.CONVERSATIONS_CHANGE,
      args: action.payload.conversations.map(conversation => {
        return {
          destination: conversation.destination,
          type: conversation.type
        };
      })
    };
  }
};

eventsMap[actionTypes.DELETE_CONVERSATION_FINISH] = function (action, { state }) {
  if (action.error) {
    return {
      type: eventTypes.MESSAGES_ERROR,
      args: { error: action.payload }
    };
  } else {
    return {
      type: eventTypes.CONVERSATIONS_CHANGE,
      args: state.messaging.conversations.map(conversation => {
        if (!((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type)) {
          return {
            destination: conversation.destination,
            type: conversation.type
          };
        }
      })
    };
  }
};

eventsMap[actionTypes.FETCH_MESSAGES_FINISHED] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.MESSAGING_ERROR,
      args: action.payload
    };
  } else {
    return {
      type: eventTypes.MESSAGES_CHANGE,
      args: {
        destination: action.payload.destination,
        type: action.payload.type
      }
    };
  }
};

eventsMap[actionTypes.CLEAR_MESSAGES] = function (action) {
  return {
    type: eventTypes.MESSAGES_CHANGE,
    args: action.payload
  };
};

eventsMap[actionTypes.DELETE_MESSAGE_FINISH] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.MESSAGES_ERROR,
      args: action.payload
    };
  } else {
    return {
      type: eventTypes.MESSAGES_CHANGE,
      args: {
        destination: action.payload.destination,
        type: action.payload.type
      }
    };
  }
};

eventsMap[actionTypes.RECEIVE_DELIVERY_RECEIPT] = function (action) {
  return {
    type: eventTypes.MESSAGES_CHANGE,
    args: {
      destination: action.payload.destination,
      messageId: action.payload.messageId,
      type: action.payload.type
    }
  };
};

eventsMap[actionTypes.SET_IS_TYPING_FINISHED] = function (action) {
  return {
    type: eventTypes.IS_TYPING_LIST_CHANGE,
    args: {
      destination: action.payload.destination,
      sender: action.payload.senderAddress,
      type: action.payload.type
    }
  };
};

eventsMap[actionTypes.GET_IMAGE_LINKS_FINISH] = function (action) {
  return {
    type: eventTypes.MESSAGES_CHANGE,
    args: {
      destination: action.payload.destination,
      type: action.payload.type
    }
  };
};

exports.default = eventsMap;

/***/ }),

/***/ "./src/messaging/cpaas2/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/messaging/cpaas2/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/messaging/cpaas2/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

var _mixins = __webpack_require__("./src/messaging/cpaas2/interface/mixins.js");

var _mixins2 = _interopRequireDefault(_mixins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This interface is for a messaging plugin.
 * @type {string}
 */
const name = 'messaging'; // Import the components of the interface.
exports.default = {
  name,
  api: _api2.default,
  reducer: _reducers2.default,
  mixins: _mixins2.default
};

/***/ }),

/***/ "./src/messaging/cpaas2/interface/mixins.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __webpack_require__("../../node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _actions = __webpack_require__("./src/messaging/cpaas2/interface/actions/index.js");

var _selectors = __webpack_require__("./src/messaging/cpaas2/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _compose = __webpack_require__("../../node_modules/stampit/compose.js");

var _compose2 = _interopRequireDefault(_compose);

var _actions2 = __webpack_require__("./src/events/interface/actions.js");

var _eventTypes = __webpack_require__("./src/messaging/cpaas2/interface/eventTypes.js");

var _logs = __webpack_require__("./src/logs/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A Conversation object represents a conversation between either two users, or a
 * user and a group. A Conversation can create messages via the conversation's
 * createMessage() function.
 * @public
 * @module Conversation
 * @requires richMessagingWithoutLocation
 * @property {string} destination The Id of the remote user with which the current user is having a conversation.
 * @property {number} lastReceived The timestamp (milliseconds since epoch) of when a message was last received in this conversation.
 * @type {Object}
 */
// `features` and `lastPull` are not documented because they're intended to be internal
// `type` is not documented because as of now there are no types other than 'im'

/**
 * A Conversation object represents a conversation between either two users, or a
 * user and a group. A Conversation can create messages via the conversation's
 * createMessage() function.
 * @public
 * @module Conversation
 * @requires simpleMessagingOnly
 * @property {string} destination The id of the remote user with which the current user is having a conversation.
 * @type {Object}
 */

/**
 * A Message object represents an individual message. Messages have parts
 * which represent pieces of a message, such as a text part or a file part. Once
 * all the desired parts have been added, a message can be sent with the send()
 * function.
 * @public
 * @module Message
 * @type {Object}
 */

const log = (0, _logs.getLogManager)().getLogger('MESSAGING');

/**
 * Base conversation stamp
 * @param {Array} destination The Destination for messages being sent through
 * this conversation in this instance of the SDK. This should be an Array with any number of user IDs
 */

// Events
const conversationBase = {
  initializers: [function ({
    destination,
    type = 'chat',
    id = undefined,
    description = '',
    messages = [],
    isTypingList = [],
    lastReceived,
    lastPull
  }) {
    this.destination = destination;
    this.type = type;
    this.description = description;
    this.messages = messages;
    this.isTypingList = isTypingList;
    this.id = id;
    const features = (0, _selectors.getMessagingConfig)(this.context.getState()).features;
    if (this.destination.length === 1) {
      const groupIndex = features.indexOf('group');
      if (groupIndex > -1) {
        features.splice(groupIndex, 1);
      }
    }
    this.features = features;
    this.lastReceived = lastReceived;
    this.lastPull = lastPull;
    this.isPending = false;
  }],

  methods: {
    /**
     * Create and return a message object. You must specify the part. If this is a simple text message, provide a `text` part as demonstrated in the example.
     *
     * @public
     * @memberof Conversation
     * @requires richMessaging
     * @constructs Message
     * @param {Object} part The part to add to the message.
     * @param {string} part.type The type of part. Can be "text", "json", "file", or "location".
     * @param {string} [part.text] The text of the part. Must be a part of type "text".
     * @param {Object} [part.json] The json of the part. Must be a part of type "json".
     * @param {File} [part.file] The file of the part. Must be a part of type "file".
     * @param {Object} [part.location] The location of the part. Must be a part of type "location".
     * @param {number} [part.location.longitude] The longitude of the location.
     * @param {number} [part.location.latitude] The latitude of the location.
     * @returns {Object} The newly created Message object.
     *
     * @example
     * conversation.createMessage({type: 'text', text: 'This is the message'});
     */
    /**
     * Create and return a message object. You must specify the part. If this is a simple text message, provide a `text` part as demonstrated in the example.
     *
     * @public
     * @memberof Conversation
     * @requires richMessagingWithoutLocation
     * @constructs Message
     * @param {Object} part The part to add to the message.
     * @param {string} part.type The type of part. Can be "text", "json", "file".
     * @param {string} [part.text] The text of the part. Must be a part of type "text".
     * @param {Object} [part.json] The json of the part. Must be a part of type "json".
     * @param {File} [part.file] The file of the part. Must be a part of type "file".
     * @returns {Message} The newly created Message object.
     *
     * @example
     * conversation.createMessage({type: 'text', text: 'This is the message'});
     */
    /**
     * Create and return a message object. You must provide a `text` part as demonstrated in the example.
     *
     * @public
     * @memberof Conversation
     * @requires simpleMessagingOnly
     * @param {Object} part The part to add to the message.
     * @param {string} part.type The type of part. Must be "text" or "file"
     * @param {string} [part.text] The text of the part. Must be a part of type "text".
     * @returns {Message} The newly created Message object.
     *
     * @example
     * conversation.createMessage({type: 'text', text: 'This is the message'});
     */
    createMessage(part) {
      if (typeof part === 'string') {
        part = { type: 'text', text: part };
      }
      let parts = Array.isArray(part) ? part : [part];

      const messageContext = {
        features: this.features,
        isGroup: this.destination.length > 1,
        id: this.id,
        type: this.type
      };
      return this.context.primitives.Message({
        destination: this.destination,
        parts: parts,
        context: messageContext,
        type: this.type
      });
    },

    /**
     * Clears all messages in this conversation from local state.
     *
     * @public
     * @memberof Conversation
     * @method clearMessages
     */
    clearMessages() {
      this.context.dispatch(_actions.messageActions.clearMessages(this.destination, this.type));
    },

    /**
     * Get the messages associated with this conversation.
     *
     * @public
     * @memberof Conversation
     * @method getMessages
     * @return {Message[]} An array of messages.
     */
    getMessages: function () {
      const conversation = (0, _selectors.findConversation)(this.context.getState(), this.destination, this.type);

      return conversation.messages.map(message => {
        if (!message.parts) {
          log.debug('no message parts found on message, skipping message');
          return;
        }
        return this.getMessage(message.messageId);
      });
    },

    /**
     * Get a specific message from this conversation.
     *
     * @public
     * @method getMessage
     * @memberof Conversation
     * @param {string} messageId ID of the message to retrieve.
     * @return {Object} A message object.
     */
    getMessage(messageId) {
      const convo = (0, _selectors.findConversation)(this.context.getState(), this.destination, this.type);
      const message = (0, _fp.find)(message => message.messageId === messageId)(convo.messages);

      if (!message) {
        log.debug(`Message (${messageId}) not found in conversation (${this.destination}).`);
        return;
      }

      const { parts, sender, timestamp, isFetchingLinks } = message;
      const { type, features, destination, id } = this;
      let mixinMessage = this.context.primitives.Message({
        parts,
        sender,
        timestamp,
        isFetchingLinks,
        destination,
        type,
        messageId,
        context: {
          features,
          id,
          type,
          isGroup: destination.length > 1
        }
      });

      // TODO: Have these functions as proper mixin functions, instead of adding them manually afterwards.
      mixinMessage.forward = participant => {
        this.context.dispatch(_actions.messageActions.sendMessage(participant, mixinMessage.parts, Date.now(), this.type, this.id));
      };
      // Only allow the end user to markRead on message that were incoming.
      const userInfo = (0, _selectors2.getUserInfo)(this.context.getState());
      if (mixinMessage.sender !== userInfo.username) {
        // TODO: Have these functions as proper mixin functions, instead of adding them manually afterwards.
        mixinMessage.markRead = () => {
          this.context.dispatch(_actions.messageActions.sendMessageRead(mixinMessage.messageId, this.destination));
        };
      }
      return mixinMessage;
    },

    /**
     * Delete messages from this conversation. Provide an array of message IDs representing the messages for which the DELETE_MESSAGE action will be dispatched. If no message IDs are provided, all of the messages will be deleted.
     * @public
     * @memberof Conversation
     * @requires richMessaging
     * @method deleteMessages
     * @param {Array} messageIds An array of message IDs
     */
    deleteMessages: function (messageIds = []) {
      if (messageIds.length === 0) {
        // If this method was called without providing any specific message IDs, we will assume that all messages should be deleted
        this.messages.forEach(message => messageIds.push(message.messageId));
      }
      messageIds.forEach(messageId => {
        this.context.dispatch(_actions.messageActions.deleteMessage(this.destination, this.type, messageId));
      });
    },

    /**
     * Delete this conversation on the server
     *
     * @public
     * @memberof Conversation
     * @requires richMessaging
     * @method delete
     */
    delete: function () {
      this.context.dispatch(_actions.convoActions.deleteConversation(this.destination, this.type));
    },

    /**
     * Subscribe to this conversations messages array.
     *
     * @public
     * @memberof Conversation
     * @param {Function} subscriber A subscriber function to be triggered when the messages array of this conversation is updated.
     * @param {string} subscriber.conversationId The conversation participant.
     * @param {string} subscriber.messageId The ID of the message that caused the event.
     * @return {Function} The unsubscribe function.
     */
    subscribe: function (subscriber) {
      if (subscriber) {
        // Create a subscriber wrapper to properly determine if this messages:change event is relevant to this convo
        // TODO: we might need to change the name of `conversationId` as it is used here. Conversations have actual IDs in the backend, which are an integer value rather than an array of strings, as is the case with destination. We track conversation IDs, as they exist in the back end, as we are required to identify the conversation by `id` when performing actions in the backend on a Group Conversation.
        const subscriberWrapper = ({ conversationId, messageId }) => {
          if (conversationId === this.destination) {
            subscriber({ conversationId, messageId });
          }
        };
        // Subscribe to the messages:change event with the wrapped subscriber
        this.context.api.on('messages:change', subscriberWrapper);

        // Return the unsubscribe function
        return () => {
          this.context.api.off('messages:change', subscriberWrapper);
        };
      }
    }
  }

  /*
   * Conversation history stamp. Handles any functions that retrieve history from the server concerning conversations.
   */
};const conversationHistory = {
  initializers: [function () {
    const features = (0, _selectors.getMessagingConfig)(this.context.getState()).features;
    if (!(0, _fp.includes)('history', features)) {
      const prototype = (0, _getPrototypeOf2.default)(this);
      delete prototype.fetchMessages;
    }
    return this;
  }],
  methods: {
    /**
     * Allows the user to fetch messages associated with a specific conversation from the server.
     * When the operation is complete, a NEW_MESSAGE event will be emitted.
     * Messages can then be retrieved using getMessages.
     *
     * @public
     * @memberof Conversation
     * @method fetchMessages
     * @param {number} [amount=50] An amount of messages to fetch.
     */
    fetchMessages: function (amount = 50) {
      this.context.dispatch(_actions.messageActions.fetchMessages(this.destination, amount, this.type));
    }
  }
  /*
   * Conversation is Typing. Responsible for updating the state of who is idling or actively typing
   */
};const conversationIsTyping = {
  initializers: [function () {
    const features = (0, _selectors.getMessagingConfig)(this.context.getState()).features;
    if (!(0, _fp.includes)('isTyping', features)) {
      const prototype = (0, _getPrototypeOf2.default)(this);
      delete prototype.setIsTyping;
    }
    return this;
  }],
  methods: {
    /**
     * Sets the typing status of the conversation for the current user.
     * Other participants will be notified of changes to the conversation's typing status.
     * See the isTypingList:change event.
     *
     * @public
     * @requires isTyping
     * @memberof Conversation
     * @method setIsTyping
     * @param {boolean} isTyping Whether the user is typing or not
     */
    setIsTyping: function (isTyping) {
      const typingState = isTyping ? 'active' : 'idle';
      this.context.dispatch(_actions.convoActions.setIsTyping({ state: typingState, destination: this.destination }));
    }
  }

  /*
   * Base Message stamp
   * @param {string} destination The Destination for messages being sent through
   * this conversation in this instance of the SDK. This can be one or many users,
   * separated by commas `,`
   * @param  {Object} parts - Initial part to the message.
   * @param  {Object} context - Information and capabilities for how the message will act with regard to the conversation.
   * @param  {Array} context.features - List of features the conversation supports.
   * @param  {Function} context.send - Function for sending the message.
   * @param  {number} timestamp unix timestamp in seconds
   * @param  {boolean} isFetchingLinks
   * @param  {string} sender The author of the message
   * @param  {string} messageId a unique id for looking up the message
   * @param  {string} [type='chat'] - The type of the message
   */
};const messageBase = {
  initializers: [function ({ destination, parts, context, timestamp, isFetchingLinks, sender, messageId, type = 'chat' }) {
    this.destination = Array.isArray(destination) ? destination : [destination];
    this.convoContext = context;
    this.type = destination.length > 1 ? 'group' : type;
    this.messageId = messageId;
    this.sender = sender;
    this.timestamp = timestamp;
    this.isFetchingLinks = isFetchingLinks;
    this.parts = parts;
  }],
  methods: {
    /**
     * Sends the message.
     *
     * @public
     * @method send
     * @memberof Message
     */
    send() {
      log.debug('Send message', this);
      const dateInSeconds = Date.now() / 1000 | 0;
      this.context.dispatch(_actions.messageActions.sendMessage(this.destination, this.parts, dateInSeconds, this.type, this.convoContext.id));
    }
  }

  /**
   * stamp to add message parts capabilities to a Message primitive
   * @name withParts
   * @param  {Object} context - Information and capabilities for how the message will act with regard to the conversation.
   * @param  {Array} context.features - List of features the conversation supports.
   */
};const withParts = {
  initializers: [function ({ context: { features = [] } }) {
    if (!(0, _fp.includes)('parts', features)) {
      const prototype = (0, _getPrototypeOf2.default)(this);
      delete prototype.addPart;
    }
    return this;
  }],
  methods: {
    /**
     * Add an additional part to a message.
     *
     * @public
     * @memberof Message
     * @requires richMessaging
     * @memberof withParts
     * @param {Object} part The part to add to the message.
     * @param {string} part.type The type of part. Can be "text", "json", "file", or "location".
     * @param {string} [part.text] The text of the part. Must be a part of type "text".
     * @param {Object} [part.json] The json of the part. Must be a part of type "json".
     * @param {File} [part.file] The file of the part. Must be a part of type "file".
     * @param {Object} [part.location] The location of the part. Must be a part of type "location".
     * @param {number} [part.location.longitude] The longitude of the location.
     * @param {number} [part.location.latitude] The latitude of the location.
     */

    /**
     * Add an additional part to a message.
     *
     * @public
     * @memberof Message
     * @requires richMessagingWithoutLocation
     * @param {Object} part The part to add to the message.
     * @param {string} part.type The type of part. Can be "text", "json", "file", or "location".
     * @param {string} [part.text] The text of the part. Must be a part of type "text".
     * @param {Object} [part.json] The json of the part. Must be a part of type "json".
     * @param {File} [part.file] The file of the part. Must be a part of type "file".
     */
    addPart(part) {
      // Validate the part. If not valid, returns an error.
      const validationResponse = validatePart(part, this.convoContext.features);
      if (validationResponse instanceof Error) {
        this.context.dispatch((0, _actions2.emitEvent)(_eventTypes.MESSAGING_ERROR, { error: validationResponse.message }));
      }
      this.parts.push(part);
    }
  }

  /**
   * stamp to allow creation of multimedia links
   * @name multimediaLinks
   * @param  {Object} context - Information and capabilities for how the message will act with regard to the conversation.
   * @param  {Array} context.features - List of features the conversation supports.
   */
};const multimediaLinks = {
  initializers: [function ({ context: { features = [] } }) {
    if (!(0, _fp.includes)('rich', features)) {
      const prototype = (0, _getPrototypeOf2.default)(this);
      delete prototype.createImageLinks;
    }
    return this;
  }],
  methods: {
    /**
     * Creates a usable link for the given message
     *
     * @public
     * @memberof Message
     * @requires rich
     */
    createImageLinks() {
      const { parts, destination, type, messageId } = this;
      this.context.dispatch(_actions.messageActions.getImageLinks({ parts, destination, type, messageId }));
    }
  }

  /*
   * A helper function to validate inputs. Will be progressively updated as we
   * allow for more and more input types.
   */
};let validatePart = function (part, features) {
  if (part.hasOwnProperty('type')) {
    let validTypeFlag = false;
    switch (part.type) {
      case 'text':
        validTypeFlag = true;
        break;
      case 'file':
        validTypeFlag = features.indexOf('rich') !== -1;
        break;
      case 'location':
        validTypeFlag = features.indexOf('rich') !== -1;
        break;
      case 'json':
        validTypeFlag = features.indexOf('rich') !== -1;
    }
    return validTypeFlag || new Error(`Part of type "${part.type}" is not supported`);
  } else {
    return new Error('A message part must have a type. Options are: [text, file, location, json]');
  }
};

exports.default = {
  Conversation: (0, _compose2.default)(conversationBase, conversationHistory, conversationIsTyping),
  Message: (0, _compose2.default)(messageBase, withParts, multimediaLinks)
};

/***/ }),

/***/ "./src/messaging/cpaas2/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/messaging/cpaas2/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

reducers[actionTypes.CREATE_CONVERSATION] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: [...state.conversations, (0, _extends3.default)({}, action.payload)]
    });
  }
};

reducers[actionTypes.FETCH_CONVERSATIONS_FINISHED] = {
  next(state, action) {
    // TODO: does not persist conversations unique to local state
    return (0, _extends3.default)({}, state, {
      conversations: (0, _fp.unionWith)((a, b) => (0, _fp.isEqual)(a.destination, b.destination) && a.type === b.type, // Comparator
      action.payload.conversations, state.conversations // Conversation arrays
      )
    });
  }
};

reducers[actionTypes.UPDATE_CONVERSATION] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, action.payload);
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.FETCH_MESSAGES] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            isPending: true
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.FETCH_MESSAGES_FINISHED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: (0, _fp.sortBy)('timestamp', (0, _fp.unionBy)('messageId', action.payload.messages, conversation.messages)),
            isTypingList: [],
            isPending: false
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.SEND_MESSAGE] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.message.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: [...conversation.messages, action.payload.message]
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.INCOMING_MESSAGE_READ] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.map(message => {
              if (message.messageId === action.payload.messageId) {
                return (0, _extends3.default)({}, message, { read: true });
              }
              return message;
            })
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.SEND_MESSAGE_READ_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.map(message => {
              if (message.messageId === action.payload.messageId) {
                return (0, _extends3.default)({}, message, { read: true });
              }
              return message;
            })
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.MESSAGE_RECEIVED] = {
  next(state, action) {
    if (action.meta.newConversation) {
      return (0, _extends3.default)({}, state, {
        conversations: [...state.conversations, {
          destination: action.payload.destination,
          messages: [action.payload.message],
          type: action.meta.type,
          lastReceived: action.payload.message.timestamp
        }]
      });
    } else {
      return (0, _extends3.default)({}, state, {
        conversations: state.conversations.map(conversation => {
          if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.meta.type) {
            return (0, _extends3.default)({}, conversation, {
              messages: [...conversation.messages, action.payload.message],
              lastReceived: action.payload.message.timestamp
            });
          }
          return conversation;
        })
      });
    }
  }
};

reducers[actionTypes.SEND_MESSAGE_FINISH] = (state, action) => {
  return (0, _extends3.default)({}, state, {
    conversations: state.conversations.map(conversation => {
      if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
        return (0, _extends3.default)({}, conversation, {
          messages: conversation.messages.map(message => sendMessageFinishHelper(message, action))
        });
      }
      return conversation;
    })
  });
};

// Remove all messages from the specified conversation.
reducers[actionTypes.CLEAR_MESSAGES] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: []
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.DELETE_MESSAGE_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.filter(message => message.messageId !== action.payload.messageId)
          });
        }
        return conversation;
      })
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.DELETE_CONVERSATION_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.filter(conversation => !((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type))
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.RECEIVE_DELIVERY_RECEIPT] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.map(message => {
              if (message.messageId === action.payload.messageId) {
                return (0, _extends3.default)({}, message, {
                  deliveryStatus: action.payload.deliveryStatus
                });
              }
              return message;
            })
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.SET_IS_TYPING_FINISHED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          let isTypingList = [...conversation.isTypingList];
          if (action.payload.state === 'active') {
            if (!conversation.isTypingList.includes(action.payload.senderAddress)) {
              isTypingList = conversation.isTypingList.concat([action.payload.senderAddress]);
            }
          } else if (action.payload.state === 'idle') {
            if (conversation.isTypingList.includes(action.payload.senderAddress)) {
              isTypingList = conversation.isTypingList.filter(username => action.payload.senderAddress !== username);
            }
          }
          return (0, _extends3.default)({}, conversation, {
            isTypingList
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.GET_IMAGE_LINKS] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.map(message => {
              // iterate over messages find ours using messageId
              if ((0, _fp.isEqual)(message.messageId, action.payload.messageId)) {
                return (0, _extends3.default)({}, message, {
                  isFetchingLinks: true
                });
              }
              return message;
            })
          });
        }
        return conversation;
      })
    });
  }
};

reducers[actionTypes.GET_IMAGE_LINKS_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      conversations: state.conversations.map(conversation => {
        if ((0, _fp.isEqual)(conversation.destination, action.payload.destination) && conversation.type === action.payload.type) {
          return (0, _extends3.default)({}, conversation, {
            messages: conversation.messages.map(message => {
              // iterate over messages find ours using messageId
              if ((0, _fp.isEqual)(message.messageId, action.payload.messageId)) {
                return (0, _extends3.default)({}, message, {
                  isFetchingLinks: false,
                  parts: message.parts.map(part => {
                    // iterate over message parts and find ours using oldURL
                    if ((0, _fp.isEqual)(part.rawURL, action.payload.rawURL)) {
                      return (0, _extends3.default)({}, part, {
                        url: action.payload.url
                      });
                    }
                    return part;
                  })
                });
              }
              return message;
            })
          });
        }
        return conversation;
      })
    });
  }
};

/*
 * Combine all of reducers into a single reducer, with
 *      a default state of an empty array.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, { conversations: [], errors: [] });
exports.default = reducer;

/**
 * sendMessageFinishHelper
 *
 * A helper function to make dealing with the messages array in SEND_MESSAGE_FINISH
 * a little bit easier.
 *
 * @param {Object} message
 * @param {Object} action
 */

function sendMessageFinishHelper(message, action) {
  if (message.timestamp === action.payload.timestamp) {
    if (action.payload.error) {
      message = (0, _extends3.default)({}, message, {
        sender: action.payload.sender,
        isPending: false,
        messageId: null,
        error: action.payload.error
      });
    } else {
      message = (0, _extends3.default)({}, message, {
        sender: action.payload.sender,
        isPending: false,
        messageId: action.payload.messageId,
        parts: action.payload.parts
      });
    }
    if (action.payload.deliveryStatus) {
      message.deliveryStatus = action.payload.deliveryStatus;
    }
  } else {
    message = (0, _extends3.default)({}, message);
  }
  return message;
}

/***/ }),

/***/ "./src/messaging/cpaas2/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMessagingConfig = getMessagingConfig;
exports.getConversations = getConversations;
exports.getMessages = getMessages;
exports.findConversation = findConversation;
exports.findMember = findMember;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/*
 * Redux-saga selector functions.
 * Used with the `select` effect in sagas to retrieve
 *      specific portions of the state.
 */

/**
 * Retrieves the config options provided by the messaging plugin.
 * @method getMessagingConfig
 * @return {Object}
 */
function getMessagingConfig(state) {
  return (0, _fp.cloneDeep)(state.config.messaging);
}

/**
 * Retrieves conversations from the store pertaining to messaging.
 * @method getConversations
 * @return {Object}
 */
function getConversations(state) {
  return (0, _fp.cloneDeep)(state.messaging.conversations);
}

/**
 * Retrieves the messages from the store pertaining to a specific messaging
 * conversation.
 * @method getMessages
 * @return {Object}
 */
function getMessages(state, conversationId) {
  return (0, _fp.cloneDeep)(state.messaging.conversations[conversationId].messages);
}

/**
 * Searches for a conversation by its destination, which represents the destination
 * for all messages being sent to this conversation from this instance of the SDK
 *
 * @param state
 * @param {Array} destination A subscriber handle or a comma-separated list
 * of subscriber handles
 * @param {string} type The type of conversation: can be one of 'im', 'sms' or 'group'
 * @returns {Object}
 */
function findConversation(state, destination, type = 'im') {
  return (0, _fp.cloneDeep)(state.messaging.conversations.find(conversation => {
    return (0, _fp.isEqual)(conversation.destination, destination) && conversation.type === type;
  }));
}

/**
 * Searches for a member in a conversation and returns their name
 *
 * @param state
 * @param {string} destination A subscriber handle or a comma-separated list
 * of subscriber handles
 * @param id {number} User ID for the specific conversation member for whom we are searching
 * @returns {*}
 */
function findMember(state, destination, id) {
  const conv = state.messaging.conversations.find(conversation => conversation.destination === destination);
  if (conv) {
    return (0, _fp.cloneDeep)(conv.members.find(member => member.id === id));
  }
}

/***/ }),

/***/ "./src/messaging/cpaas2/requests.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.setIsTypingRequest = setIsTypingRequest;
exports.uploadFile = uploadFile;
exports.sendChatMessageRequest = sendChatMessageRequest;
exports.chatSubscribe = chatSubscribe;
exports.chatUnsubscribe = chatUnsubscribe;
exports.sendSMSRequest = sendSMSRequest;
exports.smsInboundSubscribe = smsInboundSubscribe;
exports.smsInboundUnsubscribe = smsInboundUnsubscribe;
exports.smsOutboundSubscribe = smsOutboundSubscribe;
exports.smsOutboundUnsubscribe = smsOutboundUnsubscribe;
exports.chatFetchConversations = chatFetchConversations;
exports.chatFetchMessages = chatFetchMessages;
exports.fetchImageLinks = fetchImageLinks;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Maps values from a nested object structure to a single object for easy use
 * assumes that each object in the list has a name and value property
 * @method _marshalData
 * @param {Array<Object>} attributes an list of objects with attributes
 * @return {Object} a remapped object that is easier to work with
 */


// Libraries.
// Helpers.
function _marshalData(attributes) {
  return attributes.reduce((accum, current, index) => {
    accum[current.name] = attributes[index].value;
    return accum;
  }, {});
}

/**
 * Makes a REST request to notify other users that the user is typing
 * @method setIsTypingRequest
 * @param {Object} requestInfo
 * @param {string} destination to send the notification to
 * @param {string} state (idle/active) the state of the user typing
 * @param {string} [refresh='60'] a string integer representing in seconds how long before the server refreshes the state
 * @returns {Object}
 */
function* setIsTypingRequest(requestInfo, destination, state, refresh = '60') {
  const requestOptions = {
    url: `${requestInfo.baseURL}/cpaas/chat/v1/${requestInfo.username}/oneToOne/${destination}/adhoc/messages`,
    method: 'POST',
    body: (0, _stringify2.default)({
      isComposing: {
        contenttype: 'text/plain',
        refresh: refresh,
        state: state,
        lastactive: Date.now()
      }
    })
  };
  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.SET_IS_TYPING_FAIL,
        message: 'setIsTypingRequest has failed'
      })
    };
  } else {
    return (0, _extends3.default)({}, response.payload.body.isComposing, {
      error: false
    });
  }
}

/**
 * Makes a REST request to a file upload API, storing images for use later
 * @method uploadFile
 * @param {Object} requestInfo data used to make the request
 * @param {Object} file contains file data to be uploaded
 */
function* uploadFile(requestInfo, file) {
  const formData = new FormData();
  const reqInfo = (0, _fp.cloneDeep)(requestInfo);

  const placeholderData = {
    object: {
      attributes: { attribute: [] },
      flags: { flag: [] }
    }
  };
  formData.append('root-fields', (0, _stringify2.default)(placeholderData));
  formData.append('raw', file, file.name);
  const requestOptions = {
    url: `${reqInfo.baseURL}/cpaas/nms/v1/chat/${reqInfo.username}/objects`,
    body: formData,
    method: 'POST'

    // FormData autopopulates Content-Type with a unique Boundry
    // we need to make sure that don't have one when we make the request
    // request merges requestInfo and request options so delete it
  };delete reqInfo.options.headers['Content-Type']; // Needed to prevent request helper from assuming request is application/json
  const response = yield (0, _effects2.default)(requestOptions, reqInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.FILE_UPLOAD_FAIL,
        message: 'Failed to upload file'
      })
    };
  } else {
    const responseData = _marshalData(response.payload.body.object.attributes.attribute);
    return {
      attachment: responseData,
      error: false
    };
  }
}

/**
 * Used to send Simple Chat messages
 * sends a chat message to another user (can include attachments)
 * @method sendChatMessageRequest
 * @param {Object} requestInfo
 * @param {Object} payload
 * @param {Object} payload.destination a target destination for the message
 * @param {Object} payload.textParts text parts of the message
 * @param {Object} payload.fileParts parts of the message required for sending files
 * @returns {Object}
 */
function* sendChatMessageRequest(requestInfo, destination, textParts, fileParts) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/chat/${requestInfo.version}/${requestInfo.username}/oneToOne/${destination}/adhoc/messages`,
    body: (0, _stringify2.default)({
      chatMessage: {
        text: textParts,
        attachment: fileParts
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    // Request error.
    _loglevel2.default.debug('Failed to send Chat Message.', response.error);
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.SEND_MESSAGE_FAIL,
        message: 'Failed to send Chat Message.'
      })
    };
  } else if (response.payload.requestError) {
    // Server error.
    _loglevel2.default.debug('Failed to send Chat Message.', response.payload.requestError);
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.SEND_MESSAGE_FAIL,
        message: 'Failed to send Chat Message.'
      })
    };
  } else {
    // Success scenario.
    return (0, _extends3.default)({}, response.payload.body.chatMessage, {
      error: false
    });
  }
}

/**
 * Performs a REST request for a chat subscription.
 * @method chatSubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} channel
 * @return {Object}
 */
function* chatSubscribe(requestInfo, channel) {
  const requestOptions = {};
  requestOptions.method = 'POST';
  requestOptions.url = `${requestInfo.baseURL}/cpaas/chat/${requestInfo.version}/${requestInfo.username}/subscriptions`;

  requestOptions.body = (0, _stringify2.default)({
    chatNotificationSubscription: {
      callbackReference: {
        notifyURL: channel.callbackURL
      },
      clientCorrelator: requestInfo.clientCorrelator
    }
  });

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to subscribe for chat notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      error: false,
      subscription: response.payload.body.chatNotificationSubscription
    };
  }
}

/**
 * Performs a REST request for a chat unsubscription.
 * @method chatUnsubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} subInfo Info about the subscription being ..unsubscribed.
 * @return {Object}
 */
function* chatUnsubscribe(requestInfo, subInfo) {
  const requestOptions = {};
  requestOptions.method = 'DELETE';

  requestOptions.url = `${requestInfo.baseURL}/cpaas/` + `chat/${requestInfo.version}/${requestInfo.username}/` + `subscriptions/${subInfo.subscriptionId}`;

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to unsubscribe from chat notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_UNSUB_FAIL
      })
    };
  } else {
    return {
      error: false
    };
  }
}

/**
 * Makes a REST request to the 'Send SMS' CPaaS 2.0 endpoint.
 * @method sendSMSRequest
 * @param  {Object} connection Information needed for the request.
 * @param  {Object} payload Information needed for the SMS.
 * @return {Object} Formatted response object.
 */
function* sendSMSRequest(requestInfo, destination, message) {
  let requestOptions = {};
  requestOptions.method = 'POST';

  requestOptions.url = `${requestInfo.baseURL}` + `/cpaas/smsmessaging/v1/${requestInfo.username}` + `/outbound/${requestInfo.senderAddress}/requests`;

  requestOptions.body = (0, _stringify2.default)({
    outboundSMSMessageRequest: {
      address: [destination],
      clientCorrelator: requestInfo.clientCorrelator,
      outboundSMSTextMessage: {
        message: message
      }
    }
  });

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    // Request error.
    _loglevel2.default.debug('Failed to send SMS message.', response.error);
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.SEND_MESSAGE_FAIL,
        message: 'Failed to send SMS message.'
      })
    };
  } else if (response.payload.error) {
    // Server error.
    _loglevel2.default.debug('Failed to send SMS message.', response.payload.error);
    return {
      error: new _errors2.default({
        code: _errors.messagingCodes.SEND_MESSAGE_FAIL,
        message: 'Failed to send SMS message.'
      })
    };
  } else {
    // Success scenario.
    return (0, _extends3.default)({}, response.payload.body.outboundSMSMessageRequest, {
      error: false
    });
  }
}

/**
 * Performs a REST request for inbound SMS subscription.
 * @method smsInboundSubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} channelInfo
 * @return {Object}
 */
function* smsInboundSubscribe(requestInfo, channelInfo) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/` + `smsmessaging/${requestInfo.version}/${requestInfo.username}/` + `inbound/subscriptions`,
    body: (0, _stringify2.default)({
      subscription: {
        callbackReference: {
          notifyURL: channelInfo.callbackURL
        },
        clientCorrelator: requestInfo.clientCorrelator,

        // TODO: Shouldn't this be sender address?
        destinationAddress: requestInfo.destinationAddress
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to subscribe for inbound SMS notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      error: false,
      subscription: response.payload.body.subscription
    };
  }
}

/**
 * Performs a REST request for a inbound SMS unsubscription.
 * @method smsInboundUnsubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} subInfo Info about the subscription being ..unsubscribed.
 * @return {Object}
 */
function* smsInboundUnsubscribe(requestInfo, subInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/` + `smsmessaging/${requestInfo.version}/${requestInfo.username}/` + `inbound/subscriptions/${subInfo.subscriptionId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to unsubscribe from inbound SMS notifications.',
        code: _errors.subscriptionCodes.CPAAS2CPAAS2_SERVICE_UNSUB_FAIL
      })
    };
  } else {
    return {
      error: false
    };
  }
}

/**
 * Performs a REST request for outbound SMS subscription.
 * @method smsOutboundSubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} channelInfo
 * @return {Object}
 */
function* smsOutboundSubscribe(requestInfo, channelInfo) {
  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/` + `smsmessaging/${requestInfo.version}/${requestInfo.username}/` + `outbound/${requestInfo.username}/subscriptions`,
    body: (0, _stringify2.default)({
      deliveryReceiptSubscription: {
        callbackReference: {
          notifyURL: channelInfo.callbackURL
        },
        clientCorrelator: requestInfo.clientCorrelator
      }
    })
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to subscribe for outbound SMS notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      error: false,
      subscription: response.payload.body.deliveryReceiptSubscription
    };
  }
}

/**
 * Performs a REST request for a outbound SMS unsubscription.
 * @method smsOutboundUnsubscribe
 * @param  {Object} requestInfo Info needed to perform the request.
 * @param  {Object} subInfo Info about the subscription being ..unsubscribed.
 * @return {Object}
 */
function* smsOutboundUnsubscribe(requestInfo, subInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/` + `smsmessaging/${requestInfo.version}/${requestInfo.username}/` + `outbound/${requestInfo.username}/subscriptions/${subInfo.subscriptionId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to unsubscribe from outbound SMS notifications.',
        code: _errors.subscriptionCodes.CPAAS2_SERVICE_SUB_FAIL
      })
    };
  } else {
    return {
      error: false
    };
  }
}

/**
 * Performs a REST request to fetch a list of chat sessions
 * @method chatFetchConversations
 * @param {Object} requestInfo
 * @return {Object} a list of chat sessions
 */
function* chatFetchConversations(requestInfo) {
  const requestOptions = {
    method: 'GET',
    url: `${requestInfo.baseURL}/cpaas/chat/v1/${requestInfo.username}/oneToOne`
  };
  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);
  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to fetch conversations.',
        code: _errors.messagingCodes.FETCH_CONVERSATIONS_FAIL
      })
    };
  } else {
    return (0, _extends3.default)({}, response.payload.body.chatSessionList, {
      error: false
    });
  }
}

/**
 * Performs a REST request to fetch a list of messages for a particular conversation
 * @method chatFetchMessages
 * @param {Object} requestInfo
 * @param {Object} destination a target to send the message to
 * @return {Object}
 */
function* chatFetchMessages(requestInfo, destination) {
  const requestOptions = {
    method: 'GET',
    url: `${requestInfo.baseURL}/cpaas/chat/v1/${requestInfo.username}/oneToOne/${destination}/adhoc/messages`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);
  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to fetch chat messages.',
        code: _errors.subscriptionCodes.FETCH_MESSAGES_FAIL
      })
    };
  } else {
    return (0, _extends3.default)({}, response.payload.body.chatMessageList, {
      error: false
    });
  }
}

/**
 * Used to fetch links for images with authentication,
 * url is passed as a parameter because it is a unique url
 * returned via the uploadFile API
 * @method fetchImageLinks
 * @param {Object} requestInfo
 * @param {string} url where we get the image blob
 * @return {Object}
 */
function* fetchImageLinks(requestInfo, url) {
  const response = yield (0, _effects2.default)({ url, method: 'GET', responseType: 'blob' }, requestInfo.options);

  if (response.error) {
    return {
      error: new _errors2.default({
        message: 'Failed to fetch image link.',
        code: _errors.messagingCodes.FETCH_IMAGE_LINKS_FAIL
      })
    };
  } else {
    return {
      blob: response.payload.body,
      error: false
    };
  }
}

/***/ }),

/***/ "./src/messaging/cpaas2/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerChat = registerChat;
exports.registerInboundSMS = registerInboundSMS;
exports.registerOutboundSMS = registerOutboundSMS;
exports.sendChatMessage = sendChatMessage;
exports.receiveChatMessageNotification = receiveChatMessageNotification;
exports.sendSMS = sendSMS;
exports.receiveSMS = receiveSMS;
exports.receiveDeliveryReceipt = receiveDeliveryReceipt;
exports.fetchChatConversations = fetchChatConversations;
exports.fetchChatMessages = fetchChatMessages;
exports.setIsTyping = setIsTyping;
exports.receiveIsTypingNotification = receiveIsTypingNotification;
exports.getImageLinks = getImageLinks;

var _messaging = __webpack_require__("./src/messaging/cpaas2/sagas/messaging.js");

var messagingSagas = _interopRequireWildcard(_messaging);

var _subscriptions = __webpack_require__("./src/messaging/cpaas2/sagas/subscriptions.js");

var subsSagas = _interopRequireWildcard(_subscriptions);

var _actionTypes = __webpack_require__("./src/messaging/cpaas2/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actionTypes2 = __webpack_require__("./src/notifications/interface/actionTypes.js");

var _constants = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("./src/subscription/interface/effects.js");

var _effects2 = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Register For Services
 */

/**
 * Saga to register the chat service with the subscription plugin.
 * Runs immediately.
 * @method registerChat
 */


// Libraries.
function* registerChat() {
  yield (0, _effects.registerService)('chat', subsSagas.chatSubscription, subsSagas.chatUnsubscription);
}

/**
 * Saga to register the SMS service with the subscription plugin.
 * Runs immediately.
 * @method registerInboundSMS
 */
function* registerInboundSMS() {
  yield (0, _effects.registerService)('smsinbound', subsSagas.smsInboundSubscription, subsSagas.smsInboundUnsubscription);
}

/**
 * Saga to register the SMS service with the subscription plugin.
 * Runs immediately.
 * @method registerOutboundSMS
 */
function* registerOutboundSMS() {
  yield (0, _effects.registerService)('smsoutbound', subsSagas.smsOutboundSubscription, subsSagas.smsOutboundUnsubscription);
}

/**
 * Chat Operations
 */

/**
 * Send an outgoing Simple Chat Message
 * @method sendChatMessage
 */
function* sendChatMessage() {
  function sendChatPattern(action) {
    return action.type === actionTypes.SEND_MESSAGE && action.payload.message.type === 'chat';
  }

  yield (0, _effects2.takeEvery)(sendChatPattern, messagingSagas.sendChatMessage);
}

/**
 * Handle an incoming Simple Chat Message
 * @method receiveChatMessage
 */
function* receiveChatMessageNotification() {
  function incomingChatMessagePattern(action) {
    return action.type === _actionTypes2.NOTIFICATION_RECEIVED && action.payload.chatMessageNotification && action.payload.chatMessageNotification.chatMessage && action.payload.chatMessageNotification.chatMessage['x-type'] === 'inbound';
  }

  yield (0, _effects2.takeEvery)(incomingChatMessagePattern, messagingSagas.handleChatMessageNotification);
}

/**
 * SMS Operations
 */

/**
 * Waits for SMS send message actions and triggers sendSMS saga
 * @method sendSMS
 */
function* sendSMS() {
  function sendSMSPattern(action) {
    return action.type === actionTypes.SEND_MESSAGE && action.payload.message.type === 'sms';
  }

  yield (0, _effects2.takeEvery)(sendSMSPattern, messagingSagas.sendSMS);
}

/**
 * Waits for incoming SMS notification actions and triggers handleIncomingSMS saga
 * @method receiveSMS
 */
function* receiveSMS() {
  // Redux-saga take() pattern.
  function incomingSMSPattern(action) {
    return action.type === _actionTypes2.NOTIFICATION_RECEIVED && action.payload.inboundSMSMessageNotification;
  }

  yield (0, _effects2.takeEvery)(incomingSMSPattern, messagingSagas.handleIncomingSMS);
}

/**
 * Waits for delivery receipts notification actions and triggers handleDeliveryReceipts saga
 * @method receiveDeliveryReceipt
 */
function* receiveDeliveryReceipt() {
  function deliveryReceiptPattern(action) {
    return action.type === _actionTypes2.NOTIFICATION_RECEIVED && action.meta.platform === _constants.platforms.CPAAS2 && (0, _fp.has)('payload.deliveryInfoNotification.deliveryInfo.deliveryStatus', action);
  }

  yield (0, _effects2.takeEvery)(deliveryReceiptPattern, messagingSagas.handleDeliveryReceipts);
}

/**
 * Waits for fetch conversation actions and triggers fetchChatConversations saga
 * @method fetchChatConversations
 */
function* fetchChatConversations() {
  function fetchConversationPattern(action) {
    return action.type === actionTypes.FETCH_CONVERSATIONS;
  }
  yield (0, _effects2.takeEvery)(fetchConversationPattern, messagingSagas.fetchChatConversations);
}

/**
 * Waits for fetch message actions and triggers fetchChatMessages saga
 * @method fetchChatMessages
 */
function* fetchChatMessages() {
  function fetchConversationPattern(action) {
    return action.type === actionTypes.FETCH_MESSAGES;
  }
  yield (0, _effects2.takeEvery)(fetchConversationPattern, messagingSagas.fetchChatMessages);
}

/**
 * Waits for isTyping notifications and triggers up[dateIsTyping saga
 * @method setIsTyping
 */
function* setIsTyping() {
  function isTypingPattern(action) {
    return action.type === actionTypes.SET_IS_TYPING;
  }
  yield (0, _effects2.takeEvery)(isTypingPattern, messagingSagas.setIsTyping);
}

/**
 * Waits for isTyping notifications and triggers up[dateIsTyping saga
 * @method receiveIsTypingNotification
 */
function* receiveIsTypingNotification() {
  function isTypingPattern(action) {
    return action.type === _actionTypes2.NOTIFICATION_RECEIVED && (0, _fp.has)('payload.chatMessageNotification.isComposing', action) && (0, _fp.get)('payload.chatMessageNotification.isComposing["x-type"]', action) === 'inbound';
  }
  yield (0, _effects2.takeEvery)(isTypingPattern, messagingSagas.receiveIsTypingNotification);
}

/**
 * Waits for get image links notifications and triggers getImageLinks saga
 * @method getImageLinks
 */
function* getImageLinks() {
  function getImageLinksPattern(action) {
    return action.type === actionTypes.GET_IMAGE_LINKS;
  }
  yield (0, _effects2.takeEvery)(getImageLinksPattern, messagingSagas.getImageLinks);
}

/***/ }),

/***/ "./src/messaging/cpaas2/sagas/messaging.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.receiveIsTypingNotification = receiveIsTypingNotification;
exports.setIsTyping = setIsTyping;
exports.sendChatMessage = sendChatMessage;
exports.handleChatMessageNotification = handleChatMessageNotification;
exports.handleDeliveryReceipts = handleDeliveryReceipts;
exports.sendSMS = sendSMS;
exports.handleIncomingSMS = handleIncomingSMS;
exports.fetchChatConversations = fetchChatConversations;
exports.fetchChatMessages = fetchChatMessages;
exports.getImageLinks = getImageLinks;

var _actions = __webpack_require__("./src/messaging/cpaas2/interface/actions/index.js");

var _requests = __webpack_require__("./src/messaging/cpaas2/requests.js");

var _selectors = __webpack_require__("./src/messaging/cpaas2/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _constants = __webpack_require__("./src/constants.js");

var _mappings = __webpack_require__("./src/messaging/mappings.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Logging


// Other plugins.
const log = (0, _logs.getLogManager)().getLogger('MESSAGING');

/**
 * Handles isTypingNotifications and sets isTypingList in redux state
 * @method receiveIsTypingNotification
 * @param {Object} action
 */


// Libraries.
// Messaging plugin.
function* receiveIsTypingNotification(action) {
  const { state, senderAddress } = action.payload.chatMessageNotification.isComposing;

  yield (0, _effects.put)(_actions.convoActions.setIsTypingFinished({
    state,
    senderAddress: senderAddress,
    destination: [senderAddress],
    type: 'chat'
  }));
}

/**
 * Sets the typing status of the current user in redux state
 * @method setIsTyping
 * @param {Object} action
 */
function* setIsTyping(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const response = yield (0, _effects.call)(_requests.setIsTypingRequest, requestInfo, action.payload.destination, action.payload.state);
  const { state, senderAddress, 'x-destinationAddress': destination, error } = response;

  if (error) {
    yield (0, _effects.put)(_actions.convoActions.setIsTypingFinished({
      error: error
    }));
  } else {
    yield (0, _effects.put)(_actions.convoActions.setIsTypingFinished({
      state,
      senderAddress: senderAddress,
      destination: [destination],
      type: 'chat'
    }));
  }
}

/**
 * Sends chat messages via POST request
 * @method sendChatMessage
 * @param  {Object} action A `SEND_MESSAGE` action
 */
function* sendChatMessage(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);

  let chatResponse;

  let textParts = [];
  let fileParts = [];
  action.payload.message.parts.forEach(part => {
    if (part.type === 'text') {
      textParts = textParts.concat([part]);
    } else if (part.type === 'file') {
      fileParts = fileParts.concat([part]);
    } else {
      log.info('Unknown part type' + part.type);
    }
  });

  // TODO: when the backend API expands its functionality this log/error should be removed
  if (fileParts.length > 1) {
    log.info('Too many fileParts to upload, API  doesnt currently support multiple fileParts.');
    yield (0, _effects.put)(_actions.messageActions.sendMessageFinish({
      error: new _errors2.default({
        message: 'Too many fileParts to upload, API  doesnt currently support multiple fileParts.',
        code: _errors.messagingCodes.INVALID_FILE_PARTS
      })
    }));
  }

  let attachmentParts = [];
  if (fileParts.length > 0) {
    const uploadResponseList = yield (0, _effects.all)(fileParts.map(filePart => (0, _effects.call)(_requests.uploadFile, requestInfo, filePart.file)));

    attachmentParts = uploadResponseList.map(response => {
      return (0, _extends3.default)({}, response.attachment, { type: 'file', rawURL: response.attachment.link });
    });
    // multimedia messaging requires a specific format for each uploaded file
    const chatMediaParts = attachmentParts.map(part => {
      return { name: part.name, 'x-id': part['x-id'] };
    });

    chatResponse = yield (0, _effects.call)(_requests.sendChatMessageRequest, requestInfo, action.payload.destination[0], textParts[0].text, chatMediaParts);
  } else {
    // hardcoding textParts because API only allows sending one text part
    chatResponse = yield (0, _effects.call)(_requests.sendChatMessageRequest, requestInfo, action.payload.destination[0], textParts[0].text);
  }
  const allParts = textParts.concat(attachmentParts);
  let finishInfo = {
    type: 'chat',
    destination: action.payload.destination,
    sender: chatResponse.senderAddress,
    deliveryStatus: chatResponse.status,
    parts: allParts,
    timestamp: action.payload.message.timestamp
  };

  if (chatResponse.error) {
    yield (0, _effects.put)(_actions.messageActions.sendMessageFinish((0, _extends3.default)({}, finishInfo, {
      error: chatResponse.error
    })));
  } else {
    const messageId = chatResponse.resourceURL.split('/messages/')[1];
    yield (0, _effects.put)(_actions.messageActions.sendMessageFinish((0, _extends3.default)({}, finishInfo, {
      messageId
    })));
  }
}

/**
 * Handles incoming chat message notifications
 * @method handleChatMessageNotification
 * @param  {Object} action A `NOTIFICATION_RECEIVED` action representing a deliveryReceipt.
 */
function* handleChatMessageNotification(action) {
  const { dateTime, senderAddress, text, attachment } = action.payload.chatMessageNotification.chatMessage;
  // Grab the messageId from the end of link.href
  const messageId = action.payload.chatMessageNotification.link[0].href.split('/messages/')[1];

  const existingConversation = yield (0, _effects.select)(_selectors.findConversation, [senderAddress], 'chat');
  const newConversation = !existingConversation;

  let parts = [];
  if (text) {
    const textPart = [{ type: 'text', text }];
    parts = parts.concat(textPart);
  }

  if (attachment) {
    const fileParts = attachment.map(file => {
      return {
        type: 'file',
        rawURL: file.link,
        name: file.name,
        size: file.size,
        'x-id': file['x-id']
      };
    });
    parts = parts.concat(fileParts);
  }

  yield (0, _effects.put)(_actions.messageActions.messageReceived([senderAddress], parts, messageId, senderAddress, dateTime, {
    type: 'chat',
    newConversation: newConversation
  }));
}

/**
 * Handles delivery receipts for SMS messages via websocket messages
 * @method handleDeliveryReceipts
 * @param  {Object} action A `RECEIVE_DELIVERY_RECEIPT` action representing a deliveryReceipt.
 */
function* handleDeliveryReceipts(action) {
  const deliveryInfo = action.payload.deliveryInfoNotification.deliveryInfo;
  let deliveryStatus = null;
  if (_mappings.DeliveryStatuses[deliveryInfo.deliveryStatus]) {
    deliveryStatus = _mappings.DeliveryStatuses[deliveryInfo.deliveryStatus];
  } else {
    log.info(`Invalid deliveryStatus: ${deliveryInfo.deliveryStatus}, defaulting to Unknown`);
    deliveryStatus = _mappings.DeliveryStatuses['Unknown'];
  }
  const messageId = deliveryInfo.messageId;
  const destination = `${deliveryInfo.address}`;
  yield (0, _effects.put)(_actions.messageActions.deliveryReceiptReceived(messageId, deliveryStatus, [destination], 'sms'));
}

/**
 * Handles "send message" actions specifically for SMS.
 * @method sendSMS
 * @param  {Object} action A `SEND_MESSAGE` action representing a SMS Message.
 */
function* sendSMS(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);

  // TODO: Remove this big workaround ---
  const messagingConfig = yield (0, _effects.select)(_selectors.getMessagingConfig);
  requestInfo.senderAddress = messagingConfig.smsFrom || 'default';
  // END Workaround

  const { destination, message } = action.payload;
  const response = yield (0, _effects.call)(_requests.sendSMSRequest, requestInfo, destination[0], message.parts[0].text);

  // TODO: Do something with the rest of the information from the response?
  //      The finish action is specific for pre-CPaaS 2.0 messages, so its
  //      awkward to pass on/store all the new information.
  let finishInfo = {
    sender: requestInfo.username,
    destination: destination,
    parts: message.parts,
    timestamp: message.timestamp,
    type: message.type
  };

  if (response.error) {
    yield (0, _effects.put)(_actions.messageActions.sendMessageFinish((0, _extends3.default)({}, finishInfo, {
      deliveryStatus: _mappings.DeliveryStatuses['DeliveryImpossible'],
      error: response.error
    })));
  } else {
    // the ID is in the end of a string (`.../messages/<ID>`), so get it.
    const messageId = response.resourceURL.split('/messages/')[1];
    yield (0, _effects.put)(_actions.messageActions.sendMessageFinish((0, _extends3.default)({}, finishInfo, {
      deliveryStatus: _mappings.DeliveryStatuses[response.deliveryInfoList.deliveryInfo[0].deliveryStatus],
      messageId
    })));
  }
}

/**
 * Saga for receiving an incoming SMS message.
 * @method handleIncomingSMS
 * @param  {Object} action A `NOTIFICATION_RECEIVED` action representing an inbound SMS.
 */
// TODO: Have a single "handleIncoming" saga that handles both IM and SMS?
function* handleIncomingSMS(action) {
  const notification = action.payload.inboundSMSMessageNotification;
  let { message, messageId, senderAddress } = notification.inboundSMSMessage;
  const { dateTime } = notification;

  if (!senderAddress) {
    // Incorrect property name: AEB-2485
    senderAddress = notification.inboundSMSMessage.senderAdress;
  }

  const existingConversation = yield (0, _effects.select)(_selectors.findConversation, [senderAddress], 'sms');
  const newConversation = !existingConversation;

  yield (0, _effects.put)(_actions.messageActions.messageReceived([senderAddress], [{ type: 'text', text: message }], messageId, senderAddress, dateTime, {
    newConversation: newConversation,
    type: 'sms'
  }));
}

/**
 * Saga that fetches a list of Chat Conversations
 * @method fetchChatConversations
 * @param {Object} action
 */
function* fetchChatConversations(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const response = yield (0, _effects.call)(_requests.chatFetchConversations, requestInfo);

  if (response.error) {
    yield (0, _effects.put)(_actions.convoActions.fetchConversationsFinished({
      error: response.error
    }));
  }

  const chatSessions = response.chatSession.map(chatSession => {
    const { sessionId, remoteAddress, sessionDetails } = chatSession;
    const { lastText, lastPullTime, lastMessageTime } = sessionDetails;

    return {
      id: sessionId,
      destination: [remoteAddress],
      type: 'chat',
      lastMessage: lastText,
      lastReceived: lastMessageTime,
      lastPull: lastPullTime,
      isTypingList: [],
      messages: []
    };
  });

  yield (0, _effects.put)(_actions.convoActions.fetchConversationsFinished({
    conversations: chatSessions,
    error: false
  }));
}

/**
 * Saga that fetches all chat messages for a particular conversation
 * @method fetchChatMessages
 * @param {Object} action
 */
function* fetchChatMessages(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const response = yield (0, _effects.call)(_requests.chatFetchMessages, requestInfo, action.payload.destination[0]);

  let destination;
  const messageList = response.chatMessage.map(message => {
    destination = message['x-destinationAddress']; // FIXME: make this less ugly

    let parts = [];
    if (message.text) {
      parts = parts.concat({ type: 'text', text: message.text });
    }
    if (message.attachment) {
      parts = parts.concat(message.attachment.map(attachment => {
        return (0, _extends3.default)({
          type: 'file'
        }, attachment, {
          rawURL: attachment.link,
          name: attachment.name
        });
      }));
    }

    return {
      parts: parts,
      sender: message.senderAddress,
      destination: message['x-destinationAddress'],
      timestamp: message.dateTime,
      messageId: message.resourceURL.split('/messages/')[1] // messageID is affter /messages/
    };
  });

  if (response.error) {
    yield (0, _effects.put)(_actions.messageActions.fetchMessagesFinished([destination], 'chat', null, response.error));
  } else {
    yield (0, _effects.put)(_actions.messageActions.fetchMessagesFinished([destination], 'chat', messageList, null));
  }
}

/**
 * Creates URLs for multimedia attachments and dispatches an action to update the store with the new url
 * @param {Object} action
 */
function* getImageLinks(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const { parts, destination, type, messageId } = action.payload;
  const fileParts = parts.filter(part => part.type === 'file');
  const responseList = yield (0, _effects.all)(fileParts.map(filePart => (0, _effects.call)(_requests.fetchImageLinks, requestInfo, filePart.rawURL)));

  yield (0, _effects.all)(responseList.map((response, index) => {
    if (response.error) {
      return (0, _effects.put)(_actions.messageActions.getImageLinksFinish({ error: response.error }));
    } else {
      // create a url from the blob and save it to the store.
      const url = URL.createObjectURL(response.blob);
      return (0, _effects.put)(_actions.messageActions.getImageLinksFinish({
        url,
        rawURL: fileParts[index].rawURL,
        destination,
        type,
        messageId
      }));
    }
  }));
}

/***/ }),

/***/ "./src/messaging/cpaas2/sagas/subscriptions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.chatSubscription = chatSubscription;
exports.chatUnsubscription = chatUnsubscription;
exports.smsInboundSubscription = smsInboundSubscription;
exports.smsInboundUnsubscription = smsInboundUnsubscription;
exports.smsOutboundSubscription = smsOutboundSubscription;
exports.smsOutboundUnsubscription = smsOutboundUnsubscription;

var _requests = __webpack_require__("./src/messaging/cpaas2/requests.js");

var _selectors = __webpack_require__("./src/messaging/cpaas2/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _selectors3 = __webpack_require__("./src/subscription/interface/selectors.js");

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _constants = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _loglevel = __webpack_require__("../../node_modules/loglevel/lib/loglevel.js");

var _loglevel2 = _interopRequireDefault(_loglevel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Plugin chat subscription saga.
 * Handles subscribing to the chat service needed for the messaging plugin.
 * @method chatSubscription
 */

// Libraries.
function* chatSubscription(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const channels = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  const channel = channels.notificationChannels[action.payload.type];

  _loglevel2.default.info(`Subscribing to chat service on ${action.payload.type} channel.`);

  const response = yield (0, _effects.call)(_requests.chatSubscribe, requestInfo, channel);

  if (response.error) {
    yield (0, _effects.put)(
    // TODO: Create a subscription effect for this?
    (0, _actions.reportSubscriptionFinished)({
      service: 'chat',
      type: action.payload.type,
      error: response.error
    }));
  } else {
    yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)({
      service: 'chat',
      type: action.payload.type,
      subscription: response.subscription
    }));
  }
}

/**
 * Plugin chat unsubscription saga.
 * Handles unsubscribing from chat service needed for the messaging plugin.
 * @method chatUnsubscription
 */


// Other plugins.
// Messaging plugin.
function* chatUnsubscription(action) {
  const { subscriptions } = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  let chatSubscription = subscriptions.filter(sub => {
    return sub.service === 'chat' && sub.channelType === action.payload.type;
  });

  if (chatSubscription.length === 0) {
    // This scenario should not occur because we should not be able to subscribe
    //    to an already subscribed-to service.
    _loglevel2.default.debug(`No chat subscription on ${action.payload.type} channel found to unsubscribe.`);
    yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)({
      error: new _errors2.default({
        message: 'Multiple chat subscriptions found. Cannot unsubscribe.',
        code: _errors.subscriptionCodes.CPAAS2_UNSUBSCRIBE_FAIL
      }),
      service: 'chat',
      type: action.payload.type
    }));
    return;
  } else if (chatSubscription.length > 1) {
    // "Error" scenario, why are there more than 1 chat subscriptions?
    // TODO: Report ...something.
    yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)());
    return;
  } else {
    chatSubscription = chatSubscription[0];
  }

  _loglevel2.default.info(`Unsubcribing from chat service on ${action.payload.type} channel.`);
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);

  const response = yield (0, _effects.call)(_requests.chatUnsubscribe, requestInfo, chatSubscription);

  yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'chat',
    type: action.payload.type
  })));
}

/**
 * Subscription saga for inbound SMS notifications.
 * @method smsInboundSubscription
 * @param  {Object} action
 */
function* smsInboundSubscription(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const channels = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  const channel = channels.notificationChannels[action.payload.type];

  // TODO: Remove this workaround -----
  const messagingConfig = yield (0, _effects.select)(_selectors.getMessagingConfig);
  requestInfo.destinationAddress = messagingConfig.smsFrom;
  // END Workaround -----

  _loglevel2.default.debug(`Subscribing to SMS inbound service on ${action.payload.type} channel.`);
  const response = yield (0, _effects.call)(_requests.smsInboundSubscribe, requestInfo, channel);

  yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'smsinbound',
    type: action.payload.type
  })));
}

/**
 * Unsubscription saga for inbound SMS notifications.
 * @method smsInboundUnsubscription
 * @param  {Object} action
 */
function* smsInboundUnsubscription(action) {
  const { subscriptions } = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  let smsSubscription = subscriptions.filter(sub => {
    return sub.service === 'smsinbound' && sub.channelType === action.payload.type;
  });

  if (smsSubscription.length === 1) {
    smsSubscription = smsSubscription[0];

    _loglevel2.default.debug(`Unsubscribing from inbound SMS service on ${action.payload.type} channel.`);
    const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
    const response = yield (0, _effects.call)(_requests.smsInboundUnsubscribe, requestInfo, smsSubscription);

    yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)((0, _extends3.default)({}, response, {
      service: 'smsinbound',
      type: action.payload.type
    })));
  } else {
    // "Error" scenario: Should only be one subscription like this.
  }
}

/**
 * Subscription saga for outbound SMS notifications.
 * @method smsOutboundSubscription
 * @param  {Object} action
 */
function* smsOutboundSubscription(action) {
  const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const channels = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  const channel = channels.notificationChannels[action.payload.type];

  _loglevel2.default.debug(`Subscribing to SMS outbound service on ${action.payload.type} channel.`);
  const response = yield (0, _effects.call)(_requests.smsOutboundSubscribe, requestInfo, channel);

  yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'smsoutbound',
    type: action.payload.type
  })));
}

/**
 * Unsubscription saga for outbound SMS notifications.
 * @method smsOutboundUnsubscription
 * @param  {Object} action
 */
function* smsOutboundUnsubscription(action) {
  const { subscriptions } = yield (0, _effects.select)(_selectors3.getNotificationChannels);
  let smsSubscription = subscriptions.filter(sub => {
    return sub.service === 'smsoutbound' && sub.channelType === action.payload.type;
  });

  if (smsSubscription.length === 1) {
    smsSubscription = smsSubscription[0];

    _loglevel2.default.debug(`Unsubscribing from outbound SMS service on ${action.payload.type} channel.`);
    const requestInfo = yield (0, _effects.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
    const response = yield (0, _effects.call)(_requests.smsOutboundUnsubscribe, requestInfo, smsSubscription);

    yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)((0, _extends3.default)({}, response, {
      service: 'smsoutbound',
      type: action.payload.type
    })));
  } else {
    // "Error" scenario: Should only be one subscription like this.
  }
}

/***/ }),

/***/ "./src/messaging/mappings.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Statuses we receive from the REST responses/websocket messages
const DeliveryStatuses = exports.DeliveryStatuses = {
  DeliveredToNetwork: 'Pending',
  DeliveredToTerminal: 'Delivered',
  DeliveryImpossible: 'Failed',
  Unknown: 'Unknown'
};

/***/ }),

/***/ "./src/notifications/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = notifications;

var _interface = __webpack_require__("./src/notifications/interface/index.js");

var _events = __webpack_require__("./src/notifications/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _sagas = __webpack_require__("./src/notifications/cpaas2/sagas.js");

var sagas = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _actions2 = __webpack_require__("./src/config/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Configuration options for the notification feature.
 * @public
 * @name config.notifications
 * @memberof config
 * @instance
 * @param {Object} notifications - The notifications configuration object.
 * @param {number} [notifications.idCacheLength=100] - Default amount of event ids to remember for de-duplication purposes.
 */

/**
 * CPaaS 2.0 Notifications plugin factory.
 * @method notifications
 * @param {configs.notifications} options - Configuration options for authentication.
 * @return {Object} plugin - A notifications plugin.
 */


// Libraries.


// Other plugins.
function notifications(options = {}) {
  const defaultOptions = {
    idCacheLength: 100
  };
  const pluginOptions = (0, _fp.defaultsDeep)(defaultOptions, options);

  function* init() {
    yield (0, _effects.put)((0, _actions2.update)(pluginOptions, _interface.name));
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));
  }

  const capabilities = [];

  return {
    name: _interface.name,
    capabilities,
    init,
    api: _interface.api,
    reducer: _interface.reducer,
    sagas: (0, _fp.values)(sagas)
  };
} // Notification plugin.

/***/ }),

/***/ "./src/notifications/cpaas2/sagas.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__("../../node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

exports.processNotifications = processNotifications;

var _actions = __webpack_require__("./src/notifications/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _actionTypes = __webpack_require__("./src/notifications/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _selectors = __webpack_require__("./src/notifications/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Get the logger


// Logs
const log = (0, _logs.getLogManager)().getLogger('NOTIFICATION');

/**
 * Tries to find the id of the notification.
 *
 * CPaaS 2.0 notifications do not have a consistent path to their ID.
 * The ID is one level down in the object, but we need to dynamically
 * find the key that its in.
 *
 * @param {Object} notification
 * @returns The notification id if it finds one, undefined otherwise.
 */
// Notification plugin.
function findNotificationId(notification) {
  for (let key in notification) {
    if (notification[key].id) {
      return notification[key].id;
    }
  }
}

function* processNotifications() {
  const config = yield (0, _effects.select)(_selectors.getNotificationConfig);
  const idCache = [];

  /**
   * Checks whether a notification has already been received,
   *      judging by its event ID.
   * @method isDuplicate
   * @param  {string} id
   * @return {boolean}
   */
  function isDuplicate(id) {
    if (idCache.indexOf(id) !== -1) {
      return true; // duplicate.
    } else {
      // Not a duplicate.
      idCache.push(id);
      if (idCache.length > config.idCacheLength) {
        idCache.shift();
      }

      return false;
    }
  }

  while (true) {
    const { payload: notification, meta } = yield (0, _effects.take)(actionTypes.PROCESS_NOTIFICATION);

    // Only process notifications from enabled channels, ie. "silence" the channel.
    let channel = yield (0, _effects.select)(_selectors.getNotificationsInfo, meta.channel);
    if (!channel.channelEnabled) {
      log.debug('Notification received on disabled channel. Ignoring it.', meta.channel);
      continue;
    }

    // Find the unique ID of the received notification.
    const notificationId = findNotificationId(notification);
    if (!notificationId) {
      log.error('Received notification without a findable ID.', (0, _keys2.default)(notification));
      continue;
    }

    if (!isDuplicate(notificationId)) {
      // Notify others (plugins) that a new notification was receive.
      yield (0, _effects.put)(actions.notificationReceived(notification, meta.platform));

      // Finish processing the notification.
      yield (0, _effects.put)(actions.processNotificationFinish(notification));
    } else {
      const error = new Error(`Notification id ${notificationId} is duplicate.`);
      yield (0, _effects.put)(actions.processNotificationFinish(error));
    }
  }
}

/***/ }),

/***/ "./src/notifications/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/';

const PROCESS_NOTIFICATION = exports.PROCESS_NOTIFICATION = prefix + 'PROCESS_NOTIFICATION';
const PROCESS_NOTIFICATION_FINISH = exports.PROCESS_NOTIFICATION_FINISH = prefix + 'PROCESS_NOTIFICATION_FINISH';
const NOTIFICATION_RECEIVED = exports.NOTIFICATION_RECEIVED = prefix + 'NOTIFICATION_RECEIVED';

const ENABLE_NOTIFICATION_CHANNEL = exports.ENABLE_NOTIFICATION_CHANNEL = prefix + 'ENABLE_NOTIFICATION_CHANNEL';
const ENABLE_NOTIFICATION_CHANNEL_FINISH = exports.ENABLE_NOTIFICATION_CHANNEL_FINISH = prefix + 'ENABLE_NOTIFICATION_CHANNEL_FINISH';

/***/ }),

/***/ "./src/notifications/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.websocketNotification = websocketNotification;
exports.externalNotification = externalNotification;
exports.notificationReceived = notificationReceived;
exports.processNotificationFinish = processNotificationFinish;
exports.enableNotificationChannel = enableNotificationChannel;
exports.enableNotificationChannelFinish = enableNotificationChannelFinish;

var _actionTypes = __webpack_require__("./src/notifications/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper function for funneling all notification types into a single action.
 * @method notificationHelper
 * @param  {string} channel - The channel that the notification came from.
 * @param  {Object} notification
 * @param  {string} platform
 * @return {Object} A flux standard action.
 */
function notificationHelper(channel, notification, platform) {
  return {
    type: actionTypes.PROCESS_NOTIFICATION,
    payload: notification,
    meta: {
      platform,
      channel
    }
  };
}

/**
 * Represents an application request to process a websocket notification.
 * @method websocketNotification
 * @param  {Object} notification
 * @param  {string} platform
 * @return {Object} A flux standard action.
 */

// Constants
function websocketNotification(notification, platform = _constants.platforms.LINK) {
  return notificationHelper('WEBSOCKET', notification, platform);
}

/**
 * Represents an application request to process an external notification.
 * @method externalNotification
 * @param  {Object} notification
 * @param  {string} [channel='EXTERNAL'] - The channel that the notification came from.
 * @return {Object} A flux standard action.
 */
function externalNotification(notification, channel = 'EXTERNAL', platform) {
  // TODO: Are external notifications _only_ for Link?
  return notificationHelper(channel.toUpperCase(), notification, platform);
}

/**
 * Represents a received notification.
 * @method notificationReceived
 * @param  {Object} notification
 * @param  {string} platform
 * @return {Object} A flux standard action.
 */
function notificationReceived(notification, platform) {
  return {
    type: actionTypes.NOTIFICATION_RECEIVED,
    payload: notification,
    error: notification instanceof Error,
    meta: {
      platform
    }
  };
}

/**
 * Represents a received notification.
 * @method processNotificationFinish
 * @param  {Object} notification
 * @param  {string} platform
 * @return {Object} A flux standard action.
 */
function processNotificationFinish(notification, platform) {
  return {
    type: actionTypes.PROCESS_NOTIFICATION_FINISH,
    payload: notification,
    error: notification instanceof Error,
    meta: {
      platform
    }
  };
}

/**
 * Represents a request to change a notification channel status.
 * @method enableNotificationChannel
 * @param  {string} channel - The notification channel being affected.
 * @param  {Object} params
 * @param  {boolean} params.channelEnabled - Whether to enable the channel or not.
 * @return {Object} A flux standard action.
 */
function enableNotificationChannel(channel, params = {}) {
  return {
    type: actionTypes.ENABLE_NOTIFICATION_CHANNEL,
    payload: (0, _extends3.default)({}, params),
    meta: {
      channel
    }
  };
}

/**
 * Represents the response of a change in a notification channel status.
 * @method enableNotificationChannelFinish
 * @param  {string} channel - The notification channel being affected.
 * @param  {Object} $1
 * @param  {Object} $1.params - Information about the channel change.
 * @param  {Object} $1.params.channelEnabled - Whether the channel was enabled or not.
 * @param  {Object} $1.error - Error object, in the case of an error.
 * @return {Object} A flux standard action.
 */
function enableNotificationChannelFinish(channel, { params, error } = {}) {
  var action = {
    type: actionTypes.ENABLE_NOTIFICATION_CHANNEL_FINISH,
    meta: {
      channel
    }
  };

  if (error) {
    action.error = true;
    action.payload = new Error(error);
    action.payload.channelEnabled = params.channelEnabled;
  } else {
    action.payload = (0, _extends3.default)({}, params);
  }

  return action;
}

/***/ }),

/***/ "./src/notifications/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = api;

var _actions = __webpack_require__("./src/notifications/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Notifications API.
 * @method api
 * @param {Function} dispatch The redux store's dispatch function.
 * @return {Object} api  The notifications API object.
 */
/**
 * @public
 * @module Notification
 * @requires externalNotifications
 */
function api({ dispatch }) {
  const notificationApi = {
    /**
     * Provides an external notification to the system for processing.
     *
     * @public
     * @requires externalNotifications
     * @memberof Notification
     * @method process
     * @param {Object} notification
     * @param {string} [channel] - The channel that the notification came from.
     */
    process(notification, channel, platform = _constants.platforms.LINK) {
      dispatch(actions.externalNotification(notification, channel, platform));
    },

    /**
     * Registers a device token for push notifications.
     *
     * @public
     * @requires push
     * @memberof Notification
     * @method registerPush
     * @param {Object} params
     * @param {string} params.deviceToken - The device token to be registered.
     * @param {string[]} params.services - Array of services to register for.
     * @param {string} params.pushProvider - The push provider, can be either 'apple' or 'google'.
     * @param {string} params.clientCorrelator - Unique identifier for a client device.
     */
    registerPush(params) {
      dispatch(actions.enableNotificationChannel('PUSH', (0, _extends3.default)({}, params, {
        channelEnabled: true
      })));
    },

    /**
     * Deregisters for push notifications.
     *
     * @public
     * @requires push
     * @memberof Notification
     * @method deregisterPush
     */
    deregisterPush() {
      dispatch(actions.enableNotificationChannel('PUSH', {
        channelEnabled: false
      }));
    },

    /**
     * Enables, or disables, the processing of websocket notifications.
     *
     * @public
     * @requires push
     * @memberof Notification
     * @method enableWebsocket
     * @param {boolean} enable - Whether the websocket channel should be enabled.
     */
    enableWebsocket(enable) {
      dispatch(actions.enableNotificationChannel('WEBSOCKET', {
        channelEnabled: enable
      }));
    }
  };

  return { notification: notificationApi };
}

/***/ }),

/***/ "./src/notifications/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Push notifications registration state has changed.
 *
 * @public
 * @requires push
 * @memberof Notification
 * @event notifications:change
 * @param {Object} params
 * @param {string} params.channel The channel for the notification.
 */
const NOTI_CHANGE = exports.NOTI_CHANGE = 'notifications:change';

/**
 * An error occured with push notifications.
 *
 * @public
 * @requires push
 * @memberof Notification
 * @event notifications:error
 * @param {Object} params
 * @param {BasicError} params.error The Basic error object.
 * @param {string} params.channel The channel for the notification.
 */
const NOTI_ERROR = exports.NOTI_ERROR = 'notifications:error';

/***/ }),

/***/ "./src/notifications/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/notifications/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/notifications/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var events = {};

events[actionTypes.ENABLE_NOTIFICATION_CHANNEL_FINISH] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.NOTI_ERROR,
      args: { channel: action.meta.channel, error: action.payload }
    };
  } else {
    return {
      type: eventTypes.NOTI_CHANGE,
      args: { channel: action.meta.channel }
    };
  }
};

exports.default = events;

/***/ }),

/***/ "./src/notifications/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.api = exports.name = undefined;

var _reducers = __webpack_require__("./src/notifications/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

var _api = __webpack_require__("./src/notifications/interface/api.js");

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const name = 'notifications';

exports.name = name;
exports.api = _api2.default;
exports.reducer = _reducers2.default;

/***/ }),

/***/ "./src/notifications/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/notifications/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actionTypes2 = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

reducers[actionTypes.ENABLE_NOTIFICATION_CHANNEL_FINISH] = {
  next(state, action) {
    let channel = action.meta.channel;
    let enabled = action.payload.channelEnabled;

    let newChannelState;
    if (enabled) {
      newChannelState = (0, _extends3.default)({}, state[channel], action.payload);
    } else {
      // If the channel is being disabled, clear old state.
      newChannelState = (0, _extends3.default)({}, action.payload);
    }

    return (0, _extends3.default)({}, state, {
      [channel]: newChannelState
    });
  }
};

/*
 * The websocket channel is assumed to be enabled when the
 *      websocket is opened.
 */
reducers[_actionTypes2.WS_CONNECT_FINISHED] = {
  next(state) {
    // TODO: Link WS only?
    return (0, _extends3.default)({}, state, {
      WEBSOCKET: (0, _extends3.default)({}, state.WEBSOCKET, {
        channelEnabled: true
      })
    });
  }
};

// Default notifications sub-state.
const defaultState = {
  WEBSOCKET: {
    channelEnabled: false
  },
  PUSH: {
    channelEnabled: false
  },
  EXTERNAL: {
    channelEnabled: true
  }

  /**
   * Notifications reducer.
   * @method reducer
   * @param  {Object}  state - The current redux state.
   * @param  {Object}  action - A flux standard action.
   * @return {Object}  - The new redux state.
   */
};const reducer = (0, _reduxActions.handleActions)(reducers, defaultState);
exports.default = reducer;

/***/ }),

/***/ "./src/notifications/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNotificationsInfo = getNotificationsInfo;
exports.getNotificationConfig = getNotificationConfig;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Retrieves the notifications state.
 * @method getNotificationsInfo
 * @param  {String} [channel] - Specific notification channel information to retrieve.
 * @return {Object}
 */
function getNotificationsInfo(state, channel = undefined) {
  if (channel) {
    return state.notifications[channel];
  } else {
    return state.notifications;
  }
}

/**
 * Retrieves notification config.
 * @method getNotificationConfig
 * @return {Object}
 */
function getNotificationConfig(state) {
  return (0, _fp.cloneDeep)(state.config.notifications);
}

/***/ }),

/***/ "./src/presence/cpaas2/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The valid status values
 * @name STATUS
 * @type {Object}
 */
const STATUS = exports.STATUS = {
  OPEN: 'Open',
  CLOSED: 'Closed'

  /**
   * The valid activities values
   * @name ACTIVITY
   * @type {Object}
   */
};const ACTIVITY = exports.ACTIVITY = {
  AVAILABLE: 'Available',
  BUSY: 'Busy',
  LUNCH: 'Lunch',
  VACATION: 'Vacation',
  ON_THE_PHONE: 'OnThePhone',
  ACTIVITIES_UNKNOWN: 'ActivitiesUnknown',
  ACTIVITIES_OTHER: 'ActivitiesOther'
};

/***/ }),

/***/ "./src/presence/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _interface = __webpack_require__("./src/presence/interface/index.js");

var _sagas = __webpack_require__("./src/presence/cpaas2/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _events = __webpack_require__("./src/presence/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _constants = __webpack_require__("./src/presence/cpaas2/constants.js");

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Libraries.
const name = 'presence';

// Other plugins.
// Presence plugin.


const capabilities = ['presence'];

exports.default = () => {
  // Add plugin-specific things to the API.
  function augmentedApi(context) {
    const newApi = (0, _interface.api)(context);
    /**
     * Possible status values.
     * @public
     * @memberof Presence
     * @type {Object}
     * @property {string} OPEN
     * @property {string} CLOSED
     * @example
     * const { statuses, activities } = client.presence
     * // Use the values when updating presence.
     * client.presence.update(statuses.OPEN, activities.AVAILABLE)
     */
    newApi.presence.statuses = _constants.STATUS;
    /**
     * Possible activity values.
     * @public
     * @memberof Presence
     * @type {Object}
     * @property {string} AVAILABLE
     * @property {string} BUSY
     * @property {string} LUNCH
     * @property {string} VACATION
     * @property {string} ON_THE_PHONE
     * @property {string} ACTIVITIES_UNKNOWN
     * @property {string} ACTIVITIES_OTHER
     */
    newApi.presence.activities = _constants.ACTIVITY;
    return newApi;
  }

  return {
    name,
    capabilities,
    api: augmentedApi,
    reducer: _interface.reducer,
    init: () => [(0, _effects.put)((0, _actions.mapEvents)(_events2.default))],
    sagas: (0, _fp.values)(sagas)
  };
};

/***/ }),

/***/ "./src/presence/cpaas2/requests/presence.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.publish = publish;
exports.createList = createList;
exports.deleteList = deleteList;
exports.getList = getList;
exports.getPresenceLists = getPresenceLists;
exports.retrievePresence = retrievePresence;
exports.addUser = addUser;
exports.removeUser = removeUser;

var _constants = __webpack_require__("./src/presence/cpaas2/constants.js");

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _helpers = __webpack_require__("./src/common/helpers/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * REST request to create a new presence source with initial presence state.
 * @method publish
 * @param  {Object} userPresence
 * @param  {string} userPresence.status - user presence status
 * @param  {string} userPresence.activity - user presence activity
 * @param  {string} userPresence.note - user presence note
 * @param  {Object} requestInfo
 * @return {Object}
 */


// Helpers.
function* publish({ status, activity, note }, requestInfo) {
  let requestBody = {
    presenceSource: {
      clientCorrelator: requestInfo.clientCorrelator,
      presence: {
        person: {
          'overriding-willingness': {
            overridingWillingnessValue: status
          },
          activities: {
            activityValue: activity
          }
        }
      }
    }
  };
  if (note && activity === _constants.ACTIVITY.ACTIVITIES_OTHER) {
    requestBody.presenceSource.presence.person.activities.other = note;
  }

  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceSources`,
    body: (0, _stringify2.default)(requestBody)
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Presence publish')
    };
  } else {
    return response.payload.body.presenceSource;
  }
}

/**
 * REST request to create a new presence list.
 * @method createList
 * @param  {string} user User ID of presentity
 * @param  {Object} requestInfo
 * @return {Object}
 */
// Presence plugin.
function* createList(user, requestInfo) {
  let requestBody = {
    presenceList: {
      'x-listName': 'myList',
      presenceContact: user
    }
  };

  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/${requestInfo.username}/presenceLists`,
    body: (0, _stringify2.default)(requestBody)
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Create presence list')
    };
  } else {
    return response.payload.body.presenceList;
  }
}
/**
 * REST request to delete a presence list.
 * @method deleteList
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* deleteList(presenceListId, requestInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceLists/${presenceListId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Delete presence list')
    };
  } else {
    return response;
  }
}

/**
 * REST request to retrieve a presence list.
 * @method getList
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* getList(presenceListId, requestInfo) {
  const requestOptions = {
    method: 'GET',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceLists/${presenceListId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Get presence list')
    };
  } else {
    return response;
  }
}
/**
 * REST request to retrieve all presence lists.
 * @method getPresenceLists
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* getPresenceLists(requestInfo) {
  const requestOptions = {
    method: 'GET',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceLists`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Get presence lists')
    };
  } else {
    return response.payload.body.presenceListCollection;
  }
}

/**
 * REST request to retrieve presence states of requested presentities.
 * @method retrievePresence
 * @param  {Array} users Array of userId's
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {string} subscriptionId Resource ID of the subscription
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* retrievePresence(users, presenceListId, subscriptionId, requestInfo) {
  let adhocPresenceList = {
    adhocPresenceList: {
      presentityUserId: users
    }
  };

  const requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/adhocPresenceList`,
    body: (0, _stringify2.default)(adhocPresenceList)
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Fetch users presence')
    };
  } else {
    return response.payload.body.presenceList;
  }
}
/**
 * REST request to add a new presentity to the presence list.
 * @method addUser
 * @param  {string} user userId
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* addUser(userId, presenceListId, requestInfo) {
  let presenceContact = {
    presenceContact: {
      presentityUserId: userId
    }
  };

  const requestOptions = {
    method: 'PUT',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceLists/${presenceListId}/` + `presenceContacts/${userId}`,
    body: (0, _stringify2.default)(presenceContact)
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Add presence user')
    };
  } else {
    return response.payload.body.presenceContact;
  }
}
/**
 * REST request to delete a presentity from a presence list.
 * @method removeUser
 * @param  {string} user userId
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* removeUser(userId, presenceListId, requestInfo) {
  const requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/presenceLists/${presenceListId}/` + `presenceContacts/${userId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Remove presence user')
    };
  } else {
    return response.payload.result;
  }
}

/***/ }),

/***/ "./src/presence/cpaas2/requests/subscriptions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.subscribe = subscribe;
exports.unsubscribe = unsubscribe;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _helpers = __webpack_require__("./src/common/helpers/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * REST request to create a presence list subscription.
 * @method subscribe
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {string} callbackURL Callback URL of websocket channel
 * @param  {Object} requestInfo
 * @return {Object}
 */
// Presence plugin.

// Helpers.
function* subscribe(presenceListId, callbackURL, requestInfo) {
  let presenceListSubscription = {
    presenceListSubscription: {
      callbackReference: {
        notifyURL: callbackURL
      },
      clientCorrelator: requestInfo.clientCorrelator,
      duration: 86400
    }
  };

  let requestOptions = {
    method: 'POST',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/subscriptions/presenceListSubscriptions/` + `${presenceListId}`,
    body: (0, _stringify2.default)(presenceListSubscription)
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Subscribe to presence list')
    };
  } else {
    return response.payload.body;
  }
}

/**
 * REST request to delete a subscription against a presence list.
 * @method unsubscribe
 * @param  {string} presenceListId Resource ID of the presenceList
 * @param  {string} subscriptionId Resource ID of the subscription
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* unsubscribe(presenceListId, subscriptionId, requestInfo) {
  let requestOptions = {
    method: 'DELETE',
    url: `${requestInfo.baseURL}/cpaas/presence/${requestInfo.version}/` + `${requestInfo.username}/subscriptions/presenceListSubscriptions/` + `${presenceListId}/${subscriptionId}`
  };

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    return {
      error: (0, _helpers.handleRequestError)(response, 'Unsubscribe from presence list')
    };
  } else {
    return response.payload.body;
  }
}

/***/ }),

/***/ "./src/presence/cpaas2/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerPresence = registerPresence;
exports.subscribePresence = subscribePresence;
exports.unsubscribePresence = unsubscribePresence;
exports.updatePresence = updatePresence;
exports.fetchPresence = fetchPresence;
exports.receivePresence = receivePresence;

var _subscriptions = __webpack_require__("./src/presence/cpaas2/sagas/subscriptions.js");

var subscriptionSagas = _interopRequireWildcard(_subscriptions);

var _presence = __webpack_require__("./src/presence/cpaas2/sagas/presence.js");

var presenceSagas = _interopRequireWildcard(_presence);

var _actionTypes = __webpack_require__("./src/presence/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actionTypes2 = __webpack_require__("./src/notifications/interface/actionTypes.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _effects2 = __webpack_require__("./src/subscription/interface/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Register the presence service for subscriptions.
 * @method registerPresence
 */


// Libraries.
/**
 * Presence saga index.
 * Defines which actions trigger which sagas.
 */

// Presence plugin.
function* registerPresence() {
  yield (0, _effects2.registerService)('presence', subscriptionSagas.presenceSubscribe, subscriptionSagas.presenceUnsubscribe);
}

/**
 * Presence operations.
 */

/**
 * Subscribe user presence.
 * @method subscribePresence
 */


// Other plugins.
function* subscribePresence() {
  yield (0, _effects.takeEvery)(actionTypes.SUBSCRIBE, presenceSagas.subscribePresence);
}

/**
 * Unsubscribe user presence.
 * @method unsubscribePresence
 */
function* unsubscribePresence() {
  yield (0, _effects.takeEvery)(actionTypes.UNSUBSCRIBE, presenceSagas.unsubscribePresence);
}

/**
 * Update user presence.
 * @method updatePresence
 */
function* updatePresence() {
  yield (0, _effects.takeEvery)(actionTypes.UPDATE, presenceSagas.updatePresence);
}

/**
 * Fetch user(s) presence.
 * @method fetchPresence
 */
function* fetchPresence() {
  yield (0, _effects.takeEvery)(actionTypes.GET, presenceSagas.fetchPresence);
}

function* receivePresence() {
  yield (0, _effects.takeEvery)(action => action.type === _actionTypes2.NOTIFICATION_RECEIVED && action.payload.presenceNotification, presenceSagas.handleIncomingPresence);
}

/***/ }),

/***/ "./src/presence/cpaas2/sagas/presence.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__("../../node_modules/babel-runtime/core-js/object/values.js");

var _values2 = _interopRequireDefault(_values);

exports.updatePresence = updatePresence;
exports.fetchPresence = fetchPresence;
exports.subscribePresence = subscribePresence;
exports.unsubscribePresence = unsubscribePresence;
exports.handleIncomingPresence = handleIncomingPresence;

var _presence = __webpack_require__("./src/presence/cpaas2/requests/presence.js");

var _actions = __webpack_require__("./src/presence/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _selectors2 = __webpack_require__("./src/subscription/interface/selectors.js");

var _constants = __webpack_require__("./src/constants.js");

var _constants2 = __webpack_require__("./src/presence/cpaas2/constants.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Helpers.
const log = (0, _logs.getLogManager)().getLogger('PRESENCE');

/**
 * Map of old presence activity values to new values.
 * @type {Object}
 */


// Libraries.


// Other plugins.
// Presence plugin.
const activityMapCPaaSToCPaaS2 = {
  active: _constants2.ACTIVITY.AVAILABLE,
  idle: _constants2.ACTIVITY.BUSY,
  away: _constants2.ACTIVITY.BUSY,
  lunch: _constants2.ACTIVITY.LUNCH,
  other: _constants2.ACTIVITY.ACTIVITIES_OTHER,
  busy: _constants2.ACTIVITY.BUSY,
  vacation: _constants2.ACTIVITY.VACATION,
  'on-the-phone': _constants2.ACTIVITY.ON_THE_PHONE,
  unknown: _constants2.ACTIVITY.ACTIVITIES_UNKNOWN

  /*
   * Map of old presence status values to new values.
   * @type {Object}
   */
};const statusMapCPaaSToCPaaS2 = {
  open: _constants2.STATUS.OPEN,
  closed: _constants2.STATUS.CLOSED

  /**
   * Update presence.
   * @method updatePresence
   * @param  {Object} action An action of type `PUBLISH_PRESENCE`.
   */
};function* updatePresence({ payload }) {
  // Convert the status to the CPaaS2 value (if required)
  if (payload.status in statusMapCPaaSToCPaaS2) {
    payload.status = statusMapCPaaSToCPaaS2[payload.status];
  }

  // Convert the activity to the CPaaS2 value (if required)
  if (payload.activity in activityMapCPaaSToCPaaS2) {
    payload.activity = activityMapCPaaSToCPaaS2[payload.activity];
  }

  // Verify that the status value is a valid CPaaS2 values
  if ((0, _values2.default)(_constants2.STATUS).indexOf(payload.status) === -1) {
    log.info('Could not update presence: Invalid status.');
    yield (0, _effects.put)(actions.updatePresenceFinish(new _errors2.default({
      code: _errors.presenceCodes.INVALID_STATUS,
      message: 'Invalid status in presence update request.'
    })));
    return;
  }

  // Verify that the activity value is a valid CPaaS2 value
  if ((0, _values2.default)(_constants2.ACTIVITY).indexOf(payload.activity) === -1) {
    log.info('Could not update presence: Invalid activity.');
    yield (0, _effects.put)(actions.updatePresenceFinish(new _errors2.default({
      code: _errors.presenceCodes.INVALID_ACTIVITY,
      message: 'Invalid activity in presence update request.'
    })));
    return;
  }

  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const response = yield (0, _effects.call)(_presence.publish, payload, requestInfo);
  log.debug('Received response from getRequestInfo request:', response);

  if (!response.error) {
    let presenceValues = {};
    presenceValues.status = response.presence.person['overriding-willingness'].overridingWillingnessValue;
    presenceValues.activity = response.presence.person.activities.activityValue;
    presenceValues.note = response.presence.person.activities.other;

    yield (0, _effects.put)(actions.updatePresenceFinish(presenceValues));
  } else {
    yield (0, _effects.put)(actions.updatePresenceFinish(response.error));
  }
}

/**
 * fetchPresence.
 * @method fetchPresence
 * @param  {Array<string>|string} users A single userId or array of userIds
 */
function* fetchPresence({ payload }) {
  const users = payload;
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);

  // get current presenceListId
  const subscriptions = yield (0, _effects.select)(_selectors2.getNotificationChannels);
  var presenceSubscription = subscriptions.subscriptions.filter(function (sub) {
    return sub.service === 'presence';
  });
  const presenceListId = presenceSubscription[0].presenceListId;
  const resourceURL = presenceSubscription[0].resourceURL;
  const subscriptionId = resourceURL.substring(resourceURL.lastIndexOf('/') + 1);

  const response = yield (0, _effects.call)(_presence.retrievePresence, users, presenceListId, subscriptionId, requestInfo);
  log.debug('Received response from retrievePresence request:', response);

  if (!response.error) {
    yield (0, _effects.put)(actions.getPresenceFinish(response));
  } else {
    yield (0, _effects.put)(actions.getPresenceFinish(response.error));
  }
}

/**
 * subscribePresence.
 * @method subscribePresence
 * @param  {string} userId userId
 */
function* subscribePresence({ payload }) {
  const userId = payload;
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);

  // get current presenceListId
  const subscriptions = yield (0, _effects.select)(_selectors2.getNotificationChannels);
  var presenceSubscription = subscriptions.subscriptions.filter(function (sub) {
    return sub.service === 'presence';
  });
  const presenceListId = presenceSubscription[0].presenceListId;
  const response = yield (0, _effects.call)(_presence.addUser, userId, presenceListId, requestInfo);
  log.debug('Received response from addUser request:', response);

  if (!response.error) {
    yield (0, _effects.put)(actions.subscribePresenceFinish(response));
  } else {
    yield (0, _effects.put)(actions.subscribePresenceFinish(response.error));
  }
}
/**
 * unsubscribePresence.
 * @method unsubscribePresence
 * @param  {string} userId userId
 */
function* unsubscribePresence({ payload }) {
  const userId = payload;
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);

  // get current presenceListId
  const subscriptions = yield (0, _effects.select)(_selectors2.getNotificationChannels);
  var presenceSubscription = subscriptions.subscriptions.filter(function (sub) {
    return sub.service === 'presence';
  });
  const presenceListId = presenceSubscription[0].presenceListId;

  const response = yield (0, _effects.call)(_presence.removeUser, userId, presenceListId, requestInfo);
  log.debug('Received response from removeUser request:', response);

  if (!response.error) {
    yield (0, _effects.put)(actions.unsubscribePresenceFinish(userId));
  } else {
    yield (0, _effects.put)(actions.unsubscribePresenceFinish(response.error));
  }
}

/**
 * handle incoming presence notification.
 * @method handleIncomingPresence
 * @param  {string} userId userId
 */
function* handleIncomingPresence(wsAction) {
  const notification = wsAction.payload.presenceNotification;
  //
  if (notification.presence) {
    let presence = {};
    presence.userId = notification.presentityUserId;
    presence.activity = notification.presence.person.activities.activityValue;
    presence.status = notification.presence.person['overriding-willingness'].overridingWillingnessValue;
    presence.note = notification.presence.person.activities.other;
    yield (0, _effects.put)(actions.presenceReceived(presence));
  }
}

/***/ }),

/***/ "./src/presence/cpaas2/sagas/subscriptions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.presenceSubscribe = presenceSubscribe;
exports.presenceUnsubscribe = presenceUnsubscribe;

var _presence = __webpack_require__("./src/presence/cpaas2/requests/presence.js");

var _subscriptions = __webpack_require__("./src/presence/cpaas2/requests/subscriptions.js");

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _selectors2 = __webpack_require__("./src/subscription/interface/selectors.js");

var _constants = __webpack_require__("./src/constants.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Helpers.


// Other plugins.
// Presence plugin.
const log = (0, _logs.getLogManager)().getLogger('PRESENCE');

/**
 * Subscription saga. Creates a new presence subscription channel.
 * @method presenceSubscribe
 */


// Libraries.
function* presenceSubscribe() {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const channels = yield (0, _effects.select)(_selectors2.getNotificationChannels);

  const callbackURL = channels.notificationChannels.websocket.callbackURL;

  // either use an existing presence list, or create a new one
  const presenceListResponse = yield (0, _effects.call)(_presence.getPresenceLists, requestInfo);
  log.debug('Received presenceLists response:', presenceListResponse);

  // check if there is a presence list already
  let presenceListId, newListResponse;
  if (!presenceListResponse.error) {
    // check if there is an existing presenceList
    if (presenceListResponse.presenceList.length > 0) {
      const url = presenceListResponse.presenceList[0].resourceURL;
      if (url) {
        let lastIndex = url.lastIndexOf('/');
        presenceListId = url.slice(lastIndex + 1);
      }
    } else {
      //  create a new presenceList
      newListResponse = yield (0, _effects.call)(_presence.createList, [], requestInfo);

      if (newListResponse.error) {
        yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)({
          service: 'presence',
          type: 'websocket',
          error: newListResponse.error
        }));
        return;
      }

      const resourceURL = newListResponse.resourceURL;
      if (resourceURL) {
        presenceListId = resourceURL.substring(resourceURL.lastIndexOf('/') + 1);
      }
    }
  } else {
    yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)({
      service: 'presence',
      type: 'websocket',
      error: presenceListResponse.error
    }));
    return;
  }

  // Subscribe to the presence list subscription
  const response = yield (0, _effects.call)(_subscriptions.subscribe, presenceListId, callbackURL, requestInfo);
  log.debug('Received subscribe presence response:', response);

  if (response.error) {
    yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)({
      service: 'presence',
      type: 'websocket',
      error: response.error
    }));
  } else {
    yield (0, _effects.put)((0, _actions.reportSubscriptionFinished)({
      service: 'presence',
      type: 'websocket',
      subscription: response.presenceListSubscription
    }));
  }
}

/**
 * Unsubscription saga. Deletes an existing presence subscription.
 * @method presenceUnsubscribe
 */
function* presenceUnsubscribe(action) {
  const { subscriptions } = yield (0, _effects.select)(_selectors2.getNotificationChannels);
  let presenceSubscription = subscriptions.filter(sub => {
    return sub.service === 'presence' && sub.channelType === action.payload.type;
  });

  if (presenceSubscription.length === 0) {
    // "Error" scenario: Can't unsubscribe to a service
    //    that we don't have.
  } else if (presenceSubscription.length > 1) {
    // "Error" scenario: There shouldn't be able to have
    //    more than 1 of the same service.
  } else {
    presenceSubscription = presenceSubscription[0];
  }
  const presenceListId = presenceSubscription.presenceListId;
  const subscription = presenceSubscription.subscriptionId;
  const subscriptionId = subscription.substring(subscription.lastIndexOf('/') + 1);

  log.info(`Unsubscribing from presence service on ${action.payload.type} channel.`);
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);

  // Unsubscribe from the presence list subscription
  const response = yield (0, _effects.call)(_subscriptions.unsubscribe, presenceListId, subscriptionId, requestInfo);

  yield (0, _effects.put)((0, _actions.reportUnsubscriptionFinished)((0, _extends3.default)({}, response, {
    service: 'presence',
    type: action.payload.type
  })));
}

/***/ }),

/***/ "./src/presence/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/PRESENCE/';

const UPDATE = exports.UPDATE = prefix + 'UPDATE';
const UPDATE_FINISH = exports.UPDATE_FINISH = prefix + 'UPDATE_FINISH';
const GET = exports.GET = prefix + 'GET';
const GET_FINISH = exports.GET_FINISH = prefix + 'GET_FINISH';
const SUBSCRIBE = exports.SUBSCRIBE = prefix + 'SUBSCRIBE';
const SUBSCRIBE_FINISH = exports.SUBSCRIBE_FINISH = prefix + 'SUBSCRIBE_FINISH';
const UNSUBSCRIBE = exports.UNSUBSCRIBE = prefix + 'UNSUBSCRIBE';
const UNSUBSCRIBE_FINISH = exports.UNSUBSCRIBE_FINISH = prefix + 'UNSUBSCRIBE_FINISH';
const RECEIVED = exports.RECEIVED = prefix + 'RECEIVED';
const CREATE_PRESENCE_LIST = exports.CREATE_PRESENCE_LIST = prefix + 'CREATE_PRESENCE_LIST';
const CREATE_PRESENCE_LIST_FINISH = exports.CREATE_PRESENCE_LIST_FINISH = prefix + 'CREATE_PRESENCE_LIST_FINISH';
const DELETE_PRESENCE_LIST = exports.DELETE_PRESENCE_LIST = prefix + 'DELETE_PRESENCE_LIST';
const GET_PRESENCE_LIST = exports.GET_PRESENCE_LIST = prefix + 'GET_PRESENCE_LIST';

/***/ }),

/***/ "./src/presence/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updatePresence = updatePresence;
exports.updatePresenceFinish = updatePresenceFinish;
exports.getPresence = getPresence;
exports.getPresenceFinish = getPresenceFinish;
exports.subscribePresence = subscribePresence;
exports.subscribePresenceFinish = subscribePresenceFinish;
exports.unsubscribePresence = unsubscribePresence;
exports.unsubscribePresenceFinish = unsubscribePresenceFinish;
exports.createPresenceList = createPresenceList;
exports.deletePresenceList = deletePresenceList;
exports.getPresenceList = getPresenceList;
exports.createListFinish = createListFinish;
exports.presenceReceived = presenceReceived;

var _actionTypes = __webpack_require__("./src/presence/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Update the presence for the current user
 * @param  {string} status   The status of the presence state
 * @param  {string} activity The activity to be shown as presence state
 * @param  {string} note     The note to be shown as alternative presence state
 *                           which is determined by the user. The note entry is
 *                           effective on the remote sip client when the
 *                           activity is other.
 * @return {Object}          A Flux Standard Action for UPDATE_PRESENCE
 */
// Presence plugin.
function updatePresence(status, activity, note) {
  return {
    type: actionTypes.UPDATE,
    payload: {
      status,
      activity,
      note
    }
  };
}

// Other plugins.
function updatePresenceFinish(payload) {
  return {
    type: actionTypes.UPDATE_FINISH,
    error: payload instanceof Error || payload instanceof _errors2.default,
    payload
  };
}

/**
 * Get the presence for the given user(s)
 * @param  {string} users  A user id or an array of user ids.
 * @return {Object}        A Flux Standard Action for GET_PRESENCE
 */
function getPresence(users) {
  return {
    type: actionTypes.GET,
    payload: users
  };
}

function getPresenceFinish(payload) {
  return {
    type: actionTypes.GET_FINISH,
    error: payload instanceof Error || payload instanceof _errors2.default,
    payload
  };
}

/**
 * Subscribe to the presence for the given user(s)
 * @param  {string} users  A user id or an array of user ids.
 * @return {Object}        A Flux Standard Action for SUBSCRIBE_PRESENCE
 */
function subscribePresence(users) {
  return {
    type: actionTypes.SUBSCRIBE,
    payload: users
  };
}

function subscribePresenceFinish(payload) {
  return {
    type: actionTypes.SUBSCRIBE_FINISH,
    error: payload instanceof Error || payload instanceof _errors2.default,
    payload
  };
}

/**
 * Unsubscribe from the presence for the given user(s)
 * @param  {string} users  A user id or an array of user ids.
 * @return {Object}        A Flux Standard Action for UNSUBSCRIBE_PRESENCE
 */
function unsubscribePresence(users) {
  return {
    type: actionTypes.UNSUBSCRIBE,
    payload: users
  };
}

function unsubscribePresenceFinish(payload) {
  return {
    type: actionTypes.UNSUBSCRIBE_FINISH,
    error: payload instanceof Error || payload instanceof _errors2.default,
    payload
  };
}

/**
 * Create a new presence list
 * @param  {string} users  A user id or an array of user ids.
 * @return {Object}        A Flux Standard Action for UNSUBSCRIBE_PRESENCE
 */
function createPresenceList(users) {
  return {
    type: actionTypes.CREATE_PRESENCE_LIST,
    payload: users
  };
}

/**
 * Delete a presence list
 * @param  {string} presenceListId  The ID of the presence list to delete.
 * @return {Object}                 A Flux Standard Action for UNSUBSCRIBE_PRESENCE
 */
function deletePresenceList(presenceListId) {
  return {
    type: actionTypes.DELETE_PRESENCE_LIST,
    payload: presenceListId
  };
}

/**
 * Retrieve a presence list
 * @param  {string} presenceListId  The ID of the presence list to delete.
 * @return {Object}                 A Flux Standard Action for UNSUBSCRIBE_PRESENCE
 */
function getPresenceList(presenceListId) {
  return {
    type: actionTypes.GET_PRESENCE_LIST,
    payload: presenceListId
  };
}

function createListFinish(payload) {
  return {
    type: actionTypes.CREATE_LIST_FINISH,
    error: payload instanceof Error || payload instanceof _errors2.default,
    payload
  };
}

function presenceReceived(presence) {
  return {
    type: actionTypes.RECEIVED,
    payload: presence
  };
}

/***/ }),

/***/ "./src/presence/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  const presenceApi = {
    /**
     * Update the presence for the current user.
     * Other users subscribed for this user's presence will receive the update.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method update
     * @param  {string} status The status of the presence state.
     * @param  {string} activity The activity to be shown as presence state
     * @param  {string} [note] An additional note to be provided when the activity is "other".
     */
    update(status, activity, note) {
      context.dispatch(actions.updatePresence(status, activity, note));
    },

    /**
     * Retrieve the presence information for specified users.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method get
     * @param  {Array<string>|string} users  A user id or an array of user ids.
     * @return {Array} List of user presence information.
     */
    get(user) {
      const users = Array.isArray(user) ? user : [user];
      const storedUsers = selectors.getPresence(context.getState(), users);
      // return something sensible based on the input
      if (!Array.isArray(users)) {
        if (storedUsers.length) {
          return storedUsers[0];
        }
        return undefined;
      }
      return storedUsers;
    },

    /**
     * Retrieve the presence information for all users.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method getAll
     * @return {Array} List of user presence information.
     */
    getAll() {
      return selectors.getAllPresence(context.getState());
    },

    /**
     * Retrieves the presence information for the current user.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method getSelf
     * @return {Object}
     */
    getSelf() {
      return selectors.getSelfPresence(context.getState());
    },

    /**
     * Fetch (from the server) the presence for the given users.
     * This will update the store with the retrieved values, which can then
     * be accessed using `get`.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method fetch
     * @param  {Array<string>|string} users  A user id or an array of user ids.
     */
    fetch(user) {
      const users = Array.isArray(user) ? user : [user];
      context.dispatch(actions.getPresence(users));
    },

    /**
     * Subscribe to retrieve presence updates about specified user.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method subscribe
     * @param  {string} user  The ID of the user to subscribe to.
     */
    subscribe(users) {
      context.dispatch(actions.subscribePresence(users));
    },

    /**
     * Unsubscribe from presence updates about specified user.
     *
     * @public
     * @memberof Presence
     * @requires presence
     * @method unsubscribe
     * @param  {string} user  The ID of the user to unsubscribe from.
     */
    unsubscribe(users) {
      context.dispatch(actions.unsubscribePresence(users));
    }
  };
  return { presence: presenceApi };
};

var _actions = __webpack_require__("./src/presence/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/presence/interface/selectors.js");

var selectors = _interopRequireWildcard(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/***/ }),

/***/ "./src/presence/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A presence update has been received from a subscribed user.
 *
 * @public
 * @memberof Presence
 * @requires presence
 * @event presence:change
 * @param {Object} params A presence object containing data.
 * @param {string} params.userId The ID of the user.
 * @param {string} params.status The presence status of the user.
 * @param {string} params.activity The activity of the user.
 * @param {string} params.note A custom note provided by the user.
 */
const RECEIVED = exports.RECEIVED = 'presence:change';

/**
 * The user's self presence information has changed.
 *
 * @public
 * @memberof Presence
 * @requires presence
 * @event presence:selfChange
 */
const SELF_CHANGE = exports.SELF_CHANGE = 'presence:selfChange';

/**
 * An error occured with presence.
 *
 * @public
 * @memberof Presence
 * @requires presence
 * @event presence:error
 * @param {Object} params
 * @param {BasicError} params.error The Basic error object.
 */
const ERROR = exports.ERROR = 'presence:error';

/***/ }),

/***/ "./src/presence/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/presence/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventTypes = __webpack_require__("./src/presence/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Helper function for error events.
function presenceError(action) {
  if (action.error) {
    return {
      type: eventTypes.ERROR,
      args: { error: action.payload }
    };
  }
}

const eventsMap = {};

eventsMap[actionTypes.RECEIVED] = action => ({
  type: eventTypes.RECEIVED,
  args: {
    userId: action.payload.userId,
    status: action.payload.status,
    activity: action.payload.activity,
    note: action.payload.note
  }
});

eventsMap[actionTypes.UPDATE_FINISH] = action => {
  if (action.error) {
    return presenceError(action);
  } else {
    return {
      type: eventTypes.SELF_CHANGE
    };
  }
};

// TODO: Should have events to notifiy of successful operations for these actions.
eventsMap[actionTypes.GET_FINISH] = presenceError;
eventsMap[actionTypes.SUBSCRIBE_FINISH] = presenceError;
eventsMap[actionTypes.UNSUBSCRIBE_FINISH] = presenceError;
eventsMap[actionTypes.CREATE_PRESENCE_LIST_FINISH] = presenceError;

exports.default = eventsMap;

/***/ }),

/***/ "./src/presence/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/presence/interface/api.js");

Object.defineProperty(exports, 'api', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_api).default;
  }
});

var _reducers = __webpack_require__("./src/presence/interface/reducers.js");

Object.defineProperty(exports, 'reducer', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_reducers).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/presence/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/presence/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries
const reducers = {};

reducers[actionTypes.UPDATE] = {
  next(state) {
    return (0, _extends3.default)({}, state, {
      self: (0, _extends3.default)({}, state.self, {
        loading: true,
        error: false
      })
    });
  }
};

reducers[actionTypes.UPDATE_FINISH] = {
  next(state, action) {
    let result = (0, _extends3.default)({}, state, {
      self: {
        loading: false,
        error: false,
        status: action.payload.status,
        activity: action.payload.activity
      }
    });
    if (action.payload.note) {
      result.self.note = action.payload.note;
    }
    return result;
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      self: (0, _extends3.default)({}, state.self, {
        loading: false,
        error: action.payload
      })
    });
  }
};

reducers[actionTypes.GET] = {
  next(state, { payload: userIds }) {
    const users = (0, _extends3.default)({}, state.users);
    for (let userId of userIds) {
      users[userId] = {
        userId,
        loading: true
      };
    }
    return (0, _extends3.default)({}, state, { users });
  }
};

reducers[actionTypes.GET_FINISH] = {
  next(state, { payload }) {
    if (!payload.presenceContact) {
      return (0, _extends3.default)({}, state);
    }

    let users = {};
    for (let contact of payload.presenceContact) {
      let presenceObject = {};
      presenceObject.userId = contact.presentityUserId;
      presenceObject.activity = contact.presence.person.activities.activityValue;
      presenceObject.status = contact.presence.person['overriding-willingness'].overridingWillingnessValue;
      presenceObject.note = contact.presence.person.activities.other;
      presenceObject.loading = false;
      users[contact.presentityUserId] = presenceObject;
    }
    return (0, _extends3.default)({}, state, {
      users: (0, _extends3.default)({}, state.users, users)
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state);
  }
};

reducers[actionTypes.RECEIVED] = {
  next(state, { payload }) {
    return (0, _extends3.default)({}, state, {
      users: (0, _extends3.default)({}, state.users, {
        [payload.userId]: {
          userId: payload.userId, // optimize for filtering by userId
          status: payload.status,
          activity: payload.activity,
          note: payload.note,
          loading: false
        }
      })
    });
  }
};

reducers[actionTypes.UNSUBSCRIBE_FINISH] = {
  next(state, { payload }) {
    return (0, _extends3.default)({}, state, {
      users: (0, _fp.omit)(payload, state.users)
    });
  }
};

const reducer = (0, _reduxActions.handleActions)(reducers, { self: {}, users: {} });
exports.default = reducer;

/***/ }),

/***/ "./src/presence/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__("../../node_modules/babel-runtime/core-js/object/values.js");

var _values2 = _interopRequireDefault(_values);

exports.getPresence = getPresence;
exports.getAllPresence = getAllPresence;
exports.getSelfPresence = getSelfPresence;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getPresence(state, users) {
  // If no users specified, return them all
  if (!users) {
    return state.presence.users;
  }

  // Grab all users that match the passed in IDs, return
  return (0, _values2.default)(state.presence.users).filter(user => users.indexOf(user.userId) !== -1);
}

/**
 * Retrieves presence information for all users.
 * @method getAllPresence
 * @param  {Object} state Redux state.
 * @return {Array}  List of presence information for users.
 */
function getAllPresence(state) {
  return (0, _values2.default)(state.presence.users);
}

/**
 * Retrieves the current user's self presence.
 * @method getSelfPresence
 * @param  {Object} state Redux state.
 * @return {Object} Self-presence information.
 */
function getSelfPresence(state) {
  return state.presence.self;
}

/***/ }),

/***/ "./src/request/effects.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = request;
exports.requestSaga = requestSaga;

var _actionTypes = __webpack_require__("./src/request/interface/actionTypes.js");

var _actions = __webpack_require__("./src/request/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _utils = __webpack_require__("./src/common/utils.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Creates an effect description that instructs the middleware to perform a request with the provided options.
 * This effect is blocking and will yield a RESPONSE action on completion.
 *
 * @param {Object} options See https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
 * @param {string} options.url The url to perform the request on.
 * @param {string} options.method The HTTP method to use for the request.
 * @param {Object} options.headers Object literal of headers you want to add to the request.
 * @param {Object} [options.queryParams] The parameters to be added to the query string
 * @param {string} [options.responseType] The data type assumed to be received in the response body
 * @param {Blob|BufferSource|FormData|UrlSearchParams|string} [options.body] Any body that you want to add to your request.
 * @return A blocking redux-saga effect that will instruct the middleware to wait for the request to be fullfilled or until it fails.
 */
function request(options, commonOptions) {
  return (0, _effects.call)(requestSaga, options, commonOptions);
}

/*
 * The saga backing the request effect.
 */


// Libraries.
// Requests plugin.
function* requestSaga(options, commonOptions) {
  // Merge any extra request options into the provided options
  //      for this request. Priority is for the passed-in options.
  options = (0, _utils.mergeValues)(commonOptions, options);

  const requestAction = yield (0, _effects.put)(actions.request(options));
  const responseAction = yield (0, _effects.take)(action => action.type === _actionTypes.RESPONSE && (0, _fp.get)('meta.requestId', action) === requestAction.meta.requestId);

  return responseAction;
}

/***/ }),

/***/ "./src/request/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__testonly__ = undefined;

var _objectWithoutProperties2 = __webpack_require__("../../node_modules/babel-runtime/helpers/objectWithoutProperties.js");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _freeze = __webpack_require__("../../node_modules/babel-runtime/core-js/object/freeze.js");

var _freeze2 = _interopRequireDefault(_freeze);

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = request;

var _actionTypes = __webpack_require__("./src/request/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actions = __webpack_require__("./src/request/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fetchPonyfill = __webpack_require__("../../node_modules/fetch-ponyfill/build/fetch-browser.js");

var _fetchPonyfill2 = _interopRequireDefault(_fetchPonyfill);

var _utils = __webpack_require__("./src/common/utils.js");

var _logs = __webpack_require__("./src/logs/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { fetch } = (0, _fetchPonyfill2.default)({ Promise: _promise2.default });
const log = (0, _logs.getLogManager)().getLogger('REQUEST');

/**
 * Enum declaring the valid request response data types that are available to be handled
 */
const responseTypes = (0, _freeze2.default)({
  json: 'json',
  blob: 'blob'
});

/*
 * HTTP request plugin.
 */
function request() {
  return {
    sagas: [watchRequests],
    name: 'requests'
  };
}

/*
 * Saga to watch for every request action.
 */
function* watchRequests() {
  yield (0, _effects.takeEvery)(actionTypes.REQUEST, handleRequest);
}

/*
 * Generator that handles a request action with standard HTTP handling features and reports
 * a requestFinished action when the request is done.
 *
 * @param {FluxStandardAction} action The action to handle.
 */
function* handleRequest(action) {
  // Make the request based on the action
  var result = yield (0, _effects.call)(makeRequest, action.payload, action.meta.requestId);
  yield (0, _effects.put)(actions.response(action.meta.requestId, result, !!result.error));
}

/**
 * Make a request with the specified options. The options is very similar to the options passed to the GlobalFetch
 * method except that is also accepts the url as part of the options.
 *
 * Currently this processes the request and assumes nothing about the response.
 * - If the response has a body, it will always be parsed and forwarded on.
 *      - If no body, then an empty object in its place.
 * - If the fetch succeded, the response "results" will always be forwarded on,
 *      even if the response is outside of the 200-299 range.
 *      - Because some backends provide more detailed error info (that a saga
 *        may need) as part of the body, rather than just the response status.
 *
 * @param {Object} options Options to make the request with.
 * @param {string} options.url The URL to make the request to.
 * @param {Object} [options.queryParams] The parameters to be added to the query string
 * @param {string} [options.responseType] The data type assumed to be received in the response body
 * @param {Blob|BufferSource|FormData|UrlSearchParams|string} [options.body] The request body
 * @return {Promise} A promise that resolves with a custom response object.
 */
async function makeRequest(options, requestId) {
  // Extract and remove the url property.
  const { url, queryParams, responseType = 'json' } = options,
        fetchOptions = (0, _objectWithoutProperties3.default)(options, ['url', 'queryParams', 'responseType']);

  if (!responseTypes.hasOwnProperty(responseType)) {
    // Invalid data type requested
    log.debug('responseType value was invalid');
    return {
      body: undefined,
      error: 'RESPONSE_TYPE',
      message: 'Requested invalid data type for response'
    };
  }
  let response;
  try {
    response = await fetch(url + (0, _utils.toQueryString)(queryParams), fetchOptions);
  } catch (err) {
    log.debug(`Fetch request ${requestId} failed: ${err.message}.`);
    return {
      body: false,
      error: 'FETCH',
      result: {
        ok: false,
        code: err.name,
        message: err.message
      }
    };
  }
  try {
    let result = {
      ok: response.ok,
      code: response.status,
      message: response.statusText
    };
    let responseBody;
    let error = !response.ok;

    if (error) {
      // If the response indicates an error, resolve the body as JSON and return a `REQUEST` error
      log.debug(`Response indicates that request ${requestId} failed`);
      responseBody = await response.json();
      return {
        body: responseBody,
        error: 'REQUEST',
        result
      };
    } else {
      if (responseType === responseTypes.json) {
        responseBody = await response.json();
      } else {
        // `blob` is the only other possible value for responseType
        responseBody = await response.blob();
      }
      return {
        body: responseBody,
        error: false,
        result
      };
    }
  } catch (err) {
    log.debug(`Error parsing response. Response for request ${requestId}: "${err.message}"`);
    return {
      body: false,
      error: 'REQUEST',
      result: {
        ok: false,
        code: err.name,
        message: err.message
      }
    };
  }
}

// begin-test-code
const __testonly__ = exports.__testonly__ = { makeRequest, watchRequests, handleRequest
  // end-test-code

};

/***/ }),

/***/ "./src/request/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const PREFIX = '@@KANDY/';

const REQUEST = exports.REQUEST = PREFIX + 'REQUEST';
const RESPONSE = exports.RESPONSE = PREFIX + 'RESPONSE';

/***/ }),

/***/ "./src/request/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.request = request;
exports.response = response;

var _actionTypes = __webpack_require__("./src/request/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var nextRequestId = 0;
function generateRequestId() {
  return nextRequestId++;
}

/**
 * Creates a request action.
 * @param {Object} options
 * @param {string} options.url The url for the request
 * @param {Object} [options.queryParams] Query parameters to be added to the url string
 * @param {string} [options.responseType] The data type assumed to be received in the response body
 * @param {Blob|BufferSource|FormData|UrlSearchParams|string} [options.body] The request body
 */
function request(options) {
  return {
    type: actionTypes.REQUEST,
    payload: options,
    meta: {
      requestId: generateRequestId()
    }
  };
}

/**
 * Creates a response action.
 */
function response(requestId, result, error = false) {
  return {
    type: actionTypes.RESPONSE,
    payload: result,
    error,
    meta: {
      requestId: requestId
    }
  };
}

/***/ }),

/***/ "./src/subscription/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSubcriptionPlugin;

var _interface = __webpack_require__("./src/subscription/interface/index.js");

var _events = __webpack_require__("./src/subscription/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _sagas = __webpack_require__("./src/subscription/cpaas2/sagas/index.js");

var _actions = __webpack_require__("./src/config/interface/actions.js");

var _actions2 = __webpack_require__("./src/events/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _utils = __webpack_require__("./src/common/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Configuration options for the Subscription feature.
 * @public
 * @name config.subscription
 * @memberof config
 * @instance
 * @param {Object} subscription Subscription configs.
 * @param {number} [subscription.channelLifetime=3600] The amount of time (in seconds) for which to keep subscription channels up and alive.
 * @param {number} [subscription.timeout=20] The amount of time (in seconds) allowed for the subscription/unsubscription process to take place before timing out.
 */

/**
 * CPaaS subscription implementation factory.
 * @method subscriptionCpaas
 * @param {Object} options - Configuration options for subscription. See above.
 * @return {Object} plugin - A subscription plugin.
 */


// Libraries.


// Other plugins.
function createSubcriptionPlugin(options = {}) {
  const defaultOptions = {
    channelLifetime: 3600, // sec
    timeout: 20 // sec
  };

  options = (0, _utils.mergeValues)(defaultOptions, options);

  function* init() {
    // Send the provided options to the store.
    // This will be `state.config[name]`.
    yield (0, _effects.put)((0, _actions.update)(options, _interface.name));
    yield (0, _effects.put)((0, _actions2.mapEvents)(_events2.default));
  }

  return {
    sagas: [_sagas.subscriptionFlow, _sagas.onConnectionLostEntry],
    init,
    api: _interface.api,
    reducer: _interface.reducer,
    name: _interface.name
  };
}

// Helpers.
// Subscription plugin.

/***/ }),

/***/ "./src/subscription/cpaas2/requests.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.requestWebsocket = requestWebsocket;
exports.deleteChannel = deleteChannel;
exports.revokeWebsocket = revokeWebsocket;
exports.refreshWebsocket = refreshWebsocket;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _logs = __webpack_require__("./src/logs/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logs.getLogManager)().getLogger('AUTH');

/**
 * This function requests a websocket to connect to the backend.
 * @method requestWebsocket
 * @param  {Object}    requestInfo
 * @param  {Object}    subscriptionInfo
 * @return {Object} Returns an object containing the websocket connection information, most importantly a URL to connect to a websocket.
 */

// Other plugins.
function* requestWebsocket(requestInfo, subscriptionInfo, connectivityInfo) {
  const req = {};
  req.method = 'POST';
  req.url = `${requestInfo.baseURL}/cpaas/notificationchannel/${requestInfo.version}/${requestInfo.username}/channels`;
  req.body = (0, _stringify2.default)({
    notificationChannel: {
      channelLifetime: subscriptionInfo.expires,
      channelType: 'Websockets',
      clientCorrelator: requestInfo.clientCorrelator,
      'x-connCheckRole': connectivityInfo.method.responsibleParty
    }
  });

  const response = yield (0, _effects2.default)(req, requestInfo.options);

  if (response.error) {
    if (response.payload.body) {
      log.debug('Websocket request failed.', response.payload.body);
      // Handle errors from the server.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Failed to retrieve a websocket.',
          code: _errors.subscriptionCodes.CPAAS2_WSREQUEST_FAIL
        })
      };
    } else {
      log.debug('Failed requesting a websocket.', response.payload.result.message);
      // Handle errors from the request plugin.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Retrieve websocket request failed.',
          // TODO: Shared error codes.
          code: _errors.subscriptionCodes.CPAAS2_WSREQUEST_FAIL
        })
      };
    }
  } else {
    // Request was successful.
    return (0, _extends3.default)({
      error: false
    }, response.payload.body);
  }
}
/**
 * Request to delete a specified notification channel.
 * @method deleteChannel
 * @param  {string} channelId The ID of the channel to delete.
 * @param  {Object} requestInfo
 * @return {Object}
 */
function* deleteChannel(channelId, requestInfo) {
  const requestOptions = {};
  requestOptions.method = 'DELETE';
  requestOptions.url = `${requestInfo.baseURL}` + `/cpaas/notificationchannel/${requestInfo.version}/${requestInfo.username}` + `/channels/${channelId}`;

  const response = yield (0, _effects2.default)(requestOptions, requestInfo.options);

  if (response.error) {
    if (response.payload.body) {
      // Handle errors from the server.
      // TODO: Better error; more info.
      return {
        error: new _errors2.default({
          message: 'Failed to delete notification channel.',
          code: _errors.subscriptionCodes.CPAAS2_UNSUBSCRIBE_FAIL
        })
      };
    } else {
      // Handle errors from the request helper.
      // TODO: Better error; more info.
      return {
        error: new _errors2.default({
          message: 'Delete channel request failed',
          code: _errors.subscriptionCodes.CPAAS2_UNSUBSCRIBE_FAIL
        })
      };
    }
  } else {
    // Request was successful.
    return (0, _extends3.default)({
      error: false
    }, response.payload.body);
  }
}

/**
 * Revoke a websocket connection.
 * @method revokeWebsocket
 * @param  {Object}    connection Server information for the service in use.
 * @param  {string}    connection.server Server information for generating the URL.
 * @param  {string}    connection.requestOptions Common request options to be added.
 * @param  {string}    subscriptionURL URL of the user's websocket instance.
 * @return {Object}    Revoke websocket response.
 */
function* revokeWebsocket(connection, subscriptionURL, credentials) {
  // Build the revokeWebsocket request.
  let requestOptions = {};
  requestOptions.method = 'DELETE';

  requestOptions.url = `${connection.server.protocol}://${connection.server.server}:${connection.server.port}` + subscriptionURL;

  requestOptions.headers = {
    Accept: 'application/json',
    'Content-Type': 'application/json',
    Authorization: `Bearer ${credentials.accessToken}`

    // Send the revokeWebsocket request.
  };const response = yield (0, _effects2.default)(requestOptions);

  // Handle the response and any possible errors.
  if (response.error) {
    if (response.payload.body) {
      // Handle errors from the server.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Failed to revoke websocket.',
          code: _errors.subscriptionCodes.CPAAS2_WSREVOKE_FAIL
        })
      };
    } else {
      // Handle errors from the request helper.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Revoke websocket request failed.',
          // TODO: Shared error codes.
          code: _errors.subscriptionCodes.CPAAS2_WSREVOKE_FAIL
        })
      };
    }
  } else {
    // Request was successful.
    return {
      error: false
    };
  }
}

/**
 * CPaaS 2.0 refreshWebsocket. All this call does is ask the backend to extend the lifetime
 * of the websocket.
 * @method refreshWebsocket
 * @param  {Object}    connection Server information for the service in use.
 * @param  {string}    connection.server Server information for generating the URL.
 * @param  {string}    connection.requestOptions Common request options to be added.
 * @param  {Object}    subscription Information about the subscription instance.
 * @param  {string}    subscription.expires - The time (in seconds) until subscription expiry.
 * @param  {Array}     subscription.service - The services to resubscribe to.
 * @param  {Array}     subscription.url - The URL of the user's subscription instance.
 * @return {Object}    Resubscription response.
 */
function* refreshWebsocket(connection, subscription, credentials) {
  let requestOptions = {};
  requestOptions.method = 'PUT';

  requestOptions.url = `${connection.server.protocol}://${connection.server.server}:${connection.server.port}` + subscription.url + '/channelLifetime';

  requestOptions.headers = {
    Accept: 'application/json',
    'Content-Type': 'application/json',
    Authorization: `Bearer ${credentials.accessToken}`
  };

  requestOptions.body = (0, _stringify2.default)({
    notificationChannelLifetime: {
      channelLifetime: subscription.channelLifetime
    }
  });

  const response = yield (0, _effects2.default)(requestOptions);

  if (response.error) {
    if (response.payload.body) {
      // Handle errors from the server.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Failed to refresh websocket connection.',
          code: _errors.subscriptionCodes.CPAAS2_WSREFRESH_FAIL
        })
      };
    } else {
      // Handle errors from the request helper.
      return {
        // TODO: Better error; more info.
        error: new _errors2.default({
          message: 'Refresh websocket request failed.',
          // TODO: Shared error codes.
          code: _errors.subscriptionCodes.CPAAS2_WSREFRESH_FAIL
        })
      };
    }
  } else {
    // Request was successful.
    const extendResponse = response.payload.body;
    log.debug('Websocket lifetime extended.');

    // Success.
    return (0, _extends3.default)({
      error: false
    }, extendResponse);
  }
}

/***/ }),

/***/ "./src/subscription/cpaas2/sagas/channels.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.ensureChannelOpen = ensureChannelOpen;
exports.openWebsocketChannel = openWebsocketChannel;
exports.closeChannel = closeChannel;

var _requests = __webpack_require__("./src/subscription/cpaas2/requests.js");

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/subscription/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _effects = __webpack_require__("./src/connectivity/interface/effects.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _selectors3 = __webpack_require__("./src/connectivity/interface/selectors.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _constants = __webpack_require__("./src/constants.js");

var _effects2 = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Subscription plugin.
const platform = _constants.platforms.CPAAS2;

// Libraries.

// Helpers.


// Other plugins.

const log = (0, _logs.getLogManager)().getLogger('SUBSCRIPTION');

/**
 * Ensures that a notification channel of `type` is open.
 * If already open, does nothing. If not open, requests/opens it.
 * @method ensureChannel
 * @param {string} type The type of notification channel.
 */
function* ensureChannelOpen(type) {
  /**
   * Assumed format of the subInfo object:
   * @param {Object} subInfo
   * @param {Object} subInfo.notificationChannels A mapping of types to the channel info.
   * @param {Array} subInfo.subscriptions A list of active subscriptions.
   */
  const subInfo = yield (0, _effects2.select)(_selectors.getNotificationChannels);

  // If there is no open notification channel for `type`, request it.
  if (!subInfo.notificationChannels[type]) {
    let channelResponse;
    if (type === _constants.notificationTypes.WEBSOCKET) {
      channelResponse = yield (0, _effects2.call)(openWebsocketChannel, platform);
    } else if (type === _constants.notificationTypes.PUSH) {
      // TODO: CPaaS 2.0 Push subscription here.
    } else {
        // Bad scenario.
      }

    if (channelResponse.error) {
      // Error scenario: Could not open websocket channel.
      return false;
    }

    // Save newly opened channel info in state.
    yield (0, _effects2.put)(actions.channelOpened((0, _extends3.default)({}, channelResponse.notificationChannel, {
      channelId: channelResponse.notificationChannel.resourceURL.split('/channels/')[1]
    }), type));
    return true;
  } else {
    // If there is already a channel, use it.
    return true;
  }
}

/**
 * This wsSubscribe function makes a request to the CPAAS gateway for a subscription.
 * If successful it triggers a subscribeFinished action containing subscription information.
 * @method openWebsocketChannel
 */
function* openWebsocketChannel(platform) {
  const requestInfo = yield (0, _effects2.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);
  const subscriptionInfo = yield (0, _effects2.select)(_selectors.getSubscriptionConfig);
  const connectivityInfo = yield (0, _effects2.select)(_selectors3.getConnectivityConfig);

  // Request a websocket to subscribe to.
  const response = yield (0, _effects2.call)(_requests.requestWebsocket, requestInfo, subscriptionInfo, connectivityInfo);

  if (response.error) {
    return response;
  }

  const subscription = (0, _extends3.default)({}, response.notificationChannel, {
    service: 'CPaaS2',
    url: response.notificationChannel.channelData.channelURL
  });

  const connectionInfo = yield (0, _effects2.select)(_selectors2.getAuthConfig);
  // Format the response to pass off to the connectivity plugin.
  const websocketInfo = {
    protocol: 'wss',
    server: connectionInfo.server.base,
    port: connectionInfo.server.port,
    url: subscription.url,
    params: {
      access_token: requestInfo.token
    }

    // Request the websocket connection.
  };const wsOpenOrError = yield (0, _effects.connectWebsocket)(websocketInfo, platform);

  if (wsOpenOrError.error) {
    // TODO: the connectivity plugin should be creating (and passing on) the websocket errors.
    throw new _errors2.default({
      message: 'Failed to connect to the websocket.',
      code: _errors.subscriptionCodes.WS_CONNECTION_ERROR
    });
  } else {
    // We're connected. Finish subscription process.
    // TODO: Once auth is complete, fill the data.
    return {
      // We will only ever have one of each notificationChannel type. So this should be the only websocket channel in state.
      notificationChannel: response.notificationChannel,
      type: _constants.notificationTypes.WEBSOCKET
    };
  }
}
/**
 * Close the specified channel by cleaning up its resources then deleting it.
 * @method closeChannel
 * @param  {Object} channel Information about the channel to be closed.
 * @param  {string} platform
 * @return {Object}
 */
function* closeChannel(channel, platform) {
  const { channelId, channelType } = channel;

  // TODO: Don't hardcode a constant.
  if (channelType === 'websockets') {
    // Ask the connectivity plugin to disconnect this platform's websocket if it exists
    const wsState = yield (0, _effects2.select)(_selectors3.getConnectionState, platform);
    if (wsState.connected) {
      const closeAction = yield (0, _effects.disconnectWebsocket)(undefined, platform);

      if (closeAction.error) {
        log.debug('Failed to close websocket. Continuing anyway.');
      }
    }

    const requestInfo = yield (0, _effects2.select)(_selectors2.getRequestInfo, _constants.platforms.CPAAS2);

    // Delete the notification channel resource.
    const response = yield (0, _effects2.call)(_requests.deleteChannel, channelId, requestInfo);
    return response;
  } else {
    // TODO: Handle closing other channel types.
  }
}

/***/ }),

/***/ "./src/subscription/cpaas2/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscriptionFlow = subscriptionFlow;
exports.refreshWebsocketSaga = refreshWebsocketSaga;
exports.onConnectionLostEntry = onConnectionLostEntry;
exports.onConnectionLost = onConnectionLost;

var _actionTypes = __webpack_require__("./src/subscription/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _channels = __webpack_require__("./src/subscription/cpaas2/sagas/channels.js");

var _requests = __webpack_require__("./src/subscription/cpaas2/requests.js");

var _selectors = __webpack_require__("./src/subscription/interface/selectors.js");

var _actionTypes2 = __webpack_require__("./src/connectivity/interface/actionTypes.js");

var connectivityActionTypes = _interopRequireWildcard(_actionTypes2);

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _effects = __webpack_require__("./src/common/effects/index.js");

var _effects2 = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Helpers.


// Other plugins
const platform = _constants.platforms.CPAAS2;

// Constants


// Libraries.
// Subscription plugin.

const log = (0, _logs.getLogManager)().getLogger('SUBSCRIPTION');

/**
 * Entry point for ALL subscription change actions.
 * Queues all subscription changes (ie. subscribe, unsubscribe) to avoid async
 * scenarios. This ensures channels and subscriptions are not duplicated
 * and that resources are created/clean-up when needed.
 * @method subscriptionFlow
 */
function* subscriptionFlow() {
  // Use a channel to queue ALL subscription change requests.
  const subscriptionChannel = yield (0, _effects2.actionChannel)([actionTypes.SUBSCRIBE, actionTypes.UNSUBSCRIBE]);

  while (true) {
    const action = yield (0, _effects2.take)(subscriptionChannel);

    // Handle the action appropriately.
    if (action.type === actionTypes.SUBSCRIBE) {
      if (!action.payload.services || action.payload.services.length === 0) {
        // Error scenario: No services specified.
        // TODO: Better error.
        yield (0, _effects2.put)(actions.subscribeFinished({ error: true }));
        continue;
      }

      // Open the notification channel if it isn't already.
      const hasChannel = yield (0, _effects2.call)(_channels.ensureChannelOpen, action.payload.type);
      if (!hasChannel) {
        // Error scenario: Could not open channel.
        // TODO: Better error.
        yield (0, _effects2.put)(actions.subscribeFinished({ error: true }));
        continue;
      }

      // Subscribe to the services and retrieve a list of their responses.
      const subResponses = yield (0, _effects2.call)(subscribeForServices, action);

      // Report that the subscription flow has finished.
      if (subResponses.error) {
        yield (0, _effects2.put)(actions.subscribeFinished({
          error: subResponses.error,
          type: action.payload.type
        }));
      } else {
        yield (0, _effects2.put)(actions.subscribeFinished({
          subscriptions: subResponses,
          type: action.payload.type
        }));
      }
    } else {
      // TODO: How to do a "unsubscribe all" services?
      // ie. not need the application to specify them all individually.
      // Might be simpler for the API to be sub/unsub(type, services).

      // Unsubscribe the services.
      const unsubResponses = yield (0, _effects2.call)(unsubscribeServices, action);

      if (unsubResponses.error) {
        yield (0, _effects2.put)(actions.unsubscribeFinished({
          error: unsubResponses.error,
          type: action.payload.type
        }));
        continue;
      }

      const connectionInfo = yield (0, _effects2.select)(_selectors2.getConnectionInfo, platform);
      const subscribedServices = yield (0, _effects2.select)(_selectors.getSubscribedServices, action.payload.type);

      // if we're not connected or connection info is not available, unsub from all services.
      if ((0, _fp.isUndefined)(connectionInfo)) {
        yield (0, _effects2.put)(actions.unsubscribeFinished({
          unsubscriptions: subscribedServices,
          type: action.payload.type
        }));
        continue;
      }

      // Get the channel information of the channel to be closed.
      const { notificationChannels } = yield (0, _effects2.select)(_selectors.getNotificationChannels);
      const channel = notificationChannels[action.payload.type];

      // If there are no longer any subscribed services for this channel (and
      //    the channel is open), close it.
      if (subscribedServices.length === 0 && channel) {
        const closeResponse = yield (0, _effects2.call)(_channels.closeChannel, channel, platform);

        if (closeResponse.error) {
          // TODO: Error scenario?
        } else {
          // TODO: Parameters.
          yield (0, _effects2.put)(actions.channelClosed(action.payload.type));
        }
      }

      // Report that the unsubscription flow has finished.
      yield (0, _effects2.put)(actions.unsubscribeFinished({
        unsubscriptions: unsubResponses,
        type: action.payload.type
      }));
    }
  }
}

/**
 * This function handles the flow of subscribing for CPaaS 2 services.
 * This means it dispatches a command action to tell other plugins to subscribe.
 * Once all plugins have done their subscription (if they need one), we return
 * the subscription response information.
 * @method subscribeForServices
 * @param  {Object} action A subscription action.
 * @return {Object}
 */
function* subscribeForServices(action) {
  const registeredServices = yield (0, _effects2.select)(_selectors.getRegisteredServices);

  // Get the list of services that were requested, but plugins did not register.
  const notRegistered = (0, _fp.difference)(registeredServices, action.payload.services);
  if (notRegistered.length > 0) {
    log.debug(`Not registered for requested services: ${notRegistered}.`);
  }

  // TODO: Don't allow subscribing for services with existing subscription.
  // Get the list of services that were requested, and plugins did register.
  const validServices = (0, _fp.intersection)(registeredServices, action.payload.services);
  log.info(`Requesting subscriptions for services: ${validServices}.`);

  if (validServices.length === 0) {
    // TODO: Proper error / return.
    return {
      error: new _errors2.default({
        message: 'No valid services to subscribe provided.',
        // TODO: Proper error code.
        code: 'BAD_INPUT'
      })
    };
  }

  const subscriptionConfig = yield (0, _effects2.select)(_selectors.getSubscriptionConfig, platform);

  // Announce to all plugins that subscriptions should happen.
  yield (0, _effects2.put)(actions.doPluginSubscriptions(validServices, action.payload.type));

  // What we're waiting for.
  const waitPatterns = validServices.map(service => action => action.type === actionTypes.PLUGIN_SUBSCRIPTION_FINISHED && action.payload.service === service);

  // Wait for a response from each plugin.
  const { results } = yield (0, _effects.waitFor)(subscriptionConfig.timeout * 1000, waitPatterns);

  // TODO: Would it be better to handle partial results here?
  return (0, _fp.compact)(results);
}

/**
 * This function handles the flow of unsubscribing for CPaaS 2 services.
 * This means it dispatches a command action to tell other plugins to unsubscribe.
 * Once all plugins have done their unsubscription (if they need one), we return
 * the unsubscription response information.
 * The logic in this saga is a copy from the `subscribeForServices` saga.
 * @method unsubscribeServices
 * @param  {Object} action An unsubscription action.
 * @return {Object}
 */
function* unsubscribeServices(action) {
  const subscribedServices = yield (0, _effects2.select)(_selectors.getSubscribedServices, action.payload.type);

  // Get the list of services we want to unsubscribe, but aren't subscribed.
  const notSubscribed = action.payload.services.filter(service => {
    return subscribedServices.indexOf(service) === -1;
  });
  if (notSubscribed.length > 0) {
    log.debug(`Not subscribed for services for unsubscription: ${notSubscribed}.`);
  }

  // Get the list of subscribed services we want to unsubscribe.
  const validServices = (0, _fp.intersection)(subscribedServices, action.payload.services);
  log.info(`Unsubscribing from services: ${validServices}.`);

  if (validServices.length === 0) {
    // TODO: Proper error / return.
    return {
      error: new _errors2.default({
        message: 'No valid services to subscribe provided.',
        // TODO: Proper error code.
        code: 'BAD_INPUT'
      })
    };
  }

  const subscriptionConfig = yield (0, _effects2.select)(_selectors.getSubscriptionConfig, platform);

  // Announce to all plugins that unsubscriptions should happen
  yield (0, _effects2.put)(actions.doPluginUnsubscriptions(validServices, action.payload.type));

  // What we're waiting for.
  const waitPatterns = validServices.map(service => action => action.type === actionTypes.PLUGIN_UNSUBSCRIPTION_FINISHED && action.payload.service === service);

  // Wait for a response from each plugin.
  const { results } = yield (0, _effects.waitFor)(subscriptionConfig.timeout * 1000, waitPatterns);

  // TODO: Would it be better to handle partial results here?
  return (0, _fp.compact)(results);
}

/**
 * Saga for extending a websocket subscription.
 * When triggered, make a resub request to CPaaS.
 * @method refreshWebsocketSaga
 */
function* refreshWebsocketSaga() {
  const resubTriggers = yield (0, _effects2.actionChannel)([actionTypes.SUBSCRIBE_FINISHED, actionTypes.RESUBSCRIPTION_FINISHED]);
  while (true) {
    const action = yield (0, _effects2.take)(resubTriggers);

    // If the action was an error, ignore it.
    if (action.error) {
      continue;
    }

    const subscription = yield (0, _effects2.select)(_selectors2.getSubscriptionInfo, platform);

    const resubDelay = subscription.channelLifetime * 1000 / 2;

    // Wait for either the resub delay or a unsubscribe action.
    const { expiry } = yield (0, _effects2.race)({
      expiry: (0, _effects2.delay)(resubDelay),
      unsubscribe: (0, _effects2.take)(actionTypes.UNSUBSCRIBE_FINISHED)
    });

    // If the resubDelay has elapsed, resubscribe.
    if (expiry) {
      log.info('Extending user subscription.');
      const connection = yield (0, _effects2.select)(_selectors2.getConnectionInfo, platform);
      const subscription = yield (0, _effects2.select)(_selectors2.getSubscriptionInfo, platform);
      const credentials = yield (0, _effects2.select)(_selectors2.getUserInfo);

      const response = yield (0, _effects2.call)(_requests.refreshWebsocket, connection, subscription, credentials);

      if (response.error) {
        yield (0, _effects2.put)(actions.resubscribeFinished(response, platform));
      } else {
        yield (0, _effects2.put)(actions.resubscribeFinished({}, platform));
      }
    }
  }
}

/**
 * Triggers onConnectionLost saga when a WS_RECONNECT_FAILED actionType occurs
 * @method onConnectionLostEntry
 */
function* onConnectionLostEntry() {
  yield (0, _effects2.takeEvery)(connectivityActionTypes.WS_RECONNECT_FAILED, onConnectionLost);
}

/**
 * Handles lost connections from the connectivity plugin
 * @method onConnectionLost
 */
function* onConnectionLost() {
  const subscribedServices = yield (0, _effects2.select)(_selectors.getSubscribedServices);
  yield (0, _effects2.put)(actions.unsubscribe(subscribedServices));
}

/***/ }),

/***/ "./src/subscription/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/';

const SUBSCRIBE = exports.SUBSCRIBE = prefix + 'SUBSCRIBE';
const SUBSCRIBE_FINISHED = exports.SUBSCRIBE_FINISHED = prefix + 'SUBSCRIBE_FINISHED';

const UNSUBSCRIBE = exports.UNSUBSCRIBE = prefix + 'UNSUBSCRIBE';
const UNSUBSCRIBE_FINISHED = exports.UNSUBSCRIBE_FINISHED = prefix + 'UNSUBSCRIBE_FINISHED';

const REGISTER_SUB_SERVICE = exports.REGISTER_SUB_SERVICE = prefix + 'REGISTER_SUB_SERVICE';
const PLUGIN_SUBSCRIPTION = exports.PLUGIN_SUBSCRIPTION = prefix + 'PLUGIN_SUBSCRIPTION';
const PLUGIN_SUBSCRIPTION_FINISHED = exports.PLUGIN_SUBSCRIPTION_FINISHED = prefix + 'PLUGIN_SUBSCRIPTION_FINISHED';
const PLUGIN_UNSUBSCRIPTION = exports.PLUGIN_UNSUBSCRIPTION = prefix + 'PLUGIN_UNSUBSCRIPTION';
const PLUGIN_UNSUBSCRIPTION_FINISHED = exports.PLUGIN_UNSUBSCRIPTION_FINISHED = prefix + 'PLUGIN_UNSUBSCRIPTION_FINISHED';

const CHANNEL_OPENED = exports.CHANNEL_OPENED = prefix + 'CHANNEL_OPENED';
const CHANNEL_CLOSED = exports.CHANNEL_CLOSED = prefix + 'CHANNEL_CLOSED';

/***/ }),

/***/ "./src/subscription/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.subscribe = subscribe;
exports.subscribeFinished = subscribeFinished;
exports.unsubscribe = unsubscribe;
exports.unsubscribeFinished = unsubscribeFinished;
exports.registerService = registerService;
exports.doPluginSubscriptions = doPluginSubscriptions;
exports.reportSubscriptionFinished = reportSubscriptionFinished;
exports.doPluginUnsubscriptions = doPluginUnsubscriptions;
exports.reportUnsubscriptionFinished = reportUnsubscriptionFinished;
exports.channelOpened = channelOpened;
exports.channelClosed = channelClosed;

var _actionTypes = __webpack_require__("./src/subscription/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper function for formatting actions.
 * Ensures that actions follow an expectable format.
 * @method actionFormatter
 * @param  {string}  actionType   [description]
 * @param  {Object} [payload={}] The action payload.
 * @param  {BasicError} [payload.error] For an error action, the error should be provided.
 * @param  {Object} [meta={}] The action meta data.
 * @return {Object}
 */
function actionFormatter(actionType, payload = {}, meta = {}) {
  return {
    type: actionType,
    payload: (0, _extends3.default)({}, payload),
    error: !!payload.error,
    meta: (0, _extends3.default)({}, meta)
  };
}

/**
 * Represents a request to subscribe to services and connect to a notification
 * channel.
 * @method subscribe
 * @param  {Array}   services  An array containing the request services.
 * @param  {string}  type      The type of notification channel to connect to.
 * @return {Object}            A flux standard action.
 */
function subscribe(services = [], type) {
  return actionFormatter(actionTypes.SUBSCRIBE, { services, type });
}

/**
 * Indicates that the subscription process has finished.
 * @method subscribeFinished
 * @param  {Object}  subscriptions  An object representing the subscriptions.
 * @param  {string}  type                 The type of notificaitonChannel for this subscription.
 * @param  {Object}  error                An error object.
 * @return {Object}                       A flux standard action.
 */
function subscribeFinished({ subscriptions, type, error }) {
  return actionFormatter(actionTypes.SUBSCRIBE_FINISHED, { subscriptions, type, error });
}

/**
 * A request to unsubscribe from services.
 * @method unsubscribe
 * @param  {Array} services A list of services.
 * @param  {string} type The type of notificationChannel.
 * @return {Object} A flux standard action.
 */
function unsubscribe(services = [], type) {
  return actionFormatter(actionTypes.UNSUBSCRIBE, { services, type });
}

/**
 * A notice that unsubscription has finished.
 * @method unsubscribeFinished
 * @param  {string} type The type of notificationChannel.
 * @param  {Object} [error] An error object.
 * @return {Object} A flux standard action.
 */
function unsubscribeFinished({ unsubscriptions, type, error }) {
  return actionFormatter(actionTypes.UNSUBSCRIBE_FINISHED, { unsubscriptions, type, error });
}

/**
 * Signifies that a plugin has subscription logic for certain services.
 * @method registerService
 * @param  {Array}  [services=[]] A list of services.
 * @return {Object} A flux standard action.
 */
function registerService(services = []) {
  return actionFormatter(actionTypes.REGISTER_SUB_SERVICE, { services });
}

/**
 * Indicates that the subscription plugin expects plugins to subscribe
 * for the specified services.
 * @method doPluginSubscriptions
 * @param  {Array}  services The list of services that should be subscribed to.
 * @param  {string} type The type of notification channel for these subscriptions.
 * @return {Object} A flux standard action.
 */
function doPluginSubscriptions(services, type) {
  return actionFormatter(actionTypes.PLUGIN_SUBSCRIPTION, { services, type });
}

/**
 * Indicates that a plugin has finished a subscription for the specified service.
 * @method reportSubscriptionFinished
 * @param  {Object} params
 * @param  {string} params.service The service that the subscription was for.
 * @param  {string} params.type The type of notification channel for this subscription.
 * @param  {Object} params.subscription The subscription response from the backend.
 * @param  {BasicError} [params.error] An error object.
 * @return {Object} A flux standard action.
 */
function reportSubscriptionFinished({ service, type, subscription, error }) {
  const subscriptionId = subscription ? subscription.resourceURL.split('/subscriptions/')[1] : null;
  return actionFormatter(actionTypes.PLUGIN_SUBSCRIPTION_FINISHED, (0, _extends3.default)({}, subscription, {
    subscriptionId: subscriptionId,
    service,
    channelType: type,
    error
  }));
}

/**
 * Indicates that the subscription plugin expects plugins to unsubscribe
 * for the specified services.
 * @method doPluginUnsubscriptions
 * @param  {Array}  services The list of services that should be unsubscribed.
 * @param  {string} type The type of notification channel for these unsubscriptions.
 * @return {Object} A flux standard action.
 */
function doPluginUnsubscriptions(services, type) {
  return actionFormatter(actionTypes.PLUGIN_UNSUBSCRIPTION, { services, type });
}

/**
 * Indicates that a plugin has finished an unsubscription for the specified service.
 * @method reportUnsubscriptionFinished
 * @param  {Object} params
 * @param  {string} params.service The service that the unsubscription was for.
 * @param  {string} params.type The type of notification channel for this unsubscription.
 * @param  {BasicError} [params.error] An error object.
 * @return {Object} A flux standard action.
 */
function reportUnsubscriptionFinished({ service, type, error }) {
  return actionFormatter(actionTypes.PLUGIN_UNSUBSCRIPTION_FINISHED, {
    service,
    channelType: type
  });
}

/**
 * Indicates that a notification channel has been opened / created.
 * @method channelOpened
 * @param {Object} channelInfo Data about the notification channel.
 * @param {string} type The type of notification channel.
 * @return {Object} A flux standard action.
 */
function channelOpened(channelInfo, type) {
  return actionFormatter(actionTypes.CHANNEL_OPENED, (0, _extends3.default)({}, channelInfo), { type });
}

/**
 * Indicates that a notification channel has been closed / deleted.
 * @method channelClosed
 * @param {string} type The type of notification channel.
 * @return {Object} A flux standard action.
 */
function channelClosed(type) {
  return actionFormatter(actionTypes.CHANNEL_CLOSED, {}, { type });
}

/***/ }),

/***/ "./src/subscription/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/subscription/interface/selectors.js");

var _selectors2 = __webpack_require__("./src/auth/interface/selectors.js");

var _constants = __webpack_require__("./src/constants.js");

var _logs = __webpack_require__("./src/logs/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const log = (0, _logs.getLogManager)().getLogger('SUBSCRIPTION');

/**
 * Service API. All functions in this plugin are part of the 'services' namespace.
 * @method api
 * @param  {Function} $0
 * @param  {Function} $0.dispatch - The redux store's dispatch function.
 * @param  {Function} $0.getState - The redux store's getState function.
 * @return {Object} api - The subscription API object.
 */


// Logs


// Auth plugin.
/**
 * The Service feature allows applications to subscribe for receiving
 * communications from the platform's services. It allows an application to manage the
 * features that they will receive notifications for, and on which type of
 * channel they wish to receive them on.
 *
 * Service functions are all part of the 'services' namespace.
 *
 * @public
 * @module Subscription
 */

// Subscription plugin.
function api({ dispatch, getState }) {
  const subscriptionApi = {
    /**
     * Perform a backend subscription. This will subscribe to the requested
     * services, as well as connect to the request notification channel.
     * @public
     * @memberof Subscription
     * @method subscribe
     * @param {Array} services The services that you would like to subscribe for.
     * @param {String} [type='websocket'] The type of subscription you would like to subscribe for.
     */
    subscribe(services, type = _constants.notificationTypes.WEBSOCKET) {
      const userInfo = (0, _selectors2.getUserInfo)(getState());
      if (userInfo && userInfo.accessToken) {
        services = services.map(service => service.toLowerCase());
        dispatch(actions.subscribe(services, type));
      } else {
        // TODO: Directly emit error event
      }
    },

    /**
     * Unsubscribe from notification subscriptions.
     * @public
     * @memberof Subscription
     * @method unsubscribe
     * @param {Array} services The subscribed services that should be unsubscribed.
     * @param {String} [type='websocket'] The type of channelto be used for the notifications.
     */
    unsubscribe(services, type = _constants.notificationTypes.WEBSOCKET) {
      const userInfo = (0, _selectors2.getUserInfo)(getState());
      if (userInfo && userInfo.accessToken) {
        services = services.map(service => service.toLowerCase());
        dispatch(actions.unsubscribe(services, type));
      } else {
        // TODO: Directly emit error event
      }
    },

    resubscribe(services, type = _constants.notificationTypes.WEBSOCKET) {
      log.info(`THIS FUNCTIONALITY IS NOT YET SUPPORTED. Services: ${services}. Type: ${type}`);
    },

    /**
     * Retrieve information about currently subscribed services and available services.
     * @public
     * @memberof Subscription
     * @method getSubscriptions
     * @return {Object} Lists of subscribed and available services.
     */
    getSubscriptions() {
      return {
        subscribed: (0, _selectors.getSubscribedServices)(getState()),
        available: (0, _selectors.getRegisteredServices)(getState()),
        isPending: getState().subscription.isPending
      };
    }
  };

  return { services: subscriptionApi };
}

/***/ }),

/***/ "./src/subscription/interface/effects.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerService = registerService;

var _actions = __webpack_require__("./src/subscription/interface/actions.js");

var _actionTypes = __webpack_require__("./src/subscription/interface/actionTypes.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

// Libraries.
const log = (0, _logs.getLogManager)().getLogger('SUBSCRIPTION');

/**
 * Effect for plugins to register a service with the subscription plugin.
 * @method registerService
 * @param  {string} service The name of the service.
 * @param  {Saga} subscribe The saga to be called when subscription is requested.
 * @param  {Saga} unsubscribe The saga to be called when unsubscription is requested.
 */


// Helpers.
// Subscription plugin.
function* registerService(service, subscribeSaga, unsubscribeSaga) {
  // "Register" the service with the subscription plugin, so it knows a plugin
  //    has subscription/unsubscription logic for it.
  yield (0, _effects.put)((0, _actions.registerService)(service));

  // Redux-saga take() pattern.
  function serviceSubscribePattern(action) {
    return action.type === _actionTypes.PLUGIN_SUBSCRIPTION && action.payload.services.indexOf(service) !== -1;
  }
  // Redux-saga take() pattern.
  function serviceUnsubscribePattern(action) {
    return action.type === _actionTypes.PLUGIN_UNSUBSCRIPTION && action.payload.services.indexOf(service) !== -1;
  }

  // Ensure that `takeEvery` is only called when an actual function/saga is provided.
  //    Otherwise it may cause infinite loop error issues.
  if ((0, _fp.isFunction)(subscribeSaga)) {
    // Perform subscription logic when triggered by the action.
    yield (0, _effects.takeEvery)(serviceSubscribePattern, subscribeSaga);
  } else {
    log.error(`Registering ${service} service without subscribe functionality.`);
  }

  if ((0, _fp.isFunction)(unsubscribeSaga)) {
    // Perform unsubscription logic when triggered by the action.
    yield (0, _effects.takeEvery)(serviceUnsubscribePattern, unsubscribeSaga);
  } else {
    log.error(`Registering ${service} service without unsubscribe functionality.`);
  }
}

/***/ }),

/***/ "./src/subscription/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Subscription state has changed.
 * The new state can be retrieved by calling the `getSubscribedServices` API.
 * @public
 * @memberof Subscription
 * @event subscription:change
 */
const SUB_CHANGE = exports.SUB_CHANGE = 'subscription:change';

/***/ }),

/***/ "./src/subscription/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/subscription/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/subscription/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function subChangeEvent(action) {
  return {
    type: eventTypes.SUB_CHANGE,
    args: action.error ? { error: action.payload } : {}
  };
}

const eventsMap = {};

// Emit an event on start action for isPending change.
eventsMap[actionTypes.SUBSCRIBE] = subChangeEvent;
eventsMap[actionTypes.UNSUBSCRIBE] = subChangeEvent;

// Emit an event on finish action for results.
eventsMap[actionTypes.SUBSCRIBE_FINISHED] = subChangeEvent;
eventsMap[actionTypes.UNSUBSCRIBE_FINISHED] = subChangeEvent;

exports.default = eventsMap;

/***/ }),

/***/ "./src/subscription/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.api = exports.name = exports.reducer = undefined;

var _reducers = __webpack_require__("./src/subscription/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

var _name = __webpack_require__("./src/subscription/interface/name.js");

var _name2 = _interopRequireDefault(_name);

var _api = __webpack_require__("./src/subscription/interface/api.js");

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.reducer = _reducers2.default;
exports.name = _name2.default;
exports.api = _api2.default;

/***/ }),

/***/ "./src/subscription/interface/name.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This interface is for an subscription plugin.
 * @type {string}
 */
const name = 'subscription';
exports.default = name;

/***/ }),

/***/ "./src/subscription/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/subscription/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* State Structure
    subscription: {
        notificationChannels: { // An object with key values pairs for channelType -> channelInfo
            [Websocket] : { ... }, // Channel Info taken directly from CPaaS response.
            [Push]      : { ... }
        }
    }
 */

// Libraries.
const defaultState = {
  // Information about the open notification channels.
  notificationChannels: {},
  // The list of active subscriptions.
  subscriptions: [],
  // The list of services that plugins can subscribe to.
  registeredServices: [],
  // Whether a subscription change is currently in progress.
  isPending: false
};

const reducers = {};

// Helper function for changing the pending value.
function pendingChange(value) {
  return (state, action) => {
    return (0, _extends3.default)({}, state, { isPending: value });
  };
}
// Change isPending depending on the start/finish of subscriptions.
reducers[actionTypes.SUBSCRIBE] = pendingChange(true);
reducers[actionTypes.SUBSCRIBE_FINISHED] = pendingChange(false);
reducers[actionTypes.UNSUBSCRIBE] = pendingChange(true);

/*
 * Remove subscriptions that are in the unsubscriptions list
 */
reducers[actionTypes.UNSUBSCRIBE_FINISHED] = {
  next(state, action) {
    const subscribedServices = state.subscriptions.map(subscription => subscription.service);
    return (0, _extends3.default)({}, state, {
      isPending: false,
      subscriptions: (0, _fp.difference)(subscribedServices, action.payload.unsubscriptions)
    });
  }
};

/*
 * When a plugin reports a succesful subscription, store it in state.
 */
reducers[actionTypes.PLUGIN_SUBSCRIPTION_FINISHED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      subscriptions: state.subscriptions.concat(action.payload)
    });
  }
};

/*
 * When a plugin reports a succesful unsubscription, remove it from state.
 */
reducers[actionTypes.PLUGIN_UNSUBSCRIPTION_FINISHED] = {
  next(state, action) {
    function removeSubscription(subscription) {
      return subscription.channelType === action.payload.channelType && subscription.service === action.payload.service;
    }

    return (0, _extends3.default)({}, state, {
      subscriptions: (0, _fp.remove)(removeSubscription)(state.subscriptions)
    });
  }
};

/*
 * Store the services that plugins can subscribe to in state.
 */
reducers[actionTypes.REGISTER_SUB_SERVICE] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      // TODO: Worry about duplicate services?
      registeredServices: state.registeredServices.concat(action.payload.services)
    });
  }
};

/*
 * Store the new notifiction channel into state.
 * Assumption: A channel of the same type should NOT already exist.
 */
reducers[actionTypes.CHANNEL_OPENED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      notificationChannels: (0, _extends3.default)({}, state.notificationChannels, {
        [action.meta.type]: action.payload
      })
    });
  }
};

/*
 * Remove the notification channel info when it has been closed.
 */
reducers[actionTypes.CHANNEL_CLOSED] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      notificationChannels: (0, _extends3.default)({}, state.notificationChannels, {
        [action.meta.type]: undefined
      })
    });
  }
};

/**
 * Subscription Interface reducer
 * @method reducer
 * @param  {Object}  state - The current redux state.
 * @param  {Object}  action - A flux standard action.
 * @return {Object}  - The new redux state.
 * @example
 * Subscription state structure example; connected.
 * subscriptionState = {
 *
 * }
 */
const reducer = (0, _reduxActions.handleActions)(reducers, defaultState);
exports.default = reducer;

/***/ }),

/***/ "./src/subscription/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSubscriptionConfig = getSubscriptionConfig;
exports.getRegisteredServices = getRegisteredServices;
exports.getNotificationChannels = getNotificationChannels;
exports.getSubscribedServices = getSubscribedServices;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Retrieves the config options provided by the subscription plugin.
 * @method getSubscriptionConfig
 * @return {Object}
 */
function getSubscriptionConfig(state) {
  return (0, _fp.cloneDeep)(state.config.subscription);
}

/**
 * Retrieves the list of services that plugins have registered for.
 * @method getRegisteredServices
 * @return {Array}
 */
function getRegisteredServices(state) {
  return (0, _fp.cloneDeep)(state.subscription.registeredServices);
}

/**
 * Retrieves the open notifications channels' info and their active subscriptions.
 * @method getNotificationChannels
 * @return {Object}
 */
// TODO: Rename this selector. It gets more than notification channels.
function getNotificationChannels(state) {
  return (0, _fp.cloneDeep)({
    notificationChannels: state.subscription.notificationChannels,
    subscriptions: state.subscription.subscriptions
  });
}

/**
 * Retrieve the list of services with current subscriptions.
 * @method getSubscribedServices
 * @param {string} type the type of subscription we want to get specifically
 * @return {Array}
 */
function getSubscribedServices(state, type) {
  let subscriptions = state.subscription.subscriptions;

  // If a type was specified, filter out subscriptions of other types.
  if (type) {
    subscriptions = subscriptions.filter(subscription => subscription.channelType === type);
  }

  // Massage the subscriptions to be a list of service names.
  subscriptions = subscriptions.map(subscription => subscription.service);
  return (0, _fp.cloneDeep)(subscriptions);
}

/***/ }),

/***/ "./src/users/cpaas2/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__("../../node_modules/babel-runtime/core-js/object/values.js");

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = cpaas2Users;

var _index = __webpack_require__("./src/users/interface/index.js");

var _index2 = _interopRequireDefault(_index);

var _sagas = __webpack_require__("./src/users/cpaas2/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _contacts = __webpack_require__("./src/users/interface/events/contacts.js");

var _contacts2 = _interopRequireDefault(_contacts);

var _users = __webpack_require__("./src/users/interface/events/users.js");

var _users2 = _interopRequireDefault(_users);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Other plugins.
// Users plugin.
function cpaas2Users() {
  function* init() {
    yield (0, _effects.put)((0, _actions.mapEvents)((0, _extends3.default)({}, _contacts2.default, _users2.default)));
  }

  return {
    name: _index2.default.name,
    sagas: (0, _values2.default)(sagas),
    api: _index2.default.api,
    reducer: _index2.default.reducer,
    init
  };
}

// Libraries.

/***/ }),

/***/ "./src/users/cpaas2/requests/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.addContactRequest = addContactRequest;
exports.updateContactRequest = updateContactRequest;
exports.deleteContactRequest = deleteContactRequest;
exports.fetchContactRequest = fetchContactRequest;
exports.refreshContactsRequest = refreshContactsRequest;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _handleRequestError = __webpack_require__("./src/common/helpers/handleRequestError.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _codes = __webpack_require__("./src/errors/codes.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * addContactRequest
 *
 * Perform an HTTP request to create one contact resource
 * @method addContactRequest
 * @param {Object} requestInfo Platform connection and user info for the request
 * @param {string} [body] The request body for a POST request
 */
// Helpers.
function* addContactRequest(requestInfo, body) {
  const response = yield (0, _effects2.default)({
    url: `${requestInfo.baseURL}/cpaas/addressbook/v1/${requestInfo.username}/default/contacts`,
    body: body,
    method: 'POST',
    headers: {}
  }, requestInfo.options);

  if (response.error) {
    // Handle errors from the server.
    return {
      error: (0, _handleRequestError.handleRequestError)(response, 'Add Contact Request')
    };
  } else if (response.payload.body) {
    return { result: response.payload.body.contact };
  } else {
    // No error, but response does not contain a body
    return { result: response.payload.result };
  }
}

/**
 * updateContactRequest
 *
 * Perform an HTTP request to update one contact resource
 * @method updateContactRequest
 * @param {Object} requestInfo Platform connection and user info for the request
 * @param {string} [body] The request body for a POST request
 */
function* updateContactRequest(requestInfo, contactId, body) {
  const response = yield (0, _effects2.default)({
    url: `${requestInfo.baseURL}/cpaas/addressbook/v1/${requestInfo.username}/default/contacts/${contactId}`,
    body: body,
    method: 'PUT',
    headers: {}
  }, requestInfo.options);

  if (response.error) {
    // Handle errors from the server.
    return {
      error: (0, _handleRequestError.handleRequestError)(response, 'Update Contact Request')
    };
  } else if (response.payload.body) {
    return { result: response.payload.body.contact };
  } else {
    // No error, but no body in the response
    return { result: response.payload.result };
  }
}

/**
 * deleteContactRequest
 *
 * Send an HTTP DELETE request to delete one contact
 * @method deleteContactRequest
 * @param {Object} requestInfo Platform connection and user information necessary to create the request
 * @param {string} contactId The uniquely identifier for the contact
 */
function* deleteContactRequest(requestInfo, contactId) {
  const url = `${requestInfo.baseURL}/cpaas/addressbook/v1/${requestInfo.username}/default/contacts/${contactId}`;

  const options = {
    method: 'DELETE'
  };

  const response = yield (0, _effects2.default)((0, _extends3.default)({ url }, options), requestInfo.options);

  if (response.error) {
    // Handle errors from the server.
    return {
      error: (0, _handleRequestError.handleRequestError)(response, 'Delete Contact Request')
    };
  } else {
    // Successful DELETE requests sent to this endpoint do not return a body, thus we will return a boolean
    return { result: true };
  }
}

/**
 * fetchContactRequest
 *
 * Perform an HTTP request to retrieve one contact resource
 * @method fetchContactRequest
 * @param {Object} requestInfo Platform connection and user info for the request
 * @param {string} [contactId] The unique identifier of the contact
 */
function* fetchContactRequest(requestInfo, contactId) {
  const response = yield (0, _effects2.default)({
    url: `${requestInfo.baseURL}/cpaas/addressbook/v1/${requestInfo.username}/default/contacts/${contactId}`,
    method: 'GET'
  }, requestInfo.options);

  if (response.error) {
    // Handle errors from the server.
    return {
      error: (0, _handleRequestError.handleRequestError)(response, 'Fetch Contact Request')
    };
  } else if (response.payload.body) {
    return { result: response.payload.body.contact };
  } else {
    // No error, but response does not contain a body
    return { result: true };
  }
}

/**
 * refreshContactsRequest
 *
 * Perform an HTTP request to retrieve all of a user's address book contacts
 * @method refreshContactsRequest
 * @param {Object} requestInfo Platform connection and user info for the request
 */
function* refreshContactsRequest(requestInfo) {
  const url = `${requestInfo.baseURL}/cpaas/addressbook/v1/${requestInfo.username}/default/contacts`;
  const options = { method: 'GET' };

  const response = yield (0, _effects2.default)((0, _extends3.default)({ url }, options), requestInfo.options);

  if (response.error) {
    // Handle errors from the server.
    return {
      error: (0, _handleRequestError.handleRequestError)(response, 'Refresh Contact Request')
    };
  } else if (response.payload.body) {
    return { result: response.payload.body.contactCollection.contact };
  } else {
    // Response does not contain an error, but no body was provided. As this request expects a body, we treat it as an error.
    return {
      error: new _errors2.default({
        message: 'Request succeeded but no body was provided in the response',
        code: _codes.usersCodes.UNKNOWN
      })
    };
  }
}

/***/ }),

/***/ "./src/users/cpaas2/requests/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.directorySearch = directorySearch;

var _effects = __webpack_require__("./src/request/effects.js");

var _effects2 = _interopRequireDefault(_effects);

var _handleRequestError = __webpack_require__("./src/common/helpers/handleRequestError.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries
// Helpers.
const log = (0, _logs.getLogManager)().getLogger('USERS');

/**
 * directorySearch
 *
 * Composes and executes a REST request to the directory service
 * @method directorySearch
 * @param {Object} requestInfo
 * @param {Object} params
 */
function* directorySearch(requestInfo, params = {}) {
  const directoryId = params.directoryId || 'default';
  const method = 'GET';
  const url = `${requestInfo.baseURL}/cpaas/directory/v1/${requestInfo.username}/${directoryId}/search`;
  const queryParams = (0, _fp.mapKeys)(mapSearchKey, (0, _fp.pick)(validKeys, params));

  const response = yield (0, _effects2.default)({ url, queryParams, method }, requestInfo.options);

  if (response.error) {
    // Handle the error similarly regardless of whether or not the response has a body value
    const error = (0, _handleRequestError.handleRequestError)(response, 'User Request');
    log.debug('Error performing directorySearch request', error);
    return {
      error: error
    };
  } else if (response.payload.body) {
    // Request was successful
    return response.payload.body.directoryItemList;
  } else {
    // Request was successful but no body was provided
    return { result: true };
  }
}

/**
 * valid directory search query keys
 *
 * @type {Array}
 */
const validKeys = ['name', 'firstName', 'lastName', 'userId', 'userName', 'phoneNumber', 'order', 'sortBy', 'max', 'next'];

/**
 * Helper function to return a validated parameter for directory searches
 * @param {string} key
 * @returns {string}
 */
function mapSearchKey(key) {
  switch (key) {
    case 'userId':
      return 'userName';
    default:
      return key;
  }
}

/***/ }),

/***/ "./src/users/cpaas2/sagas/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__("../../node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

exports.addContact = addContact;
exports.updateContact = updateContact;
exports.removeContact = removeContact;
exports.fetchContact = fetchContact;
exports.refreshContacts = refreshContacts;

var _contacts = __webpack_require__("./src/users/interface/actions/contacts.js");

var actions = _interopRequireWildcard(_contacts);

var _contacts2 = __webpack_require__("./src/users/cpaas2/requests/contacts.js");

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _utils = __webpack_require__("./src/users/cpaas2/utils.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Add a contact to the Address Book
 * @method addContact
 * @param {Object} action an action of type ADD_CONTACT
 */


// Helpers
function* addContact(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, 'cpaas2');
  const contactBody = (0, _utils.remoteContactFromLocal)(action.payload, true);
  const res = yield (0, _effects.call)(_contacts2.addContactRequest, requestInfo, (0, _stringify2.default)(contactBody));
  if (res.error) {
    yield (0, _effects.put)(actions.addContactFinish({ error: res.error }));
  } else {
    yield (0, _effects.put)(actions.addContactFinish({ contact: action.payload }));
  }
}

/**
 * Update a contact in the address book
 * @method updateContact
 * @param {Object} action an action of type UPDATE_CONTACT
 */


// Libraries


// Other plugins.
// Users plugin
function* updateContact(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, 'cpaas2');
  const contactBody = (0, _utils.remoteContactFromLocal)(action.payload.contact, false);
  const res = yield (0, _effects.call)(_contacts2.updateContactRequest, requestInfo, action.payload.contactId, (0, _stringify2.default)(contactBody));
  if (res.error) {
    yield (0, _effects.put)(actions.updateContactFinish({ error: res.error }));
  } else {
    yield (0, _effects.put)(actions.updateContactFinish({ contact: action.payload.contact }));
  }
}

/**
 * Remove a contact from the address book
 * @method removeContact
 * @param {Object} action an action of type REMOVE_CONTACT
 */
function* removeContact(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, 'cpaas2');
  const res = yield (0, _effects.call)(_contacts2.deleteContactRequest, requestInfo, action.payload);
  if (res.error) {
    yield (0, _effects.put)(actions.removeContactFinish({ error: res.error }));
  } else {
    yield (0, _effects.put)(actions.removeContactFinish({ error: action.payload }));
  }
}

/**
 * Fetch a contact from the personal address book of the subscribed user.
 * @method fetchContact
 * @param {Object} action an action of type FETCH_CONTACT
 */
function* fetchContact(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, 'cpaas2');
  const res = yield (0, _effects.call)(_contacts2.fetchContactRequest, requestInfo, action.payload);
  if (res.error) {
    yield (0, _effects.put)(actions.fetchContactFinish({ error: res.error }));
  } else {
    yield (0, _effects.put)(actions.fetchContactFinish({ contact: (0, _utils.localContactFromRemote)(res.result) }));
  }
}

/**
 * Refresh the state's contacts by fetching the latest contacts from the user's address book
 * @method refreshContacts
 * @param {Object} action an action of type REFRESH_CONTACTS
 */
function* refreshContacts(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, 'cpaas2');
  const res = yield (0, _effects.call)(_contacts2.refreshContactsRequest, requestInfo);
  if (res.error) {
    yield (0, _effects.put)(actions.refreshContactsFinish({ error: res.error }));
  } else {
    yield (0, _effects.put)(actions.refreshContactsFinish({ contacts: res.result.map(_utils.localContactFromRemote) }));
  }
}

/***/ }),

/***/ "./src/users/cpaas2/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContact = addContact;
exports.updateContact = updateContact;
exports.removeContact = removeContact;
exports.fetchContact = fetchContact;
exports.refreshContacts = refreshContacts;
exports.searchDirectory = searchDirectory;
exports.fetchUser = fetchUser;
exports.fetchSelfInfo = fetchSelfInfo;

var _contacts = __webpack_require__("./src/users/cpaas2/sagas/contacts.js");

var contactsSagas = _interopRequireWildcard(_contacts);

var _users = __webpack_require__("./src/users/cpaas2/sagas/users.js");

var usersSagas = _interopRequireWildcard(_users);

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Contacts sagas

/**
 * addContact
 *
 * Add a contact to the personal address book of the subscribed user.
 * @method addContact
 */
/**
 * Users saga index.
 * Defines which actions trigger which sagas.
 */

// Users plugin.
function* addContact() {
  yield (0, _effects.takeEvery)(actionTypes.ADD_CONTACT, contactsSagas.addContact);
}

/**
 * updateContact
 *
 * Update a contact to the personal address book of the subscribed user.
 * @method updateContact
 */


// Libraries.
function* updateContact() {
  yield (0, _effects.takeEvery)(actionTypes.UPDATE_CONTACT, contactsSagas.updateContact);
}

/**
 * removeContact
 *
 * Remove a contact from the currently subscribed user's address book.
 * @method removeContact
 */
function* removeContact() {
  yield (0, _effects.takeEvery)(actionTypes.REMOVE_CONTACT, contactsSagas.removeContact);
}

/**
 * fetchContact
 *
 * Fetch a contact from the personal address book of the subscribed user.
 * @method fetchContact
 */
function* fetchContact() {
  yield (0, _effects.takeEvery)(actionTypes.FETCH_CONTACT, contactsSagas.fetchContact);
}

/**
 * refreshContacts
 *
 * Refresh the contacts of the currently subscribed user.
 * @method refreshContacts
 */
function* refreshContacts() {
  yield (0, _effects.takeEvery)(actionTypes.REFRESH_CONTACTS, contactsSagas.refreshContacts);
}

// Users sagas

/**
 * searchDirectory
 *
 * Search the user directory.
 * @method searchDirectory
 */
function* searchDirectory() {
  yield (0, _effects.takeEvery)(actionTypes.SEARCH_DIRECTORY, usersSagas.searchDirectory);
}

/**
 * fetchUser
 *
 * Fetch a user from the directory service.
 * @method fetchUser
 */
function* fetchUser() {
  yield (0, _effects.takeEvery)(actionTypes.FETCH_USER, usersSagas.fetchUser);
}

/**
 * fetchSelfInfo
 *
 * Fetch user information for the currently logged in user.
 * @method fetchSelfInfo
 */
function* fetchSelfInfo() {
  yield (0, _effects.takeEvery)(actionTypes.FETCH_SELF_INFO, usersSagas.fetchSelfInfo);
}

/***/ }),

/***/ "./src/users/cpaas2/sagas/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.searchDirectory = searchDirectory;
exports.fetchUser = fetchUser;
exports.fetchSelfInfo = fetchSelfInfo;

var _users = __webpack_require__("./src/users/interface/actions/users.js");

var actions = _interopRequireWildcard(_users);

var _users2 = __webpack_require__("./src/users/cpaas2/requests/users.js");

var _selectors = __webpack_require__("./src/auth/interface/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _codes = __webpack_require__("./src/errors/codes.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _utils = __webpack_require__("./src/users/cpaas2/utils.js");

var _constants = __webpack_require__("./src/constants.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logs.getLogManager)().getLogger('Users');

/**
 * Search the directory for users
 * @method searchDirectory
 * @param {Object} action an action of type SEARCH_DIRECTORY
 */


// Constants


// Libraries


// Helpers


// Other plugins.
// Users plugin
function* searchDirectory(action) {
  const { filters, options } = action.payload;
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const res = yield (0, _effects.call)(_users2.directorySearch, requestInfo, (0, _extends3.default)({}, filters, options));
  if (res.error) {
    const error = new _errors2.default({
      code: _codes.usersCodes.DIRECTORY_REQUEST_FAIL,
      message: 'Directory search request resulted in an error being returned from the server'
    });
    yield (0, _effects.put)(actions.searchDirectoryFinish({ error }));
  } else {
    const users = res.directoryItem.map(_utils.localUserFromRemote);
    yield (0, _effects.put)(actions.searchDirectoryFinish({ users }));
  }
}

/**
 * fetch one user by their userId
 * @method fetchUser
 * @param {Object} action an action of type FETCH_USER
 */
function* fetchUser(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const res = yield (0, _effects.call)(_users2.directorySearch, requestInfo, { userId: action.payload, sortBy: 'name', order: 'asc' });
  if (res.error) {
    const error = new _errors2.default({
      code: _codes.usersCodes.DIRECTORY_REQUEST_FAIL,
      message: 'Directory search request resulted in an error being returned from the server'
    });
    yield (0, _effects.put)(actions.fetchUserFinish({ error }));
  } else {
    if (res.directoryItem.length > 0) {
      if (res.directoryItem.length > 1) {
        log.info('Fetch User request returned more than 1 user', res.directoryItem);
      }
      yield (0, _effects.put)(actions.fetchUserFinish((0, _utils.localUserFromRemote)(res.directoryItem[0])));
    }
  }
}

/**
 * fetch the user information from the directory for the current user
 * @method fetchSelfInfo
 * @param {Object} action an action of type FETCH_SELF_INFO
 */
function* fetchSelfInfo(action) {
  const requestInfo = yield (0, _effects.select)(_selectors.getRequestInfo, _constants.platforms.CPAAS2);
  const res = yield (0, _effects.call)(_users2.directorySearch, requestInfo, {
    name: requestInfo.username.split('@')[0],
    sortBy: 'name',
    order: 'asc'
  });
  if (res.error) {
    const error = new _errors2.default({
      code: _codes.usersCodes.DIRECTORY_REQUEST_FAIL,
      message: 'Directory search request resulted in an error being returned from the server'
    });
    yield (0, _effects.put)(actions.fetchSelfInfoFinish({ error }));
  } else {
    if (res.directoryItem.length > 0) {
      if (res.directoryItem.length > 1) {
        log.info('Fetch Self Info returned more than 1 user', res.directoryItem);
      }
      yield (0, _effects.put)(actions.fetchSelfInfoFinish((0, _utils.localUserFromRemote)(res.directoryItem[0])));
    }
  }
}

/***/ }),

/***/ "./src/users/cpaas2/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__("../../node_modules/babel-runtime/core-js/object/entries.js");

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.localContactFromRemote = localContactFromRemote;
exports.remoteContactFromLocal = remoteContactFromLocal;
exports.localUserFromRemote = localUserFromRemote;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * localContactFromRemote
 *
 * Convert a contact object from the back end format used in REST calls, to the local format maintained in the state.
 *
 * @param {Object} contact A remote contact object
 */
function localContactFromRemote(contact) {
  if (contact) {
    const formattedContact = (0, _fp.reduce)((result, item) => (0, _extends3.default)({}, result, { [item.name]: item.value }), {}, contact.attributeList.attribute);

    formattedContact.contactId = contact.contactId;
    return formattedContact;
  }
}

/**
 * Helper function to restructure local contact data for use in a REST request.
 *
 * @param {Object} contact The contact object
 * @param {boolean} [newContact] Flag to indicate that the data being processed is for a new contact
 */
// Libraries
function remoteContactFromLocal(contact, newContact = true) {
  // Cloning the contact to facilitate the removal of `contactId` from the attributes portion of the REST body
  const omittedKeys = newContact ? ['contactId'] : ['contactId', 'name'];
  const contactData = (0, _fp.omit)(omittedKeys, contact);
  const attributes = (0, _fp.map)(([key, value]) => ({ name: key, value: String(value) }), (0, _entries2.default)(contactData));

  return {
    contact: {
      attributeList: {
        attribute: attributes
      },
      contactId: contact.contactId
    }
  };
}

/**
 * Helper function to organize user information into an object structure for storage in state
 */
function localUserFromRemote(data) {
  const user = {};
  for (let attribute of data.attribute) {
    user[attribute.name] = attribute.value;
  }
  if ('primaryContact' in user) {
    user.userId = user.primaryContact;
    delete user.primaryContact;
  }
  return user;
}

/***/ }),

/***/ "./src/users/interface/actions/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/';

/**
 * Contact Actions
 *
 * Action types associated with the operations of methods on the contacts namespace
 */
const ADD_CONTACT = exports.ADD_CONTACT = prefix + 'ADD_CONTACT';
const ADD_CONTACT_FINISH = exports.ADD_CONTACT_FINISH = prefix + 'ADD_CONTACT_FINISH';

const REFRESH_CONTACTS = exports.REFRESH_CONTACTS = prefix + 'REFRESH_CONTACTS';
const REFRESH_CONTACTS_FINISH = exports.REFRESH_CONTACTS_FINISH = prefix + 'REFRESH_CONTACTS_FINISH';

const REMOVE_CONTACT = exports.REMOVE_CONTACT = prefix + 'REMOVE_CONTACT';
const REMOVE_CONTACT_FINISH = exports.REMOVE_CONTACT_FINISH = prefix + 'REMOVE_CONTACT_FINISH';

const UPDATE_CONTACT = exports.UPDATE_CONTACT = prefix + 'UPDATE_CONTACT';
const UPDATE_CONTACT_FINISH = exports.UPDATE_CONTACT_FINISH = prefix + 'UPDATE_CONTACT_FINISH';

const FETCH_CONTACT = exports.FETCH_CONTACT = prefix + 'FETCH_CONTACT';
const FETCH_CONTACT_FINISH = exports.FETCH_CONTACT_FINISH = prefix + 'FETCH_CONTACT_FINISH';

/**
 * User Actions
 *
 * Action types associated with the operations of methods on the users namespace
 */
const FETCH_USER = exports.FETCH_USER = prefix + 'FETCH_USER';
const FETCH_USER_FINISH = exports.FETCH_USER_FINISH = prefix + 'FETCH_USER_FINISH';

const FETCH_SELF_INFO = exports.FETCH_SELF_INFO = prefix + 'FETCH_SELF_INFO';
const FETCH_SELF_INFO_FINISH = exports.FETCH_SELF_INFO_FINISH = prefix + 'FETCH_SELF_INFO_FINISH';

const SEARCH_DIRECTORY = exports.SEARCH_DIRECTORY = prefix + 'SEARCH_DIRECTORY';
const SEARCH_DIRECTORY_FINISH = exports.SEARCH_DIRECTORY_FINISH = prefix + 'SEARCH_DIRECTORY_FINISH';

/***/ }),

/***/ "./src/users/interface/actions/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refreshContacts = refreshContacts;
exports.refreshContactsFinish = refreshContactsFinish;
exports.addContact = addContact;
exports.addContactFinish = addContactFinish;
exports.fetchContact = fetchContact;
exports.fetchContactFinish = fetchContactFinish;
exports.removeContact = removeContact;
exports.removeContactFinish = removeContactFinish;
exports.updateContact = updateContact;
exports.updateContactFinish = updateContactFinish;

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Refresh the contact list.
 * @returns {Object} A flux standard action representing the REFRESH_CONTACTS action.
 */
function refreshContacts() {
  return {
    type: actionTypes.REFRESH_CONTACTS,
    payload: null
  };
}

/**
 * The finishing action which follows the REFRESH_CONTACTS action
 * @param {Object} $0
 * @param  {Array} [$0.contacts] An array of contact objects.
 * @param  {Object} [$0.error] An error object. Only present if an error occurred.
 * @returns {Object} A flux standard action representing the REFRESH_CONTACTS_FINISH action.
 */
function refreshContactsFinish({ contacts, error }) {
  return {
    type: actionTypes.REFRESH_CONTACTS_FINISH,
    payload: error || contacts,
    error: Boolean(error)
  };
}

/**
 * Adds a contact to the Address Book
 * @param {Object} contact The contact object.
 * @returns {Object} A flux standard action representing the ADD_CONTACT action.
 */
function addContact(contact) {
  return {
    type: actionTypes.ADD_CONTACT,
    payload: contact
  };
}

/**
 * The finishing action which follows the ADD_CONTACT action
 * @param {Object} $0
 * @param {Object} [$0.contact] The contact object.
 * @param {Object} [$0.error] An error object. Only present if an error occurred.
 * @returns {Object} A flux standard action representing the ADD_CONTACT_FINISH action.
 */
function addContactFinish({ contact, error }) {
  return {
    payload: error || contact,
    error: Boolean(error),
    type: actionTypes.ADD_CONTACT_FINISH
  };
}

/**
 * Fetch a contact from the user's personal address book
 * @param {string} contactId The ID of the contact to be fetched
 * @returns {Object} A flux standard action representing the FETCH_CONTACT action.
 */
function fetchContact(contactId) {
  return {
    type: actionTypes.FETCH_CONTACT,
    payload: contactId
  };
}

/**
 * The finishing action which follows a FETCH_CONTACT action
 * @param {Object} $0
 * @param {Object} [$0.contact] The contact object.
 * @param {Object} [$0.error] A Basic error object
 * @returns {Object} A flux standard action representing the FETCH_CONTACT_FINISH action.
 */
function fetchContactFinish({ contact, error }) {
  return {
    type: actionTypes.FETCH_CONTACT_FINISH,
    payload: error || contact,
    error: Boolean(error)
  };
}

/**
 * Removes a contact from the Address Book
 * @param {string} contactId The id of the contact whom it has been requested to delete from the address book
 * @returns {Object} A flux standard action representing the REMOVE_CONTACT action.
 */
function removeContact(contactId) {
  return {
    type: actionTypes.REMOVE_CONTACT,
    payload: contactId
  };
}

/**
 * The finishing action which follows a REMOVE_CONTACT action
 * @param {Object} $0
 * @param {string} [$0.contactId] The id of the contact whom it has been requested to delete from the address book
 * @param {Object} [$0.error] An error object. Only present if an error occurred.
 * @returns {Object} A flux standard action representing the REMOVE_CONTACT_FINISH action.
 */
function removeContactFinish({ contactId, error }) {
  return {
    type: actionTypes.REMOVE_CONTACT_FINISH,
    payload: contactId
  };
}

/**
 * Updates the data for a contact in the Address Book
 * @param {string} contactId The ID of the contact being targeted for an update action
 * @param {Object} contact The contact object.
 * @returns {Object} A flux standard action representing the UPDATE_CONTACT action.
 */
function updateContact(contactId, contact) {
  return {
    type: actionTypes.UPDATE_CONTACT,
    payload: { contactId, contact }
  };
}

/**
 * The finishing action which follows a UPDATE_CONTACT action
 * @param {Object} $0
 * @param {Object} [$0.contact] The contact object.
 * @param {Object} [$0.error] A Basic error object
 * @returns {Object} A flux standard action representing the UPDATE_CONTACT_FINISH action.
 */
function updateContactFinish({ contact, error }) {
  return {
    type: actionTypes.UPDATE_CONTACT_FINISH,
    payload: error || contact,
    error: !!error
  };
}

/***/ }),

/***/ "./src/users/interface/actions/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchSelfInfo = fetchSelfInfo;
exports.fetchSelfInfoFinish = fetchSelfInfoFinish;
exports.fetchUser = fetchUser;
exports.fetchUserFinish = fetchUserFinish;
exports.searchDirectory = searchDirectory;
exports.searchDirectoryFinish = searchDirectoryFinish;

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Action for fetching the current user's profile data.
 * @returns {Object} A flux standard action
 */
function fetchSelfInfo() {
  return {
    type: actionTypes.FETCH_SELF_INFO
  };
}

/**
 * The finishing action to follow the FETCH_SELF_INFO action
 * @returns {Object} A flux standard action representing the FETCH_SELF_INFO_FINISH action
 */
function fetchSelfInfoFinish(self, error) {
  return {
    type: actionTypes.FETCH_SELF_INFO_FINISH,
    payload: error || self,
    error: Boolean(error)
  };
}

/**
 *
 * @param {string} userId The URI uniquely identifying the user.
 * @returns {Object} A flux standard action representing the FETCH_USER action
 */
function fetchUser(userId) {
  return {
    type: actionTypes.FETCH_USER,
    payload: userId
  };
}

/**
 * Create a finish action to follow a FETCH_USER action.
 *
 * @param {Object} user A user object
 * @param {Object} [error] An error object.
 * @returns {Object} A flux standard action representing the USER_FETCH_FINISH action.
 */
function fetchUserFinish(user, error) {
  return {
    type: actionTypes.FETCH_USER_FINISH,
    payload: error || user,
    error: Boolean(error)
  };
}

/**
 * Create an action that searches the directory.
 *
 * @param {Object} filters Query filter options.
 * @param {string} [filters.name] Matches firstName or lastName.
 * @param {string} [filters.firstName] Matches firstName.
 * @param {string} [filters.lastName] Matches lastName.
 * @param {string} [filters.userName] Matches userName.
 * @param {string} [filters.phoneNumber] Matches phoneNumber.
 * @param {Object} [options] Sorting options
 * @param {string} [options.sortBy] The attribute upon which to sort results. This can be any of the above listed filters which describe a user attribute.
 * @param {string} [options.order] Order by which to return results. Can be one of "asc" or "desc".
 * @param {number} [options.max] The maximmum number of results to return.
 * @param {string} [options.next] The pointer for a chunk of results, which may be returned from other a previous query.
 * @returns {Object} A flux standard action representing the SEARCH_DIRECTORY action.
 */
function searchDirectory(filters, options) {
  return {
    type: actionTypes.SEARCH_DIRECTORY,
    payload: { filters, options }
  };
}

/**
 * Create a finish action to follow the SEARCH_DIRECTORY action.
 *
 * @param {Object} $0 A dictionary object of parameters
 * @param {Array} [$0.users] The user objects
 * @param {Object} [$0.error] An error object.
 * @returns {Object} A flux standard action representing the DIRECTORY_CHANGED action.
 */
function searchDirectoryFinish({ users, error }) {
  return {
    type: actionTypes.SEARCH_DIRECTORY_FINISH,
    payload: error || users,
    error: Boolean(error)
  };
}

/***/ }),

/***/ "./src/users/interface/api/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = contactsAPI;

var _contacts = __webpack_require__("./src/users/interface/actions/contacts.js");

var actions = _interopRequireWildcard(_contacts);

var _selectors = __webpack_require__("./src/users/interface/selectors.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Users plugin.
function contactsAPI({ dispatch, getState, primitives }) {
  /**
   * The Contacts feature allows users to store personal contacts to their account.
   *
   * These functions are namespaced beneath 'contacts' on the API.
   * @public
   * @module Contacts
   */

  return {
    /**
     * Add a contact to a user's personal address book.
     * Will trigger the `contacts:new` event.
     *
     * @public
     * @memberof Contacts
     * @method add
     * @param {Object} contact The contact object.
     * @param {string} contact.primaryContact The primary userId for the contact
     * @param {string} [contact.name] The name for the contact entry
     * @param {string} [contact.firstName] The contact's first name
     * @param {string} [contact.lastName] The contact's last name
     * @param {string} [contact.contactId] The contact's unique contact ID
     * @param {string} [contact.email] The contact's email address
     * @param {string} [contact.homePhoneNumber] The contact's home phone number
     * @param {string} [contact.businessPhoneNumber] The contact's business phone number
     * @param {string} [contact.mobilePhoneNumber] The contact's mobile phone number
     * @param {string} [contact.list] The name of the contact list for which to add this contact to ("friends" by default)
     * @param {boolean} [contact.buddy] Indicates whether or not the contact is a friend of the user
     */
    add(contact) {
      dispatch(actions.addContact(contact));
    },

    /**
     * Retrieves local information about a contact.
     *
     * @public
     * @memberof Contacts
     * @method get
     * @param {string} contactId The unique contact ID of the contact.
     * @return {Object} Contact information.
     */
    get(contactId) {
      return (0, _selectors.getContact)(getState(), contactId);
    },

    /**
     * Retrieves local information about all contacts.
     *
     * @public
     * @memberof Contacts
     * @method getAll
     * @return {Array} List of contact information.
     */
    getAll() {
      return (0, _selectors.getContacts)(getState());
    },

    /**
     * Refreshes the local information about contacts. This will get new contacts from the platform.
     * Will trigger the `contacts:change` event.
     *
     * @public
     * @memberof Contacts
     * @method refresh
     */
    refresh() {
      dispatch(actions.refreshContacts());
    },

    /**
     * Remove a contact from a personal address book.
     * Will trigger the `contacts:change` event.
     *
     * @public
     * @memberof Contacts
     * @method remove
     * @param  {string} id The Id of the contact that will be removed.
     */
    remove(id) {
      dispatch(actions.removeContact(id));
    },

    /**
     * Update a contact from the user's personal address book.
     * Will trigger the `contacts:change` event.
     *
     * @public
     * @memberof Contacts
     * @method update
     * @param  {string} contactId The unique contact ID.
     * @param  {Object} contact The contact object.
     */
    update(contactId, contact) {
      dispatch(actions.updateContact(contactId, contact));
    },

    /**
     * Fetch a contact from the user's personal address book.
     * Will trigger the `contacts:change` event.
     *
     * @public
     * @memberof Contacts
     * @method fetch
     * @param  {string} contactId The unique contact ID of the contact.
     */
    fetch(contactId) {
      dispatch(actions.fetchContact(contactId));
    }
  };
}

/***/ }),

/***/ "./src/users/interface/api/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _users = __webpack_require__("./src/users/interface/api/users.js");

var _users2 = _interopRequireDefault(_users);

var _contacts = __webpack_require__("./src/users/interface/api/contacts.js");

var _contacts2 = _interopRequireDefault(_contacts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Users API index.
 * APIs are organized by their namespacing.
 * @method api
 * @param {Object} context
 * @param {Function} context.dispatch The redux store's dispatch function.
 * @param {Function} context.getState The redux store's getState function.
 * @param {Object} context.primitives Primitive types designed for use in the SDK
 * @return {Object} The plugin's API object.
 */
function api(context) {
  return {
    contacts: (0, _contacts2.default)(context),
    user: (0, _users2.default)(context)
  };
}

/***/ }),

/***/ "./src/users/interface/api/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = usersAPI;

var _users = __webpack_require__("./src/users/interface/actions/users.js");

var actions = _interopRequireWildcard(_users);

var _selectors = __webpack_require__("./src/users/interface/selectors.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Users plugin.
function usersAPI({ dispatch, getState, primitives }) {
  /**
   * The Users feature allows access to user information for users within the same domain.
   *
   * These functions are namespaced beneath 'user' on the API.
   * @public
   * @module Users
   */

  return {
    /**
     * Fetches information about a specified user from the platform.
     * Will trigger a `directory:change` event.
     *
     * @public
     * @memberof Users
     * @method fetch
     *
     * @param {string} userId The URI uniquely identifying the user.
     */
    fetch(userId) {
      dispatch(actions.fetchUser(userId));
    },

    /**
     * Fetches information about the current user's profile data from the platform.
     * Will trigger a `directory:change` event.
     *
     * @public
     * @memberof Users
     * @method fetchSelfInfo
     */
    fetchSelfInfo() {
      dispatch(actions.fetchSelfInfo());
    },

    /**
     * Retrieves local information about a previously fetched user.
     * @public
     * @memberof Users
     * @method get
     * @param {string} userId The URI uniquely identifying the user.
     */
    get(userId) {
      return (0, _selectors.getUser)(getState(), userId);
    },

    /**
     * Retrieves local information about previously fetched users.
     * @public
     * @memberof Users
     * @method getAll
     */
    getAll() {
      return (0, _selectors.getUsers)(getState());
    },

    /**
     * Search the users in the directory.
     * Will trigger a `directory:change` event.
     *
     * @public
     * @memberof Users
     * @method search
     * @param {Object} filters Query filter options.
     * @param {string} [filters.userId] Matches the unique URI identifying the user.
     * @param {string} [filters.name] Matches firstName or lastName.
     * @param {string} [filters.firstName] Matches firstName.
     * @param {string} [filters.lastName] Matches lastName.
     * @param {string} [filters.userName] Matches userName.
     * @param {string} [filters.phoneNumber] Matches phoneNumber.
     * @param {Object} [options] Sorting options
     * @param {string} [options.sortBy] The attribute upon which to sort results. This can be any of the above listed filters which describe a user attribute.
     * @param {string} [options.order] Order by which to return results. Can be one of "asc" or "desc".
     * @param {number} [options.max] The maximmum number of results to return.
     * @param {string} [options.next] The pointer for a chunk of results, which may be returned from other a previous query.
     */
    search(filters = {}, options = {}) {
      dispatch(actions.searchDirectory(filters, options));
    }
  };
}

/***/ }),

/***/ "./src/users/interface/events/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventTypes = __webpack_require__("./src/users/interface/events/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const eventsMap = {};

const contactNewEvent = action => {
  return {
    type: eventTypes.CONTACTS_CHANGE,
    args: action.payload
  };
};

const contactsChangeEvent = action => {
  if (action.error) {
    return {
      type: eventTypes.CONTACTS_ERROR,
      args: { error: action.payload }
    };
  } else {
    return {
      type: eventTypes.CONTACTS_CHANGE
    };
  }
};

const addContactFinishActions = action => {
  if (action.error) {
    return contactsChangeEvent(action);
  }
  return [contactNewEvent(action), contactsChangeEvent(action)];
};

eventsMap[actionTypes.ADD_CONTACT_FINISH] = addContactFinishActions;
eventsMap[actionTypes.REFRESH_CONTACTS_FINISH] = contactsChangeEvent;
eventsMap[actionTypes.REMOVE_CONTACT_FINISH] = contactsChangeEvent;
eventsMap[actionTypes.UPDATE_CONTACT_FINISH] = contactsChangeEvent;
eventsMap[actionTypes.FETCH_CONTACT_FINISH] = contactsChangeEvent;

exports.default = eventsMap;

/***/ }),

/***/ "./src/users/interface/events/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Contacts actions
/**
 * A new contact has been added to the address book.
 * @public
 * @memberof Contacts
 * @event contacts:new
 * @param {Object} contact The new contact.
 */
const CONTACTS_NEW = exports.CONTACTS_NEW = 'contacts:new';

/**
 * An error occurred while performing a contact operation.
 * @public
 * @memberof Contacts
 * @event contacts:error
 * @param {Object} params
 * @param {Object} params.error The Basic error object.
 */
const CONTACTS_ERROR = exports.CONTACTS_ERROR = 'contacts:error';

/**
 * The contacts list has changed.
 * @public
 * @memberof Contacts
 * @event contacts:change
 * @example
 * client.on('contacts:change', function () {
 *    // Get the updated list of contacts.
 *    const contacts = client.contacts.getAll()
 *    ...
 * })
 */
const CONTACTS_CHANGE = exports.CONTACTS_CHANGE = 'contacts:change';

// Users actions
/**
 * The directory has changed.
 * @public
 * @memberof Users
 * @event directory:change
 * @param {Object} params
 * @param {Array} params.results The results of the directory search.
 */
const DIRECTORY_CHANGE = exports.DIRECTORY_CHANGE = 'directory:change';

/**
 * An error occurred while performing a directory operation.
 * @public
 * @memberof Users
 * @event directory:error
 * @param {Object} params
 * @param {Object} params.error The Basic error object.
 */
const DIRECTORY_ERROR = exports.DIRECTORY_ERROR = 'directory:error';

/***/ }),

/***/ "./src/users/interface/events/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventTypes = __webpack_require__("./src/users/interface/events/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const eventsMap = {};

eventsMap[actionTypes.SEARCH_DIRECTORY_FINISH] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.DIRECTORY_ERROR,
      args: { error: action.payload }
    };
  } else {
    return {
      type: eventTypes.DIRECTORY_CHANGE,
      args: { results: action.payload }
    };
  }
};

eventsMap[actionTypes.FETCH_USER_FINISH] = eventsMap[actionTypes.FETCH_SELF_INFO_FINISH] = function (action) {
  if (action.error) {
    return {
      type: eventTypes.DIRECTORY_ERROR,
      args: { error: action.payload }
    };
  } else {
    return {
      type: eventTypes.DIRECTORY_CHANGE,
      args: { results: [action.payload] }
    };
  }
};

exports.default = eventsMap;

/***/ }),

/***/ "./src/users/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/users/interface/api/index.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/users/interface/reducers/index.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This interface is for a users plugin.
 * @type {string}
 */
// Import the components of the interface.
const name = 'users';

// Export the interface as a single object.
exports.default = { name, api: _api2.default, reducer: _reducers2.default };

/***/ }),

/***/ "./src/users/interface/reducers/contacts.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

const contactsPendingReducer = {
  next(state) {
    return (0, _extends3.default)({}, state, {
      isPending: true
    });
  }
};

reducers[actionTypes.ADD_CONTACT] = contactsPendingReducer;
reducers[actionTypes.REFRESH_CONTACTS] = contactsPendingReducer;
reducers[actionTypes.FETCH_CONTACT] = contactsPendingReducer;
reducers[actionTypes.UPDATE_CONTACT] = contactsPendingReducer;

reducers[actionTypes.ADD_CONTACT_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      contacts: (0, _extends3.default)({}, state.contacts, {
        [action.payload.contactId]: action.payload
      }),
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.REFRESH_CONTACTS_FINISH] = {
  next(state, action) {
    const contacts = {};
    for (let contact of action.payload) {
      contacts[contact.contactId] = contact;
    }
    return (0, _extends3.default)({}, state, {
      contacts: contacts,
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.FETCH_CONTACT_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      contacts: (0, _extends3.default)({}, state.contacts, {
        [action.payload.contactId]: action.payload
      }),
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.REMOVE_CONTACT_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      contacts: (0, _fp.unset)(action.payload, state.contacts), // Remove the property from state.contacts whose key is equal to action.payload
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.UPDATE_CONTACT_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      contacts: (0, _extends3.default)({}, state.contacts, {
        [action.payload.contactId]: action.payload
      }),
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

exports.default = reducers;

/***/ }),

/***/ "./src/users/interface/reducers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _contacts = __webpack_require__("./src/users/interface/reducers/contacts.js");

var _contacts2 = _interopRequireDefault(_contacts);

var _users = __webpack_require__("./src/users/interface/reducers/users.js");

var _users2 = _interopRequireDefault(_users);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Combine all of reducers into a single reducer, defaulting to an empty Object for each
 * substate of contacts and users
 */
const reducer = (0, _reduxActions.handleActions)((0, _extends3.default)({}, _contacts2.default, _users2.default), {
  errors: [],
  contacts: {},
  users: {},
  isPending: true
});
exports.default = reducer;

/***/ }),

/***/ "./src/users/interface/reducers/users.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/users/interface/actions/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const reducers = {};

reducers[actionTypes.FETCH_USER_FINISH] = {
  next(state, action) {
    const user = action.payload;
    return (0, _extends3.default)({}, state, {
      users: (0, _extends3.default)({}, state.users, {
        [user.userId]: user
      })
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.FETCH_SELF_INFO_FINISH] = {
  next(state, action) {
    const self = action.payload;
    return (0, _extends3.default)({}, state, {
      users: (0, _extends3.default)({}, state.users, {
        [self.userId]: self
      })
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

reducers[actionTypes.SEARCH_DIRECTORY_FINISH] = {
  next(state, action) {
    const users = {};
    for (let user of action.payload) {
      users[user.userId] = user;
    }
    return (0, _extends3.default)({}, state, {
      users: (0, _extends3.default)({}, state.users, users),
      isPending: false
    });
  },
  throw(state, action) {
    return (0, _extends3.default)({}, state, {
      isPending: false,
      errors: state.errors.concat(action.payload)
    });
  }
};

exports.default = reducers;

/***/ }),

/***/ "./src/users/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContacts = getContacts;
exports.getContact = getContact;
exports.getUsers = getUsers;
exports.getUser = getUser;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/*
 * Redux-saga selector functions.
 * Used with the `select` effect in sagas to Retrieves
 *      specific portions of the state.
 */

/**
 * Gets the contacts from state.
 * @method getContacts
 * @return {Object}
 */
function getContacts(state) {
  return (0, _fp.cloneDeep)(state.users.contacts);
}

/**
 * Gets a contact from the state whose ID matches the supplied parameter
 * @method getContact
 * @return {Object}
 */
function getContact(state, id) {
  return (0, _fp.cloneDeep)(state.users.contacts[id]);
}

/**
 * Gets the users from state.
 * @method getUsers
 * @return {Object}
 */
function getUsers(state) {
  return (0, _fp.cloneDeep)(state.users.users);
}

/**
 * Gets the users from state.
 * @method getUser
 * @return {Object}
 */
function getUser(state, name) {
  return (0, _fp.cloneDeep)(state.users.users[name]);
}

/***/ }),

/***/ "./src/webrtc/channels/devices.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchDeviceEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

/**
 * Listen for events emitted from the webRTC Device Manager.
 * @method watchDeviceEvents
 * @param  {Object} manager The webRTC Device Manager.
 */


// Libraries.
function* watchDeviceEvents(manager) {
  /**
   * Create an event channel between the Device Manager and redux-saga.
   * This pushes its events into the redux-saga context.
   * */
  const managerChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(manager, emit);
  });

  // managerChannel will emit the Manager's events as actions,
  //  so they can be directly dispatched.
  yield (0, _effects.takeEvery)(managerChannel, _effects.put);
}

/**
 * Function to set-up listeners for the Device Manager events.
 * Contains the logic for how a webRTC event should be parsed
 *    before being sent elsewhere. Split into a stand-alone
 *    function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   manager The Device Manager.
 * @param  {Function} emit    Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
// Webrtc plugin.
function setListeners(manager, emit, END = 'END') {
  // Manager event handlers.
  const change = devices => {
    emit(_actions.deviceActions.devicesChanged(devices));
  };

  manager.on('change', change);

  // Return an unsubscribe function that removes all event listeners.
  const unsubscribe = () => {
    manager.off('change', change);
  };

  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watchMediaManagerEvents = exports.watchTrackManagerEvents = exports.watchDeviceEvents = undefined;

var _devices = __webpack_require__("./src/webrtc/channels/devices.js");

Object.defineProperty(exports, 'watchDeviceEvents', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_devices).default;
  }
});

var _trackManager = __webpack_require__("./src/webrtc/channels/trackManager.js");

Object.defineProperty(exports, 'watchTrackManagerEvents', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_trackManager).default;
  }
});

var _mediaManager = __webpack_require__("./src/webrtc/channels/mediaManager.js");

Object.defineProperty(exports, 'watchMediaManagerEvents', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_mediaManager).default;
  }
});
exports.default = watchManagers;

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _devices2 = _interopRequireDefault(_devices);

var _trackManager2 = _interopRequireDefault(_trackManager);

var _sessionManager = __webpack_require__("./src/webrtc/channels/sessionManager.js");

var _sessionManager2 = _interopRequireDefault(_sessionManager);

var _mediaManager2 = _interopRequireDefault(_mediaManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Combine all of the manager channels into a single function.
 * @method watchManagers
 * @param  {Object} managers Webrtc stack managers.
 */
function* watchManagers(managers, webRTC) {
  yield (0, _effects.fork)(_devices2.default, managers.devices);
  yield (0, _effects.fork)(_trackManager2.default, managers.track);
  yield (0, _effects.fork)(_sessionManager2.default, managers.sessionManager, webRTC);
  yield (0, _effects.fork)(_mediaManager2.default, managers.media);
}

/***/ }),

/***/ "./src/webrtc/channels/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchMediaEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

/**
 * Sets up event listeners for a Media's events.
 * The events are turned into actions and dispatched
 *    to be handled by redux elsewhere.
 * @method watchMediaEvents
 * @param  {Object} media A Media object.
 * @param  {Object} webRTC The webRTC stack.
 */


// Libraries.
function* watchMediaEvents(media, webRTC) {
  /**
   * Create an event channel between the Media and redux-saga.
   * This "forces" the Media events into a redux-saga context.
   */
  const mediaChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(media, emit, _reduxSaga.END);
  });
  yield (0, _effects.takeEvery)(mediaChannel, _effects.put);
}

/**
 * Function to set-up listeners for a Media object's events.
 * Contains the logic for how a webRTC event should be parsed
 *    before being sent elsewhere. Split into a stand-alone
 *    function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   media A Media object.
 * @param  {Function} emit  Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
// Webrtc plugin.
function setListeners(media, emit, END = 'END') {
  // Media received a new track.
  const newTrack = ({ mediaId, trackId }) => {
    /**
     * When a new track has been added,
     * update redux state's webrtc.media.tracks array with the new trackId.
     */
    emit(_actions.mediaActions.mediaNewTrack(mediaId, { trackId }));
  };

  // TODO: Handle media's 'track:removed' event here.
  //  In unified-plan, when a track is removed this event is triggered.
  const trackRemoved = trackId => {
    emit(_actions.mediaActions.mediaTrackRemoved(media.id, { trackId }));
  };

  const trackEnded = ({ mediaId, trackId }) => {
    /**
     * When a track has ended,
     * update redux state's webrtc.media.tracks array
     * by removing the specified trackId.
     */
    emit(_actions.mediaActions.mediaTrackEnded(mediaId, { trackId }));
  };
  const mediaStopped = id => {
    /**
     * When the media is stopped, its channel should be ended (via `END`).
     * The mediaManager channel will handle updating state for this event.
     */
    emit(END);
  };

  media.on('track:new', newTrack);
  media.on('track:removed', trackRemoved);
  media.on('track:ended', trackEnded);
  media.on('media:stopped', mediaStopped);

  const unsubscribe = () => {
    media.off('track:new', newTrack);
    media.off('track:removed', trackRemoved);
    media.off('track:ended', trackEnded);
    media.off('media:stopped', mediaStopped);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/mediaManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchMediaManagerEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _media = __webpack_require__("./src/webrtc/channels/media.js");

var _media2 = _interopRequireDefault(_media);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Sets up event listeners for Media Manager events. The events are turned into
 *    actions and dispatched to be handled by redux elsewhere.
 * @method watchMediaManagerEvents
 * @param  {Object} manager The Media Manager.
 */


// Libraries.
function* watchMediaManagerEvents(manager) {
  /**
   * Create an event channel between the Media Manager and redux-saga.
   * This pushes its events into the redux-saga context.
   */
  const managerChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(manager, emit);
  });

  yield (0, _effects.takeEvery)(managerChannel, mediaManagerEventsHandler);
} // Webrtc plugin.


function* mediaManagerEventsHandler({ media, action }) {
  // If it is a new Media, watch for its events.
  if (action.type === actionTypes.MEDIA_NEW) {
    yield (0, _effects.fork)(_media2.default, media);
  }

  // Dispatch the action
  yield (0, _effects.put)(action);
}

/**
 * Function to set-up listeners for the Media Manager events.
 * Contains the logic for how a webRTC event should be parsed
 *    before being sent elsewhere. Split into a stand-alone
 *    function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   manager The Media Manager.
 * @param  {Function} emit    Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
function setListeners(manager, emit, END = 'END') {
  const newMedia = id => {
    const media = manager.get(id);
    /**
     * When a new media has been added,
     * update redux state's webrtc.media array by adding in the new media object
     * (List of tracks will just be a list of track ids).
     */
    emit({
      media,
      action: _actions.mediaActions.newMedia(id, {
        local: media.getState().isLocal,
        tracks: media.getTracks().map(track => track.id)
      })
    });
  };

  const removedMedia = id => {
    /**
     * When a media has been removed,
     * update redux state's webrtc.media array
     * by removing the media with the specified media id.
     */
    emit({
      action: _actions.mediaActions.removedMedia(id)
    });
  };

  manager.on('media:new', newMedia);
  manager.on('media:removed', removedMedia);

  const unsubscribe = () => {
    manager.off('media:new', newMedia);
    manager.off('media:removed', removedMedia);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/session.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchSessionEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

/**
 * Sets up event listeners for a Session's events.
 * The events are turned into actions and dispatched
 *    to be handled by redux elsewhere.
 * @method watchSessionEvents
 * @param  {Object} session The Session object.
 * @param  {Object} webRTC The webRTC stack.
 */


// Libraries.
function* watchSessionEvents(session, webRTC) {
  /**
   * Create an event channel between the Session and redux-saga.
   * This "forces" the Session events into a redux-saga context.
   */
  const sessionChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(session, emit);
  });
  // sessionChannel will emit the Session's events as actions, so dispatch
  //    them to be handled by sagas.
  // TODO: If the event is "Session gone", should close/unsubscribe the channel.
  yield (0, _effects.takeEvery)(sessionChannel, _effects.put);
}

/**
 * Function to set-up listeners for a Session object's events.
 * Contains the logic for how a webRTC event should be parsed
 *    before being sent elsewhere. Split into a stand-alone
 *    function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   session A Session object.
 * @param  {Function} emit  Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
// Webrtc plugin.
function setListeners(session, emit, END = 'END') {
  // Session received a new track.
  const newTrack = ({ local, trackId }) => {
    /**
     * When a new track has been added,
     * update redux state's webrtc.session.localTracks/remoteTracks array
     * with the new trackId.
     * ('local' boolean will determine whether to update localTracks or remoteTracks)
     */
    emit(_actions.sessionActions.sessionNewTrack(session.id, {
      local,
      trackId
    }));
  };

  const trackEnded = ({ local, trackId }) => {
    /**
     * When a track has ended,
     * update redux state's webrtc.session.localTracks/remoteTracks array
     * by removing the specified trackId.
     * ('local' boolean will determine whether to update localTracks or remoteTracks)
     */
    emit(_actions.sessionActions.sessionTrackEnded(session.id, {
      local,
      trackId
    }));
  };

  // Generic "something changed" handler.
  // TODO: Either use this for other events or remove it.
  // eslint-disable-next-line no-unused-vars
  const onChange = () => {
    const state = session.getState();

    emit(_actions.sessionActions.sessionChange(session.id, {
      id: state.id,
      localTracks: state.localTracks.map(track => track.id),
      remoteTracks: state.remoteTracks.map(track => track.id)
    }));
  };

  session.on('new:track', newTrack);
  session.on('track:ended', trackEnded);

  const unsubscribe = () => {
    session.off('new:track', newTrack);
    session.off('track:ended', trackEnded);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/sessionManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchSessionManagerEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _session = __webpack_require__("./src/webrtc/channels/session.js");

var _session2 = _interopRequireDefault(_session);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Sets up event listeners for Session Manager Events.
 * The events are turned into actions and dispatched
 *    to be handled by redux elsewhere.
 * @method watchSessionManagerEvents
 * @param  {Object} manager The webRTC Session Manager.
 * @param  {Object} webRTC The webRTC stack.
 */


// Libraries.
function* watchSessionManagerEvents(manager, webRTC) {
  /**
   * Create an event channel between the Session Manager and redux-saga.
   * This pushes its events into the redux-saga context.
   */
  const managerChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(manager, emit);
  });

  while (true) {
    const { session, action } = yield (0, _effects.take)(managerChannel);

    // If it is a new Session, watch for its events.
    if (action.type === actionTypes.SESSION_ADDED) {
      yield (0, _effects.fork)(_session2.default, session, webRTC);
    }

    // Dispatch the action directly.
    yield (0, _effects.put)(action);
  }
}

/**
 * Sets up listeners for the Session Manager events.
 * Contains logic for how specific webRTC events should be
 *    parsed before being sent elsewhere. Split into a
 *    stand-alone function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   manager The Session Manager.
 * @param  {Function} emit    Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
// Webrtc plugin.
function setListeners(manager, emit, END = 'END') {
  // Handle new Session.
  const sessionAdded = id => {
    const session = manager.get(id);
    const state = session.getState();
    delete state.id;

    emit({
      session: session,
      action: _actions.sessionActions.sessionAdded(id, state)
    });
  };

  // Handle Sessions ending.
  const sessionRemoved = id => {
    emit({
      action: _actions.sessionActions.sessionRemoved(id)
    });
  };

  manager.on('session:new', sessionAdded);
  manager.on('session:removed', sessionRemoved);
  const unsubscribe = () => {
    manager.off('session:new', sessionAdded);
    manager.off('session:removed', sessionRemoved);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/track.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchTrackEvents;
exports.setListeners = setListeners;

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

/**
 * Sets up event listeners for a Track's events.
 * The events are turned into actions and dispatched
 *    to be handled by redux elsewhere.
 * @method watchTrackEvents
 * @param  {Object} track A Track object.
 * @param  {Object} webRTC The webRTC stack.
 */
// Libraries.
function* watchTrackEvents(track, webRTC) {
  /**
   * Create an event channel between the Track and redux-saga.
   * This "forces" the Track events into a redux-saga context.
   */
  const trackChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(track, emit, _reduxSaga.END);
  });
  yield (0, _effects.takeEvery)(trackChannel, _effects.put);
}

/**
 * Function to set-up listeners for a Track object's events.
 * Contains the logic for how a webRTC event should be parsed
 *    before being sent elsewhere. Split into a stand-alone
 *    function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   track A Track object.
 * @param  {Function} emit  Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
function setListeners(track, emit, END = 'END') {
  // Track ended
  const trackEnded = trackData => {
    /**
     * When the track ends, its channel should be ended (via `END`).
     * The trackManager channel will handle updating state for this event.
     */
    emit(END);
  };

  track.on('ended', trackEnded);

  const unsubscribe = () => {
    track.off('ended', trackEnded);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/channels/trackManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = watchTrackManagerEvents;
exports.setListeners = setListeners;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _track = __webpack_require__("./src/webrtc/channels/track.js");

var _track2 = _interopRequireDefault(_track);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Sets up event listeners for Track Manager Events.
 * The events are turned into actions and dispatched
 *    to be handled by redux elsewhere.
 * @method watchTrackManagerEvents
 * @param  {Object} manager The webRTC Track Manager.
 */


// Libraries.
function* watchTrackManagerEvents(manager) {
  /**
   * Create an event channel between the Track Manager and redux-saga.
   * This pushes its events into the redux-saga context.
   * */
  const managerChannel = (0, _reduxSaga.eventChannel)(emit => {
    return setListeners(manager, emit);
  });

  // https://github.com/redux-saga/redux-saga/issues/684
  // See user "kuy"'s second comment.
  // Using takeEvery to handle actions.
  // That way they are handled in a forked process and other actions don't get dropped.
  yield (0, _effects.takeEvery)(managerChannel, trackManagerEventsHandler);
} // Call plugin.


function* trackManagerEventsHandler({ track, action }) {
  // If it is a new Track, watch for its events.
  if (action.type === actionTypes.TRACK_ADDED) {
    yield (0, _effects.fork)(_track2.default, track);
  }

  // Dispatch the action
  yield (0, _effects.put)(action);
}

/**
 * Sets up listeners for the Track Manager events.
 * Contains logic for how specific webRTC events should be
 *    parsed before being sent elsewhere. Splut into a
 *    stand-alone function in order to be re-usable.
 * @method setListeners
 * @param  {Object}   manager The Track Manager.
 * @param  {Function} emit    Function that receives the parsed events.
 * @param  {Any}      [END='END'] The "end of lifetime" symbol.
 * @return {Function} The unsubscribe function.
 */
function setListeners(manager, emit, END = 'END') {
  // Handle new Tracks.
  const trackAdded = id => {
    const track = manager.get(id);
    const state = track.getState();
    delete state.id;

    /**
     * When a new track is added,
     * update redux state's webrtc.tracks array by adding track's state into it.
     */
    emit({
      track,
      action: _actions.trackActions.trackAdded(id, state)
    });
  };

  // Handle Tracks ending.
  const trackRemoved = id => {
    /**
     * When a track has ended,
     * update redux state's webrtc.tracks array
     * by specifying which track to remove by providing a track id.
     */
    emit({
      action: _actions.trackActions.trackRemoved(id)
    });
  };

  manager.on('add', trackAdded);
  manager.on('remove', trackRemoved);
  const unsubscribe = () => {
    manager.off('add', trackAdded);
    manager.off('remove', trackRemoved);
  };
  return unsubscribe;
}

/***/ }),

/***/ "./src/webrtc/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeStack = initializeStack;
exports.default = webRtcPlugin;

var _interface = __webpack_require__("./src/webrtc/interface/index.js");

var _interface2 = _interopRequireDefault(_interface);

var _events = __webpack_require__("./src/webrtc/interface/events/index.js");

var _events2 = _interopRequireDefault(_events);

var _channels = __webpack_require__("./src/webrtc/channels/index.js");

var _channels2 = _interopRequireDefault(_channels);

var _sagas = __webpack_require__("./src/webrtc/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _utils = __webpack_require__("./src/common/utils.js");

var _kandyWebrtc = __webpack_require__("../webrtc/src/interface/index.js");

var _kandyWebrtc2 = _interopRequireDefault(_kandyWebrtc);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Helpers.
function initializeStack() {
  return (0, _kandyWebrtc2.default)();
}

// Libraries.


// Other plugins.
// Webrtc plugin.
function webRtcPlugin() {
  // Initialize the webRTC.
  const webRTC = (0, _kandyWebrtc2.default)();

  function* init({ webRTC }) {
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));

    // Wrap the webrtc sagas in a function that provides them with the webRTC stack.
    const wrappedSagas = (0, _fp.values)(sagas).map(saga => {
      return (0, _utils.autoRestart)(() => saga(webRTC.managers));
    });

    // Run all of the sagas.
    for (let saga of wrappedSagas) {
      yield (0, _effects.fork)(saga);
    }

    // Watch for events from the webRTC stack.
    // TODO: Don't also pass in the entire stack.
    yield (0, _effects.fork)(_channels2.default, webRTC.managers, webRTC);
  }

  return {
    name: _interface2.default.name,
    api: _interface2.default.api,
    reducer: _interface2.default.reducer,
    init,
    shared: {
      webRTC
    }
  };
}

/***/ }),

/***/ "./src/webrtc/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const prefix = '@@KANDY/WEBRTC/';

/**
 * Device action types.
 */
const DEVICES_CHANGE = exports.DEVICES_CHANGE = prefix + 'DEVICES/CHANGE';

/**
 * Track action types.
 */
const trackPrefix = prefix + 'TRACK/';

const TRACK_ADDED = exports.TRACK_ADDED = trackPrefix + 'ADDED';
const TRACK_REMOVED = exports.TRACK_REMOVED = trackPrefix + 'REMOVED';

const RENDER_TRACKS = exports.RENDER_TRACKS = trackPrefix + 'RENDER';
const RENDER_TRACKS_FINISH = exports.RENDER_TRACKS_FINISH = trackPrefix + 'RENDER_FINISH';

const REMOVE_TRACKS = exports.REMOVE_TRACKS = trackPrefix + 'REMOVE';
const REMOVE_TRACKS_FINISH = exports.REMOVE_TRACKS_FINISH = trackPrefix + 'REMOVE_FINISH';

const MUTE_TRACKS = exports.MUTE_TRACKS = trackPrefix + 'MUTE';
const MUTE_TRACKS_FINISH = exports.MUTE_TRACKS_FINISH = trackPrefix + 'MUTE_FINISH';
const UNMUTE_TRACKS = exports.UNMUTE_TRACKS = trackPrefix + 'UNMUTE';
const UNMUTE_TRACKS_FINISH = exports.UNMUTE_TRACKS_FINISH = trackPrefix + 'UNMUTE_FINISH';

/**
 * Session action types.
 */
const sessionPrefix = prefix + 'SESSION/';

const SESSION_ADDED = exports.SESSION_ADDED = sessionPrefix + 'ADDED';
const SESSION_REMOVED = exports.SESSION_REMOVED = sessionPrefix + 'REMOVED';

const SESSION_NEW_TRACK = exports.SESSION_NEW_TRACK = sessionPrefix + 'NEW_TRACK';
const SESSION_TRACK_ENDED = exports.SESSION_TRACK_ENDED = sessionPrefix + 'TRACK_ENDED';
const SESSION_CHANGE = exports.SESSION_CHANGE = sessionPrefix + 'CHANGE';

/**
 * Media action types.
 */
const mediaPrefix = prefix + 'MEDIA/';

const MEDIA_NEW = exports.MEDIA_NEW = mediaPrefix + 'NEW';
const MEDIA_REMOVED = exports.MEDIA_REMOVED = mediaPrefix + 'REMOVED';
const MEDIA_CHANGE = exports.MEDIA_CHANGE = mediaPrefix + 'CHANGE';

const MEDIA_NEW_TRACK = exports.MEDIA_NEW_TRACK = mediaPrefix + 'NEW_TRACK';
const MEDIA_TRACK_REMOVED = exports.MEDIA_TRACK_REMOVED = mediaPrefix + 'TRACK_REMOVED';
const MEDIA_TRACK_ENDED = exports.MEDIA_TRACK_ENDED = mediaPrefix + 'TRACK_ENDED';

/***/ }),

/***/ "./src/webrtc/interface/actions/devices.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.devicesChanged = devicesChanged;

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function devicesChanged(devices) {
  return {
    type: actionTypes.DEVICES_CHANGE,
    payload: devices
  };
} // Webrtc plugin.

/***/ }),

/***/ "./src/webrtc/interface/actions/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mediaActions = exports.sessionActions = exports.trackActions = exports.deviceActions = undefined;

var _devices = __webpack_require__("./src/webrtc/interface/actions/devices.js");

var deviceActionsImport = _interopRequireWildcard(_devices);

var _tracks = __webpack_require__("./src/webrtc/interface/actions/tracks.js");

var trackActionsImport = _interopRequireWildcard(_tracks);

var _sessions = __webpack_require__("./src/webrtc/interface/actions/sessions.js");

var sessionActionsImport = _interopRequireWildcard(_sessions);

var _media = __webpack_require__("./src/webrtc/interface/actions/media.js");

var mediaActionsImport = _interopRequireWildcard(_media);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Apparently the following doesn't work:
//      export * as newName from './place';
// So import everything from each file, then re-export.
const deviceActions = exports.deviceActions = deviceActionsImport;
const trackActions = exports.trackActions = trackActionsImport;
const sessionActions = exports.sessionActions = sessionActionsImport;
const mediaActions = exports.mediaActions = mediaActionsImport;

/***/ }),

/***/ "./src/webrtc/interface/actions/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.newMedia = newMedia;
exports.removedMedia = removedMedia;
exports.mediaNewTrack = mediaNewTrack;
exports.mediaTrackRemoved = mediaTrackRemoved;
exports.mediaTrackEnded = mediaTrackEnded;

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Webrtc plugin.
function mediaActionHelper(type, id, payload = {}, meta = {}) {
  const action = {
    type,
    payload: (0, _extends3.default)({}, payload, {
      id
    })

    // Only have meta and error properties on the action if they're needed.
  };if (!(0, _fp.isEmpty)(meta)) {
    action.meta = meta;
  }
  if (payload.error) {
    action.error = true;
  }
  return action;
}

// Libraries.
function newMedia(id, params) {
  return mediaActionHelper(actionTypes.MEDIA_NEW, id, params);
}

function removedMedia(id, params) {
  return mediaActionHelper(actionTypes.MEDIA_REMOVED, id, params);
}

function mediaNewTrack(id, params) {
  return mediaActionHelper(actionTypes.MEDIA_NEW_TRACK, id, params);
}

function mediaTrackRemoved(id, params) {
  return mediaActionHelper(actionTypes.MEDIA_TRACK_REMOVED, id, params);
}

function mediaTrackEnded(id, params) {
  return mediaActionHelper(actionTypes.MEDIA_TRACK_ENDED, id, params);
}

/***/ }),

/***/ "./src/webrtc/interface/actions/sessions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.sessionAdded = sessionAdded;
exports.sessionRemoved = sessionRemoved;
exports.sessionNewTrack = sessionNewTrack;
exports.sessionTrackEnded = sessionTrackEnded;
exports.sessionChange = sessionChange;

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Call plugin.
function sessionActionHelper(type, id, payload = {}, meta = {}) {
  const action = {
    type,
    payload: (0, _extends3.default)({}, payload, {
      id
    })

    // Only have meta and error properties on the action if they're needed.
  };if (!(0, _fp.isEmpty)(meta)) {
    action.meta = meta;
  }
  if (payload.error) {
    action.error = true;
  }
  return action;
}

// Libraries.
function sessionAdded(id, params) {
  return sessionActionHelper(actionTypes.SESSION_ADDED, id, params);
}

function sessionRemoved(id, params) {
  return sessionActionHelper(actionTypes.SESSION_REMOVED, id, params);
}

function sessionNewTrack(id, params) {
  return sessionActionHelper(actionTypes.SESSION_NEW_TRACK, id, params);
}

function sessionTrackEnded(id, params) {
  return sessionActionHelper(actionTypes.SESSION_TRACK_ENDED, id, params);
}

function sessionChange(id, params) {
  return sessionActionHelper(actionTypes.SESSION_CHANGE, id, params);
}

/***/ }),

/***/ "./src/webrtc/interface/actions/tracks.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.trackAdded = trackAdded;
exports.trackRemoved = trackRemoved;
exports.muteTracks = muteTracks;
exports.muteTracksFinish = muteTracksFinish;
exports.unmuteTracks = unmuteTracks;
exports.unmuteTracksFinish = unmuteTracksFinish;
exports.renderTracks = renderTracks;
exports.renderTracksFinish = renderTracksFinish;
exports.removeTracks = removeTracks;
exports.removeTracksFinish = removeTracksFinish;

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trackManagerHelper(type, trackId, payload = {}, meta = {}) {
  return {
    type,
    payload: (0, _extends3.default)({}, payload, {
      trackId
    }),
    meta
  };
} // Call plugin.
function trackAdded(trackId, params) {
  return trackManagerHelper(actionTypes.TRACK_ADDED, trackId, params);
}

function trackRemoved(trackId, params) {
  return trackManagerHelper(actionTypes.TRACK_REMOVED, trackId, params);
}

function trackHelper(type, payload = {}, meta = {}) {
  return {
    type,
    payload,
    meta
  };
}

function muteTracks(trackIds) {
  return trackHelper(actionTypes.MUTE_TRACKS, trackIds);
}

function muteTracksFinish(trackIds) {
  return trackHelper(actionTypes.MUTE_TRACKS_FINISH, trackIds);
}

function unmuteTracks(trackIds) {
  return trackHelper(actionTypes.UNMUTE_TRACKS, trackIds);
}

function unmuteTracksFinish(trackIds) {
  return trackHelper(actionTypes.UNMUTE_TRACKS_FINISH, trackIds);
}

function renderTracks(trackIds, params) {
  return trackHelper(actionTypes.RENDER_TRACKS, (0, _extends3.default)({
    trackIds
  }, params));
}

function renderTracksFinish(trackIds, params) {
  return trackHelper(actionTypes.RENDER_TRACKS_FINISH, (0, _extends3.default)({
    trackIds
  }, params));
}

function removeTracks(trackIds, params) {
  return trackHelper(actionTypes.REMOVE_TRACKS, (0, _extends3.default)({
    trackIds
  }, params));
}

function removeTracksFinish(trackIds, params) {
  return trackHelper(actionTypes.REMOVE_TRACKS_FINISH, (0, _extends3.default)({
    trackIds
  }, params));
}

/***/ }),

/***/ "./src/webrtc/interface/api/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _media = __webpack_require__("./src/webrtc/interface/api/media.js");

var _media2 = _interopRequireDefault(_media);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Public API for the webRTC plugin.
 * @method api
 * @return {Object}
 */
function api(context) {
  return {
    media: (0, _media2.default)(context)
  };
}

/***/ }),

/***/ "./src/webrtc/interface/api/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.default = mediaAPI;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _selectors = __webpack_require__("./src/webrtc/interface/selectors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Media related APIs.
 * @method mediaAPI
 * @param  {Function} dispatch Redux dispatch.
 * @param  {Function} getState Redux getState.
 * @return {Object}
 */
// Webrtc plugin.
function mediaAPI({ dispatch, getState }) {
  return {
    /**
     * Retrieves the available media devices for use.
     * @public
     * @memberof Media
     * @method getDevices
     * @return {Object} The lists of camera, microphone, and speaker devices.
     */
    getDevices() {
      return (0, _selectors.getDevices)(getState());
    },

    /**
     * Retrieve a media object from state with a specific media ID.
     * @public
     * @memberof Media
     * @method getById
     * @param  {string} mediaId The ID of the media to retrieve.
     * @return {MediaObject} A media object.
     */
    getById(mediaId) {
      return (0, _selectors.getMediaById)(getState(), mediaId);
    },

    /**
     * Retrieve a Track object from state with a specific ID.
     * @public
     * @memberof Media
     * @method getTrackById
     * @param  {string} trackId The ID of the track to retrieve.
     * @return {Object} A track object.
     */
    getTrackById(trackId) {
      return (0, _selectors.getTrackById)(getState(), trackId);
    },

    /**
     * Render media Tracks in a container.
     * The container is specified by providing a CSS selector string that corresponds to the HTMLElement to act as the container.
     * @public
     * @memberof Media
     * @method renderTracks
     * @param  {Array}  tracks List of Track IDs to be rendered.
     * @param  {string} cssSelector A CSS selector string that uniquely identifies an element. Ensure that special characters are properly escaped.
     * @param  {Object} [options] Additional options for rendering the tracks.
     * @param  {string} [options.speakerId] The device ID of the speaker to use for audio tracks.
     * @example
     * // When an outgoing call is accepted, render the media used for the call.
     * client.on('call:accepted', function (params) {
     *     // Get the information about the call.
     *     const call = client.call.getById(params.callId)
     *
     *     // Render the call's local and remote media in their respective containers.
     *     client.media.render(call.localMedia[0], localContainer)
     *     client.media.render(call.remoteMedia[0], remoteContainer)
     * })
     */
    renderTracks(tracks, cssSelector, options = {}) {
      dispatch(_actions.trackActions.renderTracks(tracks, (0, _extends3.default)({
        selector: cssSelector
      }, options)));
    },

    /**
     * Remove media Tracks from a container.
     * The container is specified by providing a CSS selector string that corresponds to the HTMLElement to act as the container.
     * @public
     * @memberof Media
     * @method removeTracks
     * @param  {Array}  tracks List of Track IDs to stop being rendered.
     * @param  {string} cssSelector A CSS selector string that uniquely identifies an element. Ensure that special characters are properly escaped.
     */
    removeTracks(tracks, cssSelector) {
      dispatch(_actions.trackActions.removeTracks(tracks, { selector: cssSelector }));
    },

    /**
     * Mutes the specified tracks.
     * Prevents media from being received for the tracks. Audio tracks will become silent and video tracks will be a black frame.
     * @public
     * @memberof Media
     * @method muteTracks
     * @param  {Array} tracks List of Track IDs.
     */
    muteTracks(tracks) {
      dispatch(_actions.trackActions.muteTracks(tracks));
    },

    /**
     * Unmutes the specified tracks.
     * Media will resume as normal for the tracks.
     * @public
     * @memberof Media
     * @method unmuteTracks
     * @param  {Array} tracks List of Track IDs.
     */
    unmuteTracks(tracks) {
      dispatch(_actions.trackActions.unmuteTracks(tracks));
    }
  };
}

/***/ }),

/***/ "./src/webrtc/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Media devices available for use have changed.
 * Use the `getDevices` media API to retrieve the lists of devices.
 * @public
 * @memberof Media
 * @event devices:change
 * @example
 * // Listen for changes to available media devices.
 * client.on('devices:change', function () {
 *    // Retrieve the latest media device lists.
 *    const devices = client.media.getDevices()
 * })
 */
const DEVICES_CHANGED = exports.DEVICES_CHANGED = 'devices:change';

/**
 * The specified Tracks have been muted.
 * @public
 * @memberof Media
 * @event media:muted
 * @param {Object} params
 * @param {Array<string>} params.tracks The list of Tracks that were muted.
 */
const TRACKS_MUTED = exports.TRACKS_MUTED = 'media:muted';

/**
 * The specified Tracks have been unmuted.
 * @public
 * @memberof Media
 * @event media:unmuted
 * @param {Object} params
 * @param {Array<string>} params.tracks The list of Tracks that were unmuted.
 */
const TRACKS_UNMUTED = exports.TRACKS_UNMUTED = 'media:unmuted';

/***/ }),

/***/ "./src/webrtc/interface/events/devices.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/webrtc/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const events = {};

// Media devices have changed.
events[actionTypes.DEVICES_CHANGE] = action => {
  return {
    type: eventTypes.DEVICES_CHANGED
  };
};

exports.default = events;

/***/ }),

/***/ "./src/webrtc/interface/events/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _devices = __webpack_require__("./src/webrtc/interface/events/devices.js");

var _devices2 = _interopRequireDefault(_devices);

var _tracks = __webpack_require__("./src/webrtc/interface/events/tracks.js");

var _tracks2 = _interopRequireDefault(_tracks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _extends3.default)({}, _devices2.default, _tracks2.default);

/***/ }),

/***/ "./src/webrtc/interface/events/tracks.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventTypes = __webpack_require__("./src/webrtc/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const events = {};

events[actionTypes.MUTE_TRACKS_FINISH] = action => {
  return {
    type: eventTypes.TRACKS_MUTED,
    args: { tracks: action.payload }
  };
};

events[actionTypes.UNMUTE_TRACKS_FINISH] = action => {
  return {
    type: eventTypes.TRACKS_UNMUTED,
    args: { tracks: action.payload }
  };
};

exports.default = events;

/***/ }),

/***/ "./src/webrtc/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/webrtc/interface/api/index.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/webrtc/interface/reducers/index.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'webrtc',
  api: _api2.default,
  reducer: _reducers2.default
};

/***/ }),

/***/ "./src/webrtc/interface/reducers/devices.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * The devices substate keeps tracks the of the media devices available for use.
 */
// Call plugin.
const reducers = {};

// Replace old devices with newly checked devices.


// Libraries.
reducers[actionTypes.DEVICES_CHANGE] = {
  next(state, action) {
    return action.payload;
  }
};

// The initial state of the reducer.
const defaultState = {
  camera: [],
  microphone: [],
  speaker: []
};

const reducer = (0, _reduxActions.handleActions)(reducers, defaultState);
exports.default = reducer;

/***/ }),

/***/ "./src/webrtc/interface/reducers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (state = {}, action) {
  return {
    devices: (0, _devices2.default)(state.devices, action),
    tracks: (0, _tracks2.default)(state.tracks, action),
    sessions: (0, _sessions2.default)(state.sessions, action),
    media: (0, _media2.default)(state.media, action)
  };
};

var _devices = __webpack_require__("./src/webrtc/interface/reducers/devices.js");

var _devices2 = _interopRequireDefault(_devices);

var _media = __webpack_require__("./src/webrtc/interface/reducers/media.js");

var _media2 = _interopRequireDefault(_media);

var _tracks = __webpack_require__("./src/webrtc/interface/reducers/tracks.js");

var _tracks2 = _interopRequireDefault(_tracks);

var _sessions = __webpack_require__("./src/webrtc/interface/reducers/sessions.js");

var _sessions2 = _interopRequireDefault(_sessions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/webrtc/interface/reducers/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Top-tier reducers: Handles the whole state.


// Libraries.
const reducers = {};

// Add the new media object to state.
// Webrtc plugin.
reducers[actionTypes.MEDIA_NEW] = {
  next(state, action) {
    return (0, _fp.concat)(state, (0, _extends3.default)({}, action.payload));
  }
};

// Remove the media object from state.
reducers[actionTypes.MEDIA_REMOVED] = {
  next(state, action) {
    const removeMedia = media => media.id === action.payload.id;
    return (0, _fp.remove)(removeMedia)(state);
  }
};

// Media-tier reducers: Handles only a specific portion of the substate.
const mediaReducers = {};

mediaReducers[actionTypes.MEDIA_NEW_TRACK] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      tracks: (0, _fp.concat)(state.tracks, [action.payload.trackId])
    });
  }
};

// Remove specified track from media state.
mediaReducers[actionTypes.MEDIA_TRACK_REMOVED] = {
  next(state, action) {
    const removeTrack = trackId => trackId === action.payload.trackId;
    return (0, _extends3.default)({}, state, {
      tracks: (0, _fp.remove)(removeTrack, state.tracks)
    });
  }
};

// Remove specified track from media state.
mediaReducers[actionTypes.MEDIA_TRACK_ENDED] = {
  next(state, action) {
    const removeTrack = trackId => trackId === action.payload.trackId;
    return (0, _extends3.default)({}, state, {
      tracks: (0, _fp.remove)(removeTrack, state.tracks)
    });
  }
};
const mediaReducer = (0, _reduxActions.handleActions)(mediaReducers, {});

const specificMediaActions = (0, _reduxActions.combineActions)(actionTypes.MEDIA_NEW_TRACK, actionTypes.MEDIA_TRACK_REMOVED, actionTypes.MEDIA_TRACK_ENDED);

reducers[specificMediaActions] = (state, action) => {
  return state.map(media => {
    if (media.id === action.payload.id) {
      return mediaReducer(media, action);
    } else {
      return media;
    }
  });
};

/*
 * Combine all of top-tier reducers into a single reducer,
 *      each with a default state of an empty array.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, []);
exports.default = reducer;

/***/ }),

/***/ "./src/webrtc/interface/reducers/sessions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries.
const reducers = {}; // Webrtc plugin.


reducers[actionTypes.SESSION_ADDED] = {
  next(state, action) {
    return (0, _fp.concat)(state, action.payload);
  }
};

reducers[actionTypes.SESSION_REMOVED] = {
  next(state, action) {
    const removeSession = session => session.id === action.payload.id;
    return (0, _fp.remove)(removeSession)(state);
  }
};

const sessionReducers = {};

sessionReducers[actionTypes.SESSION_NEW_TRACK] = {
  next(state, action) {
    if (action.payload.local) {
      return (0, _extends3.default)({}, state, {
        localTracks: (0, _fp.concat)(state.localTracks, [action.payload.trackId])
      });
    } else {
      return (0, _extends3.default)({}, state, {
        remoteTracks: (0, _fp.concat)(state.remoteTracks, [action.payload.trackId])
      });
    }
  }
};

sessionReducers[actionTypes.SESSION_TRACK_ENDED] = {
  next(state, action) {
    const removeTrack = trackId => trackId === action.payload.trackId;
    if (action.payload.local) {
      return (0, _extends3.default)({}, state, {
        localTracks: (0, _fp.remove)(removeTrack, state.localTracks)
      });
    } else {
      return (0, _extends3.default)({}, state, {
        remoteTracks: (0, _fp.remove)(removeTrack, state.remoteTracks)
      });
    }
  }
};

const sessionReducer = (0, _reduxActions.handleActions)(sessionReducers, {});

const specificSessionActions = (0, _reduxActions.combineActions)(actionTypes.SESSION_NEW_TRACK, actionTypes.SESSION_TRACK_ENDED);

reducers[specificSessionActions] = (state, action) => {
  return state.map(session => {
    if (session.id === action.payload.id) {
      return sessionReducer(session, action);
    } else {
      return session;
    }
  });
};

/*
 * Combine all of top-tier reducers into a single reducer,
 *      each with a default state of an empty array.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, []);
exports.default = reducer;

/***/ }),

/***/ "./src/webrtc/interface/reducers/tracks.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries.
const reducers = {};

// Add the new Track to state.
// Webrtc plugin.
reducers[actionTypes.TRACK_ADDED] = {
  next(state, action) {
    return (0, _fp.concat)(state, action.payload);
  }
};

// Remove the ended Track from state.
reducers[actionTypes.TRACK_REMOVED] = {
  next(state, action) {
    const removeTrack = track => track.trackId === action.payload.trackId;
    return (0, _fp.remove)(removeTrack)(state);
  }
};

// Store the selector used for rendering the track.
reducers[actionTypes.RENDER_TRACKS_FINISH] = {
  next(state, action) {
    return state.map(track => {
      if (action.payload.trackIds.includes(track.trackId)) {
        return (0, _extends3.default)({}, track, {
          containers: (0, _fp.concat)(track.containers, action.payload.selector)
        });
      } else {
        return track;
      }
    });
  }
};

// Remove the selector used for rendering the track.
reducers[actionTypes.REMOVE_TRACKS_FINISH] = {
  next(state, action) {
    // TODO: Only remove one container (instead of all that match)?
    const removeContainer = container => container === action.payload.selector;
    return state.map(track => {
      if (action.payload.trackIds.includes(track.trackId)) {
        return (0, _extends3.default)({}, track, {
          containers: (0, _fp.remove)(removeContainer)(track.containers)
        });
      } else {
        return track;
      }
    });
  }
};

// TODO: Update this on an action from the track channel?
reducers[actionTypes.MUTE_TRACKS_FINISH] = {
  next(state, action) {
    return state.map(track => {
      if (action.payload.includes(track.trackId)) {
        return (0, _extends3.default)({}, track, {
          muted: true
        });
      } else {
        return track;
      }
    });
  }
};

reducers[actionTypes.UNMUTE_TRACKS_FINISH] = {
  next(state, action) {
    return state.map(track => {
      if (action.payload.includes(track.trackId)) {
        return (0, _extends3.default)({}, track, {
          muted: false
        });
      } else {
        return track;
      }
    });
  }
};

/*
 * Combine all of top-tier reducers into a single reducer,
 *      each with a default state of an empty array.
 */
const reducer = (0, _reduxActions.handleActions)(reducers, []);
exports.default = reducer;

/***/ }),

/***/ "./src/webrtc/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDevices = getDevices;
exports.getSessions = getSessions;
exports.getSessionById = getSessionById;
exports.getTracks = getTracks;
exports.getTrackById = getTrackById;
exports.getMedia = getMedia;
exports.getMediaById = getMediaById;
exports.getMediaByCallId = getMediaByCallId;

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

/**
 * Retrieves media devices available on the system.
 * @method getDevices
 * @param  {Object} state Redux state.
 * @return {Object}
 */
function getDevices(state) {
  return state.webrtc.devices;
}

/**
 * Session selectors.
 */
// Call plugin.
function getSessions(state) {
  return state.webrtc.sessions;
}

function getSessionById(state, sessionId) {
  return getSessions(state).find(session => session.id === sessionId);
}

/**
 * Track selectors.
 */
function getTracks(state) {
  return state.webrtc.tracks;
}

function getTrackById(state, trackId) {
  return getTracks(state).find(track => track.trackId === trackId);
}

/**
 * Media selectors.
 * Handles retrieving data from the `state.webrtc.media` substate.
 */

/**
 * Get the list of all media this session.
 * @method getMedia
 * @param  {Object} state Redux state.
 * @return {Array} A list of all media objects.
 */
function getMedia(state) {
  return state.webrtc.media;
}

/**
 * Get a specific media object.
 * @method getMediaById
 * @param  {Object} state Redux state.
 * @param  {string} mediaId The media to retrieve.
 * @return {Object} A media object.
 */
function getMediaById(state, mediaId) {
  return getMedia(state).find(media => media.id === mediaId);
}

/**
 * Get all media objects associated with a specific call.
 * @method getMediaByCallId
 * @param  {Object} state Redux state.
 * @param  {string} callId The call to retrieve media objects from.
 * @return {Array} A list of media objects.
 */
function getMediaByCallId(state, callId) {
  const call = (0, _selectors.getCallById)(state, callId);
  if (call) {
    const mediaIds = call.localMedia.concat(call.remoteMedia);
    return mediaIds.map(mediaId => getMediaById(state, mediaId));
  } else {
    return [];
  }
}

/***/ }),

/***/ "./src/webrtc/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTracks = renderTracks;
exports.removeTracks = removeTracks;
exports.muteTracks = muteTracks;
exports.unmuteTracks = unmuteTracks;

var _media = __webpack_require__("./src/webrtc/sagas/media.js");

var mediaSagas = _interopRequireWildcard(_media);

var _actionTypes = __webpack_require__("./src/webrtc/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Track operations.
 */

/**
 * Handle rendering Track objects.
 * @method renderTracks
 * @param  {Object} webRTC The webRTC stack.
 */
function* renderTracks(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.RENDER_TRACKS, mediaSagas.renderTracks, webRTC);
}

/**
 * Handle removing Track objects.
 * @method removeTracks
 * @param  {Object} webRTC The webRTC stack.
 */


// Libraries.
// Webrtc plugin.
function* removeTracks(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.REMOVE_TRACKS, mediaSagas.removeTracks, webRTC);
}

/**
 * Handle muting tracks.
 * @method muteTracks
 * @param  {Object} webRTC The webRTC stack.
 */
function* muteTracks(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.MUTE_TRACKS, mediaSagas.muteTracks, webRTC);
}

/**
 * Handle unmuting tracks.
 * @method unmuteTracks
 * @param  {Object} webRTC The webRTC stack.
 */
function* unmuteTracks(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.UNMUTE_TRACKS, mediaSagas.unmuteTracks, webRTC);
}

/***/ }),

/***/ "./src/webrtc/sagas/media.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTracks = renderTracks;
exports.removeTracks = removeTracks;
exports.muteTracks = muteTracks;
exports.unmuteTracks = unmuteTracks;

var _actions = __webpack_require__("./src/webrtc/interface/actions/index.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _documentTools = __webpack_require__("./src/webrtc/utils/documentTools.js");

/**
 * Render Tracks in a specified container.
 * @method renderTracks
 * @param  {Object} action A "render tracks" action.
 */
// Call plugin.
function* renderTracks(webRTC, action) {
  // Get the tracks that are to be rendered.
  const tracks = yield (0, _effects.call)([webRTC.track, 'getTracks'], action.payload.trackIds);
  const filteredTracks = tracks.filter(track => !(0, _fp.isUndefined)(track));

  // Get the container the tracks are to be rendered in.
  const container = yield (0, _effects.call)(_documentTools.findContainer, action.payload.selector);
  if (!container) {
    return;
  }

  const speakerId = action.payload.speakerId;

  // Render the tracks.
  yield (0, _effects.all)(filteredTracks.map(track => (0, _effects.call)([track, 'renderIn'], container, speakerId)));

  // Report operation done.
  yield (0, _effects.put)(_actions.trackActions.renderTracksFinish(filteredTracks.map(track => track.id), {
    selector: action.payload.selector
  }));
}

/**
 * Stop Tracks from being rendered in a specified container.
 * @method removeTracks
 * @param  {Object} action A "remove tracks" action.
 */


// Libraries.
function* removeTracks(webRTC, action) {
  // Get the tracks that are to be removed.
  const allTracks = yield (0, _effects.call)([webRTC.track, 'getTracks']);
  const tracks = allTracks.filter(track => action.payload.trackIds.includes(track.id));

  // Get the container the tracks are to be rendered in.
  const container = yield (0, _effects.call)(_documentTools.findContainer, action.payload.selector);
  if (!container) {
    return;
  }

  // Remove the tracks.
  yield (0, _effects.all)(tracks.map(track => (0, _effects.call)([track, 'removeFrom'], container)));

  // Report operation done.
  yield (0, _effects.put)(_actions.trackActions.removeTracksFinish(tracks.map(track => track.id), {
    selector: action.payload.selector
  }));
}

/**
 * Mute certain tracks.
 * @method muteTracks
 * @param  {Object} action
 * @param  {Array} action.payload A list of track IDs.
 */
function* muteTracks(webRTC, action) {
  // Get the tracks that are to be muted.
  const allTracks = yield (0, _effects.call)([webRTC.track, 'getTracks']);
  const tracks = allTracks.filter(track => action.payload.includes(track.id));

  // Mute the tracks.
  yield (0, _effects.all)(tracks.map(track => (0, _effects.call)([track, 'mute'])));

  // Report operation done.
  yield (0, _effects.put)(_actions.trackActions.muteTracksFinish(tracks.map(track => track.id)));
}

/**
 * Unmute certain tracks.
 * @method unmuteTracks
 * @param  {Object} action
 * @param  {Array} action.payload A list of track IDs.
 */
function* unmuteTracks(webRTC, action) {
  // Get the tracks that are to be unmuted.
  const allTracks = yield (0, _effects.call)([webRTC.track, 'getTracks']);
  const tracks = allTracks.filter(track => action.payload.includes(track.id));

  // Unmute the tracks.
  yield (0, _effects.all)(tracks.map(track => (0, _effects.call)([track, 'unmute'])));

  // Report operation done.
  yield (0, _effects.put)(_actions.trackActions.unmuteTracksFinish(tracks.map(track => track.id)));
}

/***/ }),

/***/ "./src/webrtc/utils/documentTools.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findContainer = findContainer;

var _logs = __webpack_require__("./src/logs/index.js");

const log = (0, _logs.getLogManager)().getLogger('MEDIA');

/**
 * Find an html container based on the given selector.
 * @method findContainer
 * @param {string} selector The selector to use when querying the document.
 * @return {Object} The container object (undefined if not found).
 */
function findContainer(selector) {
  let container;
  try {
    container = document.querySelector(selector);
    if (!container) {
      throw new Error('Element not found.');
    }
  } catch (e) {
    log.error(`Unable to get container with selector: "${selector}". Error: ${e}`);
  }
  return container;
}

/***/ }),

/***/ "./src/webrtcProxy/channel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = wrapChannel;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wraps a channel with only `send` and `receive` functionality into one that
 *    also has `reply` functionality.
 * This is required by the Proxy Plugin to convert asynchronous code into
 *    synchronous code. The Proxy needs to return a value synchronously when
 *    sending data over the channel.
 * @method wrapChannel
 * @param  {Object} channel
 * @return {Object} The same channel, but with a `reply` method as well.
 */
function wrapChannel(channel) {
  /**
   * Track sent messages by their ID.
   * @type {Object}
   */
  const sentMessages = {};

  channel.receive = function receiveMessage(message) {
    const { messageId, data } = message;

    // Determine how the message needs to be handled.
    if (messageId && sentMessages[messageId]) {
      // If the message has an ID from a sent message, then it is a reply to
      //    that message. Resolve the promise associated with it.
      sentMessages[messageId].resolve(data);
    } else if (messageId && !sentMessages[messageId]) {
      // If the message has an ID that we don't know about, then the application
      //    will need to handle it.
      if (api.receive) {
        api.receive(messageId, data);
      } else {
        console.log('No listener for receiving messages.', data);
      }
    } else {
      // If the message didn't have an ID, then it wasn't from our test channel.
      console.log('Unknown message.');
    }
  };

  /*
   * The interface that the Proxy Plugin will use.
   */
  const api = {};

  /**
   * Send a message over the channel.
   * @method send
   * @param {string} messageId A unique ID to track the sent message.
   * @param {Object} data
   * @param {Function} callback Function called when a reply is received.
   */
  api.send = (messageId, data, callback) => {
    if (sentMessages[messageId]) {
      // The ID has already been used for sending a message.
      callback(null, new Error('Cannot send message; ID already used.'));
      return;
    }

    // Attach a messageId to the message.
    // This lets the remote side reply to this message by using the messageId.
    const message = {
      data,
      messageId

      // Wrap `send` is a promise so that we can correlate receiving a reply
      //    to the callback.
    };new _promise2.default(resolve => {
      // Store `resolve` so we can call it call it when we receive a reply.
      sentMessages[messageId] = {
        resolve
        // Send the message over the channel.
      };channel.send(message);
    }).then(data => {
      // The message received a reply, so remove the reference.
      delete sentMessages[messageId];
      console.debug('Received response for message: ', messageId);
      if (typeof callback === 'function') {
        callback(data);
      }
    });
  };

  /**
   * Listener for receiving a message from the channel.
   * @method receive
   * @param {string} messageId
   * @param {Object} data
   */
  // eslint-disable-next-line
  api.receive = undefined;

  /**
   * Send a reply to a specific received message over the channel.
   * @method reply
   * @param {string} messageId
   * @param {Object} data
   */
  api.reply = (messageId, data) => {
    console.debug(`Replying to message ${messageId}.`, data);

    // Attach the messageId to the message.
    const message = {
      data,
      messageId
    };

    channel.send(message);
  };

  return api;
}

/***/ }),

/***/ "./src/webrtcProxy/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = proxyPlugin;

var _interface = __webpack_require__("./src/webrtcProxy/interface/index.js");

var _interface2 = _interopRequireDefault(_interface);

var _proxyStack = __webpack_require__("./src/webrtcProxy/proxyStack.js");

var _proxyStack2 = _interopRequireDefault(_proxyStack);

var _sagas = __webpack_require__("./src/webrtcProxy/sagas/index.js");

var sagas = _interopRequireWildcard(_sagas);

var _events = __webpack_require__("./src/webrtcProxy/interface/events.js");

var _events2 = _interopRequireDefault(_events);

var _actions = __webpack_require__("./src/events/interface/actions.js");

var _utils = __webpack_require__("./src/common/utils.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _kandyWebrtc = __webpack_require__("../webrtc/src/interface/index.js");

var _kandyWebrtc2 = _interopRequireDefault(_kandyWebrtc);

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Other plugins.
// Proxy Plugin.
const log = (0, _logs.getLogManager)().getLogger('PROXY');

/**
 * Proxy Plugin factory.
 * The Proxy Plugin is responsible for setting up the webRTC /
 *    Media Proxy within the SDK. This includes replacing the
 *    webRTC stack with a Proxy stack, providing an interface
 *    for an application to configure the Proxy stack, and,
 *    in general, bringing all of the Proxy components together.
 * @method proxyPlugin
 * @return {Object} Plugin components.
 */


// Libraries.


// Helpers.
function proxyPlugin() {
  // TODO: Options.

  // Initialize a real webRTC stack.
  const webRTC = (0, _kandyWebrtc2.default)();
  // Initialize the Proxy stack. The real webRTC stack is needed for
  //    when proxy-mode is disbled.
  const proxy = (0, _proxyStack2.default)(webRTC);

  function* init({ webRTC }) {
    yield (0, _effects.put)((0, _actions.mapEvents)(_events2.default));

    // Make sure that webRTC is the Proxy Stack.
    if (!webRTC.setProxyMode || !(0, _fp.isFunction)(webRTC.setProxyMode)) {
      log.error('Cannot setup Proxy Plugin: Proxy Stack not found.');
      return;
    }

    // Wrap the sagas in a function that provides them with the proxy stack.
    const wrappedSagas = (0, _fp.values)(sagas).map(saga => {
      return (0, _utils.autoRestart)(() => saga(webRTC));
    });

    // Run all of the sagas.
    for (let saga of wrappedSagas) {
      yield (0, _effects.fork)(saga);
    }
  }

  return {
    name: _interface2.default.name,
    api: _interface2.default.api,
    reducer: _interface2.default.reducer,
    init,
    shared: {
      // Share the Proxy stack with the factory. The intention is that this
      //    will replace the webRTC stack the Webrtc plugin previously shared.
      webRTC: proxy
    }
  };
}

/***/ }),

/***/ "./src/webrtcProxy/interface/actionTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const PREFIX = '@@KANDY/PROXY/';

const SET_MODE = exports.SET_MODE = PREFIX + 'SET_MODE';
const SET_MODE_FINISH = exports.SET_MODE_FINISH = PREFIX + 'SET_MODE_FINISH';

const SET_CHANNEL = exports.SET_CHANNEL = PREFIX + 'SET_CHANNEL';
const SET_CHANNEL_FINISH = exports.SET_CHANNEL_FINISH = PREFIX + 'SET_CHANNEL_FINISH';

const INITIALIZE = exports.INITIALIZE = PREFIX + 'INITIALIZE';
const INITIALIZE_FINISH = exports.INITIALIZE_FINISH = PREFIX + 'INITIALIZE_FINISH';

/***/ }),

/***/ "./src/webrtcProxy/interface/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

exports.setProxyMode = setProxyMode;
exports.setProxyModeFinish = setProxyModeFinish;
exports.setChannel = setChannel;
exports.setChannelFinish = setChannelFinish;
exports.initializeRemote = initializeRemote;
exports.initializeRemoteFinish = initializeRemoteFinish;

var _actionTypes = __webpack_require__("./src/webrtcProxy/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function actionHelper(type, payload = {}) {
  const action = {
    type,
    payload: (0, _extends3.default)({}, payload)
  };

  if (payload.error) {
    action.error = true;
  }

  return action;
}

function setProxyMode(value) {
  return actionHelper(actionTypes.SET_MODE, { value });
}

function setProxyModeFinish({ error, value }) {
  return actionHelper(actionTypes.SET_MODE_FINISH, { error, value });
}

function setChannel(channel) {
  return actionHelper(actionTypes.SET_CHANNEL, { channel });
}

function setChannelFinish({ error }) {
  return actionHelper(actionTypes.SET_CHANNEL_FINISH, { error });
}

function initializeRemote(config) {
  return actionHelper(actionTypes.INITIALIZE, { config });
}

function initializeRemoteFinish({ error }) {
  return actionHelper(actionTypes.INITIALIZE_FINISH, { error });
}

/***/ }),

/***/ "./src/webrtcProxy/interface/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = api;

var _actions = __webpack_require__("./src/webrtcProxy/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/webrtcProxy/interface/selectors.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Proxy Plugin API.
 * @method api
 * @param {Object} context
 * @param {Function} dispatch
 * @param {Function} getState
 * @return {Object} An API object.
 */
/**
 * The Proxy module allows for a secondary mode for making calls: proxy mode.
 * When proxy mode is enabled, the SDK will redirect webRTC / media operations from the current machine to a remote machine using a channel.
 * This is an advanced feature that enables support for Calls in particular scenarios that would otherwise not support them.
 *
 * @public
 * @module Proxy
 */

/**
 * The Channel object that the Proxy module needs to be provided.
 *
 * @public
 * @module Channel
 * @example
 * // The channel the application uses for communicating with a remote endpoint.
 * const appChannel = ...
 *
 * // The channel the application will provide to the Proxy module for use.
 * const channel = {
 *    send: function (data) {
 *      // Any encoding / wrapping needed for a Proxy message being sent
 *      //    over the channel.
 *      appChannel.sendMessage(data)
 *    },
 *    // The Proxy module will set this function.
 *    receive: undefined
 * }
 * appChannel.on('message', data => {
 *    // Any decoding / unwrapping needed for the received message.
 *    channel.receive(data)
 * })
 *
 * client.proxy.setChannel(channel)
 */

/**
 * Channel function that the Proxy module will use to send messages to the remote side.
 * @public
 * @memberof Channel
 * @name send
 * @function
 * @param {Object} data Message to be sent over the channel.
 */

/**
 * API that the Proxy module will assign a listener function for accepting received messages.
 * This function should receive all messages sent from the remote side of the channel.
 * @public
 * @memberof Channel
 * @name receive
 * @function
 * @param {Object} data The message received from the Channel.
 */

// Proxy plugin.
function api({ dispatch, getState }) {
  const api = {
    /**
     * Sets the mode for the Proxy Plugin.
     * When enabled, webRTC operations will be proxied over a channel. Enabling
     *    proxy mode requires a channel to have been set. See `setChannel` API.
     * When disabled, webRTC operation will occur as normal on the local machine.
     * @public
     * @memberof Proxy
     * @method setProxyMode
     * @param {boolean} value Whether proxy mode should be enabled.
     */
    setProxyMode(value) {
      dispatch(actions.setProxyMode(value));
    },

    /**
     * Retrieves the current mode of the Proxy Plugin.
     * @public
     * @memberof Proxy
     * @method getProxyMode
     * @return {boolean} Whether proxy mode is currently enabled.
     */
    getProxyMode() {
      return (0, _selectors.getProxyState)(getState()).proxyMode;
    },

    /*
     * Retrieve Proxy information.
     */
    getInfo() {
      return (0, _selectors.getProxyState)(getState());
    },

    /**
     * Sets the channel to be used while proxy mode is enabled.
     * @public
     * @memberof Proxy
     * @method setChannel
     * @param {Channel} channel See the `Channel` module for information.
     */
    setChannel(channel) {
      dispatch(actions.setChannel(channel));
    },

    /**
     * Sends an initialization message over the channel with webRTC configurations.
     * @public
     * @memberof Proxy
     * @method initializeRemote
     * @param  {Object} config
     */
    initializeRemote(config) {
      dispatch(actions.initializeRemote(config));
    }
  };

  // Namespace the API.
  return { proxy: api };
}

/***/ }),

/***/ "./src/webrtcProxy/interface/eventTypes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The Proxy state has changed.
 * Indicates either a change in the mode or the channel.
 * @public
 * @memberof Proxy
 * @event proxy:change
 */
const PROXY_CHANGE = exports.PROXY_CHANGE = 'proxy:change';

/**
 * An error has occurred with a Proxy operation.
 * @public
 * @memberof Proxy
 * @event proxy:error
 * @param {Object} params
 * @param {Object} params.error An error object.
 */
const PROXY_ERROR = exports.PROXY_ERROR = 'proxy:error';

/***/ }),

/***/ "./src/webrtcProxy/interface/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _actionTypes = __webpack_require__("./src/webrtcProxy/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _eventTypes = __webpack_require__("./src/webrtcProxy/interface/eventTypes.js");

var eventTypes = _interopRequireWildcard(_eventTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Proxy plugin.
const eventsMap = {};

/*
 * Handle Proxy actions as either a "success" (state has change) event
 *    or an "error" (couldn't do operation) event.
 * @method proxyEvents
 * @param {Action} action
 * @return {Event}
 */
const proxyEvents = action => {
  if (action.error) {
    return {
      type: eventTypes.PROXY_ERROR,
      args: {
        error: action.payload.error
      }
    };
  } else {
    return {
      type: eventTypes.PROXY_CHANGE
    };
  }
};

eventsMap[actionTypes.SET_MODE_FINISH] = proxyEvents;
eventsMap[actionTypes.SET_CHANNEL_FINISH] = proxyEvents;
eventsMap[actionTypes.INITIALIZE_FINISH] = proxyEvents;

exports.default = eventsMap;

/***/ }),

/***/ "./src/webrtcProxy/interface/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _api = __webpack_require__("./src/webrtcProxy/interface/api.js");

var _api2 = _interopRequireDefault(_api);

var _reducers = __webpack_require__("./src/webrtcProxy/interface/reducers.js");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Expose the components of the Proxy Interface as a single object.
 */
exports.default = {
  name: 'proxy',
  api: _api2.default,
  reducer: _reducers2.default
};

/***/ }),

/***/ "./src/webrtcProxy/interface/reducers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__("../../node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _actionTypes = __webpack_require__("./src/webrtcProxy/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _reduxActions = __webpack_require__("../../node_modules/redux-actions/es/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The reducer's default state.
// Proxy plugin.
const defaultState = {
  proxyMode: false,
  hasChannel: false,
  remoteInitialized: false
};

// Libraries.


const reducers = {};

// Proxy Mode has changed.
reducers[actionTypes.SET_MODE_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      proxyMode: action.payload.value
    });
  }
};

// A channel has been provided.
reducers[actionTypes.SET_CHANNEL_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      hasChannel: true
    });
  }
};

// The remote side has been initialized.
reducers[actionTypes.INITIALIZE_FINISH] = {
  next(state, action) {
    return (0, _extends3.default)({}, state, {
      remoteInitialized: true
    });
  }
};

const reducer = (0, _reduxActions.handleActions)(reducers, defaultState);
exports.default = reducer;

/***/ }),

/***/ "./src/webrtcProxy/interface/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProxyState = getProxyState;

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

/**
 * Selector functions.
 * Used to retrieve specific portions of redux state without
 *    needing to know the structure of state.
 */

/**
 * Retrieves the Proxy Plugin state.
 * @method getProxyState
 * @param {Object} state Redux state.
 * @return {Object} Proxy plugin state.
 */
function getProxyState(state) {
  return (0, _fp.cloneDeep)(state.proxy);
} // Libraries.

/***/ }),

/***/ "./src/webrtcProxy/proxies/manager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = function (base, actualManager) {
  // Hardcode `id` as manager, since this function is only for manager proxies.
  base.id = 'manager';

  return new Proxy(base, {
    /**
     * Proxy "getter" calls on the Proxy.
     * This function is called anytime a property on `base` is accessed,
     *    eg. `base.someProp`
     * @param {Object} objTarget base
     * @param {string} prop Property being accessed.
     * @param {Object} receiver The Proxy object.
     */
    get: function (objTarget, prop, receiver) {
      // If the Proxy Stack is not in proxy mode, return the property from the
      //    actual webRTC manager object.
      if (!objTarget.proxyMode || !objTarget.channel) {
        log.debug('Using local webRTC stack.');
        return actualManager[prop];
      }
      // Otherwise, the webRTC operation needs to be proxied over the channel.

      /*
       * Tell redux-saga that this is not a promise.
       * Otherwise it will handle it differently under-the-hood and break things.
       * Ref: github.com/redux-saga/redux-saga/blob/master/packages/is/src/index.js#L10
       */
      if (!objTarget[prop] && prop === 'then') {
        return undefined;
      }

      if (objTarget[prop]) {
        // If something that actually exists is being accessed,
        //    then return that thing.
        return objTarget[prop];
      } else {
        // Otherwise, it's probably accessing a prop that it
        //    expects to be a function. So return a function proxy.
        return new Proxy(() => {}, {
          /**
           * Proxy function calls.
           * This function is called when the dummy function is called,
           * @example
           *    const someProp = base.someProp  // Triggers the above `get`.
           *    someProp()                      // Triggers this `apply`.
           * @param  {Function} funcTarget The dummy function.
           * @param  {boolean} thisArg The `base` object wrapped by the first proxy layer.
           * @param  {Array}  args List of function parameters.
           */
          apply: function (funcTarget, thisArg, args) {
            // Assemble the webRTC command to be sent over the channel.
            const operation = {
              type: thisArg.type,
              id: thisArg.id,
              operation: prop,
              params: args
            };

            log.info('operation', operation);

            if (thisArg.proxyMode && thisArg.channel && thisArg.channel.send) {
              /*
               * All manager APIs will now return a Promise, even if they didn't
               *    before. This is needed to wait for the remote response.
               * Since sagas `yield` on these API calls, they will also wait
               *    until the promise resolves.
               */
              return new _promise2.default((resolve, reject) => {
                function callback(data) {
                  log.info('Callback: ', data);

                  if ((0, _fp.isArray)(data)) {
                    const proxies = data.map(obj => {
                      return (0, _model2.default)(obj, thisArg.channel);
                    });
                    resolve(proxies);
                  } else {
                    resolve((0, _model2.default)(data, thisArg.channel));
                  }
                }

                const messageId = (0, _v2.default)();
                thisArg.channel.send(messageId, operation, callback);
              });
            }
          }
        });
      }
    }
  });
};

var _model = __webpack_require__("./src/webrtcProxy/proxies/model.js");

var _model2 = _interopRequireDefault(_model);

var _logs = __webpack_require__("./src/logs/index.js");

var _fp = __webpack_require__("../../node_modules/lodash/fp.js");

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Libraries.
// Proxy plugin.
const log = (0, _logs.getLogManager)().getLogger('PROXY');

/**
 * Creates an ES6 Proxy to wrap a webRTC manager.
 * @method createManagerProxy
 * @param  {Object} base The base object being wrapped.
 * @param  {boolean} base.proxyMode Whether operations should be proxied or not.
 * @param  {string} base.type The type of manager this is.
 * @param  {Object} actualManager A webRTC manager.
 * @return {Proxy}
 */


// Other plugins.

/***/ }),

/***/ "./src/webrtcProxy/proxies/model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = modelProxy;

var _logs = __webpack_require__("./src/logs/index.js");

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Other plugins.
const log = (0, _logs.getLogManager)().getLogger('PROXY');

/**
 * Creates an ES6 Proxy to wrap a webRTC object.
 * @method modelProxy
 * @param  {Object}  base The base object being wrapped.
 * @param  {Channel} channel The channel to use for proxying commands.
 * @return {Proxy}   A proxied webRTC object.
 */


// Libraries.
function modelProxy(base, channel) {
  log.debug(`Creating proxy for ${base.type}.`, base);

  return new Proxy(base, {
    get: function (objTarget, prop, receiver) {
      /*
       * Tell redux-saga that this is not a promise.
       * Otherwise it will handle it differently under-the-hood and break things.
       * Ref: github.com/redux-saga/redux-saga/blob/master/packages/is/src/index.js#L10
       */
      if (!objTarget[prop] && prop === 'then') {
        return undefined;
      }

      /**
       * The base object used to create a model's proxy may have references to
       *    other webRTC objects. We need to proxy those references as well.
       * Session: localTracks, remoteTracks
       * Media: tracks
       */
      if (['localTracks', 'remoteTracks', 'tracks'].includes(prop)) {
        return objTarget[prop].map(track => modelProxy(track, channel));
      }

      if (objTarget[prop]) {
        // If something that actually exists is being accessed,
        //    then return that thing.
        return objTarget[prop];
      } else {
        // Otherwise, it's probably accessing a prop that it
        //    expects to be a function. So return a function proxy.
        return new Proxy(() => {}, {
          /**
           * Proxy function calls.
           * This function is called when the dummy function is called,
           * @example
           *    const someProp = base.someProp  // Triggers the above `get`.
           *    someProp()                      // Triggers this `apply`.
           * @param  {Function} funcTarget The dummy function.
           * @param  {boolean} thisArg The `base` object wrapped by the first proxy layer.
           * @param  {Array}  args List of function parameters.
           */
          apply: function (funcTarget, thisArg, args) {
            // Assemble the webRTC command to be sent over the channel.
            const operation = {
              type: thisArg.type,
              id: thisArg.id,
              operation: prop,
              params: args
            };

            log.info('media operation', operation);
            /*
             * All APIs will now return a Promise, even if they didn't
             *    before. This is needed to wait for the remote response.
             * Since sagas `yield` on these API calls, they will also wait
             *    until the promise resolves.
             */
            return new _promise2.default(resolve => {
              function callback(data) {
                log.info('model Callback: ', data);

                resolve(data);
              }

              const messageId = (0, _v2.default)();
              channel.send(messageId, operation, callback);
            });
          }
        });
      }
    }
  });
}

/***/ }),

/***/ "./src/webrtcProxy/proxyStack.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__("../../node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

exports.default = initializeProxy;

var _manager = __webpack_require__("./src/webrtcProxy/proxies/manager.js");

var _manager2 = _interopRequireDefault(_manager);

var _channel = __webpack_require__("./src/webrtcProxy/channel.js");

var _channel2 = _interopRequireDefault(_channel);

var _logs = __webpack_require__("./src/logs/index.js");

var _v = __webpack_require__("../../node_modules/uuid/v4.js");

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Other plugins.
// Proxy plugin.
const log = (0, _logs.getLogManager)().getLogger('PROXY');

/**
 * Creates a Proxied webRTC Stack.
 * This Proxy Stack is the replacement for the actual webRTC stack.
 * @method initializeProxy
 * @param {Object} webRTC The local webRTC stack.
 * @return {Object} The Proxy Stack.
 */


// Libraries.
function initializeProxy(webRTC) {
  // The base of the proxy stack.
  const base = {
    // Whether operations should be proxied.
    proxyMode: false,
    // The channel to use for proxying operations.
    channel: undefined,
    // Whether the Client side is ready.
    clientReady: false,
    // The proxied webRTC managers.
    managers: {}

    /*
     * Recreate each of the actual webRTC managers as a proxied manager.
     * Creating proxies at the manager level (instead of only at the stack level)
     *    allows the Proxy Stack to be used in scenarios where the managers
     *    themselves are stored (rather than only using the stack from the top
     *    level).
     * Specifically, this allows us to use the Proxy Stack in the webRTC examples
     *    for testing outside of the SDK/redux context.
     */
  };for (const manager in webRTC.managers) {
    base.managers[manager] = (0, _manager2.default)({
      type: manager,
      proxyMode: base.proxyMode,
      channel: base.channel
    }, webRTC.managers[manager]);
  }

  /**
   * Sets proxy mode for the Proxy Stack.
   * @method setProxyMode
   * @param {boolean} value
   * @return {boolean} Whether the setting was successfully changed or not.
   */
  const setProxyMode = value => {
    if (typeof value !== 'boolean') {
      log.debug('Provided value is not a boolean; cannot set proxy mode.');
      return false;
    }

    log.debug('Setting proxyMode for managers to ' + value);
    base.proxyMode = value;

    for (const manProxy in base.managers) {
      base.managers[manProxy].proxyMode = value;
    }
    return true;
  };

  /**
   * Retreives the current mode of the Proxy Stack.
   * @method getProxyMode
   * @return {boolean}
   */
  const getProxyMode = () => {
    return base.proxyMode;
  };

  /**
   * Sets the channel to be used for proxying operations.
   * @method setChannel
   * @param {Channel} channel
   */
  const setChannel = channel => {
    // TODO: How to unset a channel?
    // TODO: Make (more) sure its a valid channel.
    if (!channel || !channel.send) {
      log.debug('Provided channel does not support the expected interface.');
      return false;
    }

    const wrappedChannel = (0, _channel2.default)(channel);
    log.debug('Setting channel for proxy use.');
    base.channel = wrappedChannel;

    for (const manProxy in base.managers) {
      base.managers[manProxy].channel = wrappedChannel;
    }

    // TODO: Have an API for this.
    // setTimeout(initialize, 1000)

    return true;
  };

  /**
   * Retreives the current channel to be used.
   * @method getChannel
   * @return {Channel}
   */
  const getChannel = () => {
    return base.channel;
  };

  /**
   * Sets the listener function for receiving messages from the channel.
   * @method setReceiver
   * @param  {Function} listener
   */
  const onMessage = listener => {
    base.channel.receive = listener;
  };

  /**
   * Attempts to initialize the Client side to be ready for use.
   * @method initialize
   * @param {Object} config WebRTC stack configuration.
   */
  const initialize = config => {
    return new _promise2.default((resolve, reject) => {
      if (!base.clientReady && base.channel) {
        const callback = data => {
          log.debug('Received initialize response.', data);
          if (data.initialized) {
            // The Client is now ready.
            base.clientReady = true;
            resolve();
          } else {
            reject(new Error('Remote end not initialized.'));
          }
        };

        log.debug('Initializing remote webRTC stack.', config);
        const messageId = (0, _v2.default)();
        base.channel.send(messageId, { initialize: true, config: config }, callback);
      } else {
        log.info('Either Client is already ready or no channel to use.');
        reject(new Error('Either Client is already ready or no channel to use.'));
      }
    });
  };

  /**
   * Set the SDP handlers the webRTC stack should use with the pipeline.
   * @method setHandlers
   * @param  {Array} handlers List of SDP handlers.
   */
  function setHandlers(handlers) {
    webRTC.sdp.pipeline.setHandlers(handlers);
  }

  return {
    // Proxy stack specific.
    setProxyMode,
    getProxyMode,
    setChannel,
    getChannel,
    onMessage,
    // webRTC imitations.
    initialize,
    sdp: {
      pipeline: {
        setHandlers
      }
    },
    managers: base.managers
  };
}

/***/ }),

/***/ "./src/webrtcProxy/sagas/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMode = setMode;
exports.setChannel = setChannel;
exports.initializeRemote = initializeRemote;

var _actionTypes = __webpack_require__("./src/webrtcProxy/interface/actionTypes.js");

var actionTypes = _interopRequireWildcard(_actionTypes);

var _proxyStack = __webpack_require__("./src/webrtcProxy/sagas/proxyStack.js");

var sagas = _interopRequireWildcard(_proxyStack);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function* setMode(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.SET_MODE, sagas.setProxyMode, webRTC);
}

// Libraries.
// Proxy plugin.
function* setChannel(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.SET_CHANNEL, sagas.setChannel, webRTC);
}

function* initializeRemote(webRTC) {
  yield (0, _effects.takeEvery)(actionTypes.INITIALIZE, sagas.initializeRemote, webRTC);
}

/***/ }),

/***/ "./src/webrtcProxy/sagas/proxyStack.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setProxyMode = setProxyMode;
exports.setChannel = setChannel;
exports.handleMessages = handleMessages;
exports.initializeRemote = initializeRemote;

var _actions = __webpack_require__("./src/webrtcProxy/interface/actions.js");

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__("./src/call/interfaceNew/selectors.js");

var _logs = __webpack_require__("./src/logs/index.js");

var _errors = __webpack_require__("./src/errors/index.js");

var _errors2 = _interopRequireDefault(_errors);

var _effects = __webpack_require__("../../node_modules/redux-saga/es/effects.js");

var _reduxSaga = __webpack_require__("../../node_modules/redux-saga/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Libraries.
// Proxy Plugin.
const log = (0, _logs.getLogManager)().getLogger('PROXY');

/**
 * Sets the proxy mode for the Proxy Stack.
 * @method setProxyMode
 * @param {Object} webRTC The Proxy Stack.
 * @param {Object} action
 */


// Helpers.


// Other plugins.
function* setProxyMode(webRTC, action) {
  // Check to see if there are any on-going calls.
  const calls = yield (0, _effects.select)(_selectors.getActiveCalls);

  if (calls.length > 0) {
    yield (0, _effects.put)(actions.setProxyModeFinish({
      error: new _errors2.default({
        code: 'proxy:3',
        message: 'Cannot change proxy mode while there are on-going calls.'
      })
    }));
    return;
  }

  const value = action.payload.value;
  const result = yield (0, _effects.call)([webRTC, 'setProxyMode'], value);

  const response = {
    value
    // If the mode wasn't set, define an error to be included
    //    in the finish action.
  };if (!result) {
    response.error = new _errors2.default({
      code: 'proxy:1',
      message: `Failed to set proxy mode to ${value}.`
    });
  }

  yield (0, _effects.put)(actions.setProxyModeFinish(response));
}

/**
 * Sets the channel for the Proxy Stack.
 * @method setChannel
 * @param {Object} webRTC The Proxy Stack.
 * @param {Object} action
 */
function* setChannel(webRTC, action) {
  // Check to see if there are any on-going calls.
  const calls = yield (0, _effects.select)(_selectors.getActiveCalls);

  if (calls.length > 0) {
    yield (0, _effects.put)(actions.setChannelFinish({
      error: new _errors2.default({
        code: 'proxy:3',
        message: 'Cannot set channel while there are on-going calls.'
      })
    }));
    return;
  }

  const channel = action.payload.channel;
  const result = yield (0, _effects.call)([webRTC, 'setChannel'], channel);

  const response = {};
  // If the channel wasn't set, define an error to be included
  //    in the finish action.
  if (!result) {
    response.error = new _errors2.default({
      code: 'proxy:2',
      message: 'Failed to set proxy channel.'
    });
  } else {
    // Channel was successfully set.
    // Listen for messages received from the channel.
    yield (0, _effects.fork)(handleMessages, webRTC);
  }

  yield (0, _effects.put)(actions.setChannelFinish(response));
}

/**
 * Handles (non-reply) messages received from the Client Host.
 * @method handleMessages
 * @param  {Object}  webRTC The webRTC stack.
 */
function* handleMessages(webRTC) {
  // Setup an event channel to bring the messages into redux-saga's context.
  const messageChannel = (0, _reduxSaga.eventChannel)(emit => {
    /**
     * Set the listener function on the Proxy Stack for
     *    receiving messages. It simply "emits" the entire
     *    messages into the event channel.
     */
    webRTC.onMessage((messageId, data) => {
      emit({ messageId, data });
    });

    return () => {
      // Unsubscribe by removing any listener function.
      webRTC.onMessage(() => {});
    };
  });

  while (true) {
    const { messageId, data } = yield (0, _effects.take)(messageChannel);
    log.debug(`Received message from channel: ${messageId}`);

    // If the received message is an event, dispatch it.
    if (data.event) {
      yield (0, _effects.put)(data.event);
    } else {
      log.debug('Received unknown message type; ignoring message.', data);
    }
  }
}

function* initializeRemote(webRTC, action) {
  const error = yield (0, _effects.call)([webRTC, 'initialize'], action.payload.config);

  if (error) {
    yield (0, _effects.put)(actions.initializeRemoteFinish({ error: error.message }));
  } else {
    yield (0, _effects.put)(actions.initializeRemoteFinish({}));
  }
}

/***/ })

/******/ });
});
//# sourceMappingURL=kandy.cpaas2.js.map